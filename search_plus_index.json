{"./":{"url":"./","title":"README","keywords":"","body":"树莓派 树莓派重新编译rxtx生成适配arm系统的so文件 日志 磁盘挂载共享文件服务安装 tomcat对特殊字符过滤的规则 网站https加密 SQL优化技巧 记线上服务卡死排查记录 Java Java基础 Java并发 Java虚拟机 设计模式 创建型模式 结构型模式 行为型模式 计算机网络 TCP/IP HTTP HTTPS Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-18 14:59:46 "},"note/202001081.html":{"url":"note/202001081.html","title":"磁盘挂载共享文件服务安装","keywords":"","body":"centos磁盘挂载共享文件夹 [TOC] step1:安装nfs服务（报装服务器） yum -y install nfs-utils rpcbind 当看到complete!后说明安装成功。 step2:服务端配置（报装服务器） 1、在NFS服务端上创建共享目录/export/nfs并设置权限 mkdir -p /export/nfs chmod 666 /export/nfs/ 2、编辑export文件 vi /etc/exports 加入允许访问此共享目录的linux服务器IP /home/upload 172.28.18.24(rw,sync,no_root_squash,no_subtree_check) 3、重启rpcbind服务： service rpcbind restart 4、重启nfs服务： service nfs restart 5、exportfs使配置生效 exportfs 6、查看自己的共享服务： showmount -e -- showmount -e NFS服务器IP 8.查看已挂载目录： showmount -a step3:在目标服务器中使用mount命令指向nfs服务器（上图中的ip 172.28.18.24）(表务APP服务器) 目录：/home/upload 命令格式 # mount NFS服务器IP:共享目录 本地挂载点目录 yum install nfs-utils mount 172.28.18.22:/home/upload /home/upload ​ 20200108 by ccli Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-08 15:49:21 "},"note/20200108.html":{"url":"note/20200108.html","title":"tomcat对特殊字符过滤的规则","keywords":"","body":"tomcat对base64字符串特殊字符过滤的处理 ​ 20200108 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-08 15:23:35 "},"note/20180808.html":{"url":"note/20180808.html","title":"网站https加密","keywords":"","body":"网站https加密 修改tomcat server配置文件 自动跳转https ​ SSL ​ /* ​ ​ ​ CONFIDENTIAL ​ Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-09 13:04:14 "},"note/sql.html":{"url":"note/sql.html","title":"SQL优化技巧","keywords":"","body":"SQL优化技巧 一、一些常见的**SQL**实践 （**1**）负向条件查询不能使用索引 `select * from order where status!=0 and stauts!=1` not in/not exists都不是好习惯 可以优化为in查询： select * from order where status in(2,3) （**2**）前导模糊查询不能使用索引 select * from order where desc like '%XX' 而非前导模糊查询则可以： select * from order where desc like 'XX%' （**3**）数据区分度不大的字段不宜使用索引 select * from user where sex=1 原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。 经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。 （**4**）在属性上进行计算不能命中索引 select * from order where YEAR(date) 即使date上建立了索引，也会全表扫描，可优化为值计算： select * from order where date 或者： select * from order where date 二、并非周知的**SQL**实践 （**5）如果业务大部分是单条查询，使用Hash**索引性能更好，例如用户中心 select * from user where uid=? select * from user where login_name=? 原因： B-Tree索引的时间复杂度是O(log(n)) Hash索引的时间复杂度是O(1) （**6）允许为null**的列，查询有潜在大坑 单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集 select * from user where name != 'shenjian' 如果name允许为null，索引不存储null值，结果集中不会包含这些记录。 所以，请使用not null约束以及默认值。 （**7）复合索引最左前缀，并不是值SQL语句的where**顺序要和复合索引一致 用户中心建立了(login_name, passwd)的复合索引 select * from user where login_name=? and passwd=? select * from user where passwd=? and login_name=? 都能够命中索引 select * from user where login_name=? 也能命中索引，满足复合索引最左前缀 select * from user where passwd=? 不能命中索引，不满足复合索引最左前缀 （**8）使用ENUM**而不是字符串 ENUM保存的是TINYINT，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。 三、小众但有用的**SQL**实践 （**9）如果明确知道只有一条结果返回，limit 1**能够提高效率 select * from user where login_name=? 可以优化为： select * from user where login_name=? limit 1 原因： 你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动 （**10）把计算放到业务层而不是数据库层，除了节省数据的CPU**，还有意想不到的查询缓存优化效果 select * from order where date 这不是一个好的SQL实践，应该优化为： $curDate = date('Y-m-d'); $res = mysql_query( 'select * from order where date 原因： 释放了数据库的CPU 多次调用，传入的SQL相同，才可以利用查询缓存 （**11**）强制类型转换会全表扫描 select * from user where phone=13800001234 你以为会命中**phone**索引么？大错特错了，这个语句究竟要怎么改？ 末了，再加一条，不要使用select *（潜台词，文章的SQL都不合格 =_=），只返回需要的列，能够大大的节省数据传输量，与数据库的内存使用量哟。 (12)mysql分页优化 一般刚开始学SQL的时候，会这样写 SELECT * FROM table ORDER BY id LIMIT 1000, 10; 但在数据达到百万级的时候，这样写会慢死 SELECT * FROM table ORDER BY id LIMIT 1000000, 10; 也许耗费几十秒 网上很多优化的方法是这样的 SELECT * FROM table WHERE id >= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10; 是的，速度提升到0.x秒了，看样子还行了 可是，还不是完美的！ 以下这句才是完美的！ SELECT * FROM table WHERE id BETWEEN 1000000 AND 1000010; 比上面那句，还要再快5至10倍 另外，如果需要查询 id 不是连续的一段，最佳的方法就是先找出 id ，然后用 in 查询 SELECT * FROM table WHERE id IN(10000, 100000, 1000000...); (13)in多个字段的时候如果2个字段占据数据超过数据总量的大概百分30 就不会走索引 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-09 13:06:12 "},"note/记线上服务卡死排查记录20200317.html":{"url":"note/记线上服务卡死排查记录20200317.html","title":"记线上服务卡死排查记录","keywords":"","body":"工具：https://fastthread.io/ https://console.perfma.com/ 使用jstack -l pid>test.dump将线程堆栈日志保存下来（由于是线上服务要求必须当时解决，所以仅保存约1分钟的dump日志），然后使用mat工具进行分析发现 有35%的线程处于阻塞状态，然后对阻塞线程进行分类排序， 总共有一下几类（jdbc、log4j）,排除log4j应该是由于报错大量打日志导致的。 直接搜索locked关键字直接就看到有很多下图的记录，就知道锁表了，立刻重启数据库问题解决了。 后来分类发现 高亮部分有出现6次，数据库连接池使用的c3p0 这个locked出现的次数也很多，查看连接池配置最大连接数竟然只有5，顺便把连接数改大了一点，虽然没根本解决问题，根本问题在于程序导致的锁表。 分类后大致定位到死锁代码， 结合业务总结：由于大量访问这段代码调用脚本导致一张表死锁导致，完善这块代码彻底解决了这个问题。 参考排查步骤： Java线程Dump分析工具--jstack 　　jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息，如果是在64位机器上，需要指定选项\"-J-d64\"，Windows的jstack使用方式只支持以下的这种方式： jstack [-l][F] pid\\ 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。进程处于hung死状态可以用-F强制打出stack。 dump 文件里，值得关注的线程状态有： 死锁，Deadlock（重点关注） 执行中，Runnable 等待资源，Waiting on condition（重点关注） 等待获取监视器，Waiting on monitor entry（重点关注） 暂停，Suspended 对象等待中，Object.wait() 或 TIMED_WAITING 阻塞，Blocked（重点关注） 停止，Parked 在摘了另一篇博客的三种场景： 实例一：Waiting to lock 和 Blocked ;) \"RMI TCP Connection(267865)-172.16.5.25\" daemon prio=10 tid=0x00007fd508371000 nid=0x55ae waiting for monitor entry [0x00007fd4f8684000] java.lang.Thread.State: BLOCKED (on object monitor) at org.apache.log4j.Category.callAppenders(Category.java:201) - waiting to lock (a org.apache.log4j.Logger) at org.apache.log4j.Category.forcedLog(Category.java:388) at org.apache.log4j.Category.log(Category.java:853) at org.apache.commons.logging.impl.Log4JLogger.warn(Log4JLogger.java:234) at com.tuan.core.common.lang.cache.remote.SpyMemcachedClient.get(SpyMemcachedClient.java:110) ;) 说明： 1）线程状态是 Blocked，阻塞状态。说明线程等待资源超时！ 2）“ waiting to lock ”指，线程在等待给这个 0x00000000acf4d0c0 地址上锁（英文可描述为：trying to obtain 0x00000000acf4d0c0 lock）。 3）在 dump 日志里查找字符串 0x00000000acf4d0c0，发现有大量线程都在等待给这个地址上锁。如果能在日志里找到谁获得了这个锁（如locked ），就可以顺藤摸瓜了。 4）“waiting for monitor entry”说明此线程通过 synchronized(obj) {……} 申请进入了临界区，从而进入了下图1中的“Entry Set”队列，但该 obj 对应的 monitor 被其他线程拥有，所以本线程在 Entry Set 队列中等待。 5）第一行里，\"RMI TCP Connection(267865)-172.16.5.25\"是 Thread Name 。tid指Java Thread id。nid指native线程的id。prio是线程优先级。[0x00007fd4f8684000]是线程栈起始地址。 实例二：Waiting on condition 和 TIMED_WAITING ;) \"RMI TCP Connection(idle)\" daemon prio=10 tid=0x00007fd50834e800 nid=0x56b2 waiting on condition [0x00007fd4f1a59000] java.lang.Thread.State: TIMED_WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for (a java.util.concurrent.SynchronousQueue$TransferStack) at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198) at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:424) at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:323) at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:874) at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:945) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907) at java.lang.Thread.run(Thread.java:662) ;) 说明： 1）“TIMED_WAITING (parking)”中的 timed_waiting 指等待状态，但这里指定了时间，到达指定的时间后自动退出等待状态；parking指线程处于挂起中。 2）“waiting on condition”需要与堆栈中的“parking to wait for (a java.util.concurrent.SynchronousQueue$TransferStack)”结合来看。首先，本线程肯定是在等待某个条件的发生，来把自己唤醒。其次，SynchronousQueue 并不是一个队列，只是线程之间移交信息的机制，当我们把一个元素放入到 SynchronousQueue 中时必须有另一个线程正在等待接受移交的任务，因此这就是本线程在等待的条件。 3）别的就看不出来了。 实例三：in Obejct.wait() 和 TIMED_WAITING ;) \"RMI RenewClean-[172.16.5.19:28475]\" daemon prio=10 tid=0x0000000041428800 nid=0xb09 in Object.wait() [0x00007f34f4bd0000] java.lang.Thread.State: TIMED_WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:118) - locked (a java.lang.ref.ReferenceQueue$Lock) at sun.rmi.transport.DGCClient$EndpointEntry$RenewCleanThread.run(DGCClient.java:516) at java.lang.Thread.run(Thread.java:662) ;) 说明： 1）“TIMED_WAITING (on object monitor)”，对于本例而言，是因为本线程调用了 java.lang.Object.wait(long timeout) 而进入等待状态。 2）“Wait Set”中等待的线程状态就是“ in Object.wait() ”。当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃了 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll() ，“ Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的 Monitor，恢复到运行态。 3）RMI RenewClean 是 DGCClient 的一部分。DGC 指的是 Distributed GC，即分布式垃圾回收。 4）请注意，是先 locked ，后 waiting on ，之所以先锁再等同一个对象，请看下面它的代码实现： static private class Lock { }; private Lock lock = new Lock(); public Reference remove(long timeout) { synchronized (lock) { Reference r = reallyPoll(); if (r != null) return r; for (;;) { lock.wait(timeout); r = reallyPoll(); …… } } 即，线程的执行中，先用 synchronized 获得了这个对象的 Monitor（对应于 locked ）；当执行到 lock.wait(timeout);，线程就放弃了 Monitor 的所有权，进入“Wait Set”队列（对应于 waiting on ）。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-18 15:33:36 "},"RraspberryPi/note1.html":{"url":"RraspberryPi/note1.html","title":"树莓派重新编译rxtx生成适配arm系统的so文件","keywords":"","body":"树莓派重新编译rxtx生成适配arm系统的so文件 （1）wget http://rxtx.qbang.org/pub/rxtx/rxtx-2.1-7r2.zip （2）unzip rxtx-2.1-7r2.zip （3）cd rxtx-2.1-7r2 编辑configure文件，把1.2|1.3|1.4|1.5全部替换成1.2|1.3|1.4|1.5|1.6|1.7|1.8* （4）uname -r 查看内核版本，编辑/usr/include/linux/version.h末尾添加#define UTS_RELEASE \"系统版本\" 然后执行以下命令： 1: sh ./configure 2: make 3: make install 参考: http://rxtx.qbang.org/wiki/index.php/Installation_on_Linux ​ https://blog.csdn.net/hekaibang/article/details/80420109 ​ https://github.com/inindev/raspberry-pi-rxtxlib Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-09 13:09:05 "},"java/basis.html":{"url":"java/basis.html","title":"Java基础","keywords":"","body":"一、前言 本部分内容主要包含以下： Java集合 Java反射 Java注解 Java反射 Java IO 其他面试点 以上内容都是Java中的基础知识，对于Java的学习很有帮助。其中集合、反射、IO等都是面试常问知识点，是必须要掌握的，因此整理在本部分当中。 二、目录 Java集合框架 Java集合——ArrayList Java集合——LinkedList Java集合——HashMap Java集合——TreeMap Java集合——LinkedHashMap Java泛型 Java反射(一) Java反射(二) Java反射(三) Java注解 Java IO(一) Java IO(二) RandomAccessFile Java NIO Java异常详解 Java抽象类和接口的区别 Java深拷贝和浅拷贝 Java transient关键字 Java finally与return执行顺序 Java 8 新特性 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/Collections-Framework.html":{"url":"java/basis/Collections-Framework.html","title":"Java集合框架","keywords":"","body":"一、Java集合类简介： Java集合大致可以分为Set、List、Queue和Map四种体系。 其中Set代表无序、不可重复的集合；List代表有序、重复的集合；而Map则代表具有映射关系的集合。Java 5 又增加了Queue体系集合，代表一种队列集合实现。 Java集合就像一种容器，可以把多个对象（实际上是对象的引用，但习惯上都称对象）“丢进”该容器中。从Java 5 增加了泛型以后，Java集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮。 1.Java集合和数组的区别： ①.数组长度在初始化时指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据。同时可以保存具有映射关系的数据（即关联数组，键值对 key-value）。 ②.数组元素即可以是基本类型的值，也可以是对象。集合里只能保存对象（实际上只是保存对象的引用变量），基本数据类型的变量要转换成对应的包装类才能放入集合类中。 2.Java集合类之间的继承关系: Java的集合类主要由两个接口派生而出：Collection和Map,Collection和Map是Java集合框架的根接口。 图中，ArrayList,HashSet,LinkedList,TreeSet是我们经常会有用到的已实现的集合类。 Map实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的，key用户标识集合里的每项数据。 图中，HashMap，TreeMap是我们经常会用到的集合类。 二、Collection接口： 1.简介 Collection接口是Set,Queue,List的父接口。Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作。由于方法比较多，就偷个懒，直接把JDK文档上的内容搬过来。 1.1.接口中定义的方法 可以看出Collection用法有：添加元素，删除元素，返回Collection集合的个数以及清空集合等。 其中重点介绍iterator()方法，该方法的返回值是Iterator。 1.2.使用Iterator遍历集合元素 Iterator接口经常被称作迭代器，它是Collection接口的父接口。但Iterator主要用于遍历集合中的元素。 Iterator接口中主要定义了2个方法： 下面程序简单示范了通过Iterator对象逐个获取元素的逻辑。 public class IteratorExample { public static void main(String[] args){ //创建集合，添加元素 Collection days = new ArrayList(); for(int i =0;i iterator = days.iterator(); while(iterator.hasNext()){//判断是否有下一个元素 Day next = iterator.next();//取出该元素 //逐个遍历，取得元素后进行后续操作 ..... } } } 注意： 当使用Iterator对集合元素进行迭代时，把集合元素的值传给了迭代变量（就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量。 下面的程序演示了这一点： public class IteratorExample { public static void main(String[] args) { List list = new ArrayList<>(); for (int i = 0; i iterator = list.iterator();//集合元素的值传给了迭代变量，仅仅传递了对象引用。保存的仅仅是指向对象内存空间的地址 while (iterator.hasNext()) { MyObject next = iterator.next(); next.num = 99; } System.out.println(list.toString()); } static class MyObject { int num; MyObject(int num) { this.num = num; } @Override public String toString() { return String.valueOf(num); } } } 输出结果如下： [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [99, 99, 99, 99, 99, 99, 99, 99, 99, 99] 下面具体介绍Collection接口的三个子接口Set，List，Queue。 2.Set集合 简介 Set集合与Collection集合基本相同，没有提供任何额外的方法。实际上Set就是Collection，只是行为略有不同（Set不允许包含重复元素）。 Set集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个Set集合中，则添加操作失败，add()方法返回false，且新元素不会被加入。 3.List集合 3.1.简介 List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。List集合默认按元素的添加顺序设置元素的索引，例如第一个添加的元素索引为0，第二个添加的元素索引为1...... List作为Collection接口的子接口，可以使用Collection接口里的全部方法。而且由于List是有序集合，因此List集合里增加了一些根据索引来操作集合元素的方法。 3.2.接口中定义的方法 void add(int index, Object element): 在列表的指定位置插入指定元素（可选操作）。 boolean addAll(int index, Collection c) : 将集合c 中的所有元素都插入到列表中的指定位置index处。 Object get(index): 返回列表中指定位置的元素。 int indexOf(Object o): 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。 int lastIndexOf(Object o): 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。 Object remove(int index): 移除列表中指定位置的元素。 Object set(int index, Object element): 用指定元素替换列表中指定位置的元素。 List subList(int fromIndex, int toIndex): 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的所有集合元素组成的子集。 Object[] toArray(): 返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素）。 除此之外，Java 8还为List接口添加了如下两个默认方法。 void replaceAll(UnaryOperator operator): 根据operator指定的计算规则重新设置List集合的所有元素。 void sort(Comparator c): 根据Comparator参数对List集合的元素排序。 4.Queue集合 4.1.简介 Queue用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。 4.2.接口中定义的方法 三、Map集合 1.简介 Map用户保存具有映射关系的数据，因此Map集合里保存着两组数，一组值用户保存Map里的key,另一组值用户保存Map里的value，key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较总是返回false。 如下图所描述，key和value之间存在单向一对一关系，即通过指定的key,总能找到唯一的、确定的value。从Map中取出数据时，只要给出指定的key，就可以取出对应的value。 2.Map集合与Set集合、List集合的关系 ①.与Set集合的关系 如果 把Map里的所有key放在一起看，它们就组成了一个Set集合（所有的key没有顺序，key与key之间不能重复），实际上Map确实包含了一个keySet()方法，用户返回Map里所有key组成的Set集合。 ②.与List集合的关系 如果把Map里的所有value放在一起来看，它们又非常类似于一个List：元素与元素之间可以重复，每个元素可以根据索引来查找，只是Map中索引不再使用整数值，而是以另外一个对象作为索引。 3.接口中定义的方法 Map中还包括一个内部类Entry，该类封装了一个key-value对。Entry包含如下三个方法： Map集合最典型的用法就是成对地添加、删除key-value对，然后就是判断该Map中是否包含指定key，是否包含指定value，也可以通过Map提供的keySet()方法获取所有key组成的集合，然后使用foreach循环来遍历Map的所有key，根据key即可遍历所有的value。下面程序代码示范Map的一些基本功能： public class MapTest { public static void main(String[] args){ Day day1 = new Day(1, 2, 3); Day day2 = new Day(2, 3, 4); Map map = new HashMap(); //成对放入key-value对 map.put(\"第一个\", day1); map.put(\"第二个\", day2); //判断是否包含指定的key System.out.println(map.containsKey(\"第一个\")); //判断是否包含指定的value System.out.println(map.containsValue(day1)); //循环遍历 //1.获得Map中所有key组成的set集合 Set keySet = map.keySet(); //2.使用foreach进行遍历 for (String key : keySet) { //根据key获得指定的value System.out.println(map.get(key)); } //根据key来移除key-value对 map.remove(\"第一个\"); System.out.println(map); } } 输出结果： true true Day [hour=2, minute=3, second=4] Day [hour=1, minute=2, second=3] {第二个=Day [hour=2, minute=3, second=4]} Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/arraylist.html":{"url":"java/basis/arraylist.html","title":"Java集合——ArrayList","keywords":"","body":"一、概述 以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。 按数组下标访问元素—get(i)/set(i,e) 的性能很高，这是数组的基本优势。 直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素—add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。 然后再来学习一下官方文档： Resizable-arrayimplementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.) ArrayList是一个相对来说比较简单的数据结构，最重要的一点就是它的自动扩容，可以认为就是我们常说的“动态数组”。来看一段简单的代码： ArrayList list = new ArrayList(); list.add(\"语文: 99\"); list.add(\"数学: 98\"); list.add(\"英语: 100\"); list.remove(0); 在执行这四条语句时，是这么变化的：其中，add操作可以理解为直接将数组的内容置位，remove操作可以理解为删除index为0的节点，并将后面元素移到0处。 二、 add函数 当我们在ArrayList中增加元素的时候，会使用add函数。他会将元素放到末尾。具体实现如下： public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } 我们可以看到他的实现其实最核心的内容就是ensureCapacityInternal。这个函数其实就是自动扩容机制的核心。我们依次来看一下他的具体实现 private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length > 0) grow(minCapacity); } private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; // 扩展为原来的1.5倍 int newCapacity = oldCapacity + (oldCapacity >> 1); // 如果扩为1.5倍还不满足需求，直接扩为需求值 if (newCapacity - minCapacity 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } 也就是说，当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。例如，默认的数组大小是10，也就是说当我们add10个元素之后，再进行一次add时，就会发生自动扩容，数组长度由10变为了15具体情况如下所示： 三、set和get函数 Array的set和get函数就比较简单了，先做index检查，然后执行赋值或访问操作： public E set(int index, E element) { rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; } public E get(int index) { rangeCheck(index); return elementData(index); } 四、remove函数 public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved > 0) // 把后面的往前移 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 把最后的置null elementData[--size] = null; // clear to let GC do its work return oldValue; } Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/linkedlist.html":{"url":"java/basis/linkedlist.html","title":"Java集合——LinkedList","keywords":"","body":" 一、 概述 以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。 按下标访问元素—get(i)/set(i,e) 要悲剧的遍历链表将指针移动到位(如果i>数组大小的一半，会从末尾移起)。 插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作—add()，addFirst()，removeLast()或用iterator()上的remove()能省掉指针的移动。 LinkedList是一个简单的数据结构，与ArrayList不同的是，他是基于链表实现的。 Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null). LinkedList list = new LinkedList(); list.add(\"语文: 1\"); list.add(\"数学: 2\"); list.add(\"英语: 3\"); 结构也相对简单一些，如下图所示： 二、 set和get函数 public E set(int index, E element) { checkElementIndex(index); Node x = node(index); E oldVal = x.item; x.item = element; return oldVal; } public E get(int index) { checkElementIndex(index); return node(index).item; } 这两个函数都调用了node函数，该函数会以O(n/2)的性能去获取一个节点，具体实现如下所示： Node node(int index) { // assert isElementIndex(index); if (index > 1)) { Node x = first; for (int i = 0; i x = last; for (int i = size - 1; i > index; i--) x = x.prev; return x; } } 就是判断index是在前半区间还是后半区间，如果在前半区间就从head搜索，而在后半区间就从tail搜索。而不是一直从头到尾的搜索。如此设计，将节点访问的复杂度由O(n)变为O(n/2)。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/hashmap.html":{"url":"java/basis/hashmap.html","title":"Java集合——HashMap","keywords":"","body":"一、概述 从本文你可以学习到： 什么时候会使用HashMap？他有什么特点？ 你知道HashMap的工作原理吗？ 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？ 你知道hash的实现吗？为什么要这样实现？ 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？ 当我们执行下面的操作时： HashMap map = new HashMap(); map.put(\"语文\", 1); map.put(\"数学\", 2); map.put(\"英语\", 3); map.put(\"历史\", 4); map.put(\"政治\", 5); map.put(\"地理\", 6); map.put(\"生物\", 7); map.put(\"化学\", 8); for(Entry entry : map.entrySet()) { System.out.println(entry.getKey() + \": \" + entry.getValue()); } 运行结果是 政治: 5生物: 7历史: 4数学: 2化学: 8语文: 1英语: 3地理: 6 发生了什么呢？下面是一个大致的结构，希望我们对HashMap的结构有一个感性的认识： 在官方文档中是这样描述HashMap的： Hash table basedimplementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it isunsynchronizedandpermits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time. 几个关键的信息：基于Map接口实现、允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。 二、两个重要的参数 在HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor) Initial capacity The capacity is the number of buckets in the hash table, The initial capacity is simply the capacity at the time the hash table is created. Load factor The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. 简单的说，Capacity就是bucket的大小，Load factor就是bucket填满程度的最大比例。如果对迭代性能要求很高的话，不要把capacity设置过大，也不要把load factor设置过小。当bucket中的entries的数目大于capacity*load factor时就需要调整bucket的大小为当前的2倍。 三、put函数的实现 put函数大致的思路为： 对key的hashCode()做hash，然后再计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树； 如果节点已经存在就替换old value(保证key的唯一性) 如果bucket满了(超过load factor*current capacity)，就要resize。 具体代码的实现如下： public V put(K key, V value) { // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node[] tab; Node p; int n, i; // tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 计算index，并对null做处理 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node e; K k; // 节点存在 if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; // 该链为树 else if (p instanceof TreeNode) e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value); // 该链为链表 else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } // 写入 if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 超过load factor*current capacity，resize if (++size > threshold) resize(); afterNodeInsertion(evict); return null; } 四、get函数的实现 在理解了put之后，get就很简单了。大致思路如下： bucket里的第一个节点，直接命中； 如果有冲突，则通过key.equals(k)去查找对应的entry 若为树，则在树中通过key.equals(k)查找，O(logn)； 若为链表，则在链表中通过key.equals(k)查找，O(n)。 具体代码的实现如下： public V get(Object key) { Node e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node getNode(int hash, Object key) { Node[] tab; Node first, e; int n; K k; if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) { // 直接命中 if (first.hash == hash && // always check first node ((k = first.key) == key || (key != null && key.equals(k)))) return first; // 未命中 if ((e = first.next) != null) { // 在树中get if (first instanceof TreeNode) return ((TreeNode)first).getTreeNode(hash, key); // 在链表中get do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 五、hash函数的实现 在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示： 在对hashCode()计算hash时具体实现是这样的： static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } 可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。其中代码注释是这样写的： Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff betweenspeed, utility, and qualityof bit-spreading. Because many common sets of hashes are alreadyreasonably distributed(so don’t benefit from spreading), and becausewe use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds. 在设计hash函数时，因为目前的table长度n为2的幂，而计算下标的时候，是这样实现的(使用&位操作，而非%求余)： (n - 1) & hash 设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在n - 1为15(0x1111)时，其实散列真正生效的只是低4bit的有效位，当然容易碰撞了。 因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。 如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞(we use trees to handle large sets of collisions in bins)，在JEP-180中，描述了这个问题： Improve the performance of java.util.HashMap under high hash-collision conditions byusing balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class. 之前已经提过，在获取HashMap的元素时，基本分两步： 首先根据hashCode()做hash，然后确定bucket的index； 如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。 在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。 因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题，在Java 8：HashMap的性能提升一文中有性能测试的结果。 六、RESIZE的实现 当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的： Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must eitherstay at same index, ormove with a power of two offsetin the new table. 大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。 怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示： 因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。 下面是代码的具体实现： final Node[] resize() { Node[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap = DEFAULT_INITIAL_CAPACITY) newThr = oldThr 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 计算新的resize上限 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap [] newTab = (Node[])new Node[newCap]; table = newTab; if (oldTab != null) { // 把每个bucket都移动到新的buckets中 for (int j = 0; j e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash & (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode)e).split(this, newTab, j, oldCap); else { // preserve order Node loHead = null, loTail = null; Node hiHead = null, hiTail = null; Node next; do { next = e.next; // 原索引 if ((e.hash & oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } // 原索引+oldCap else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } // 原索引+oldCap放到bucket里 if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 七、总结 我们现在可以回答开始的几个问题，加深对HashMap的理解： 1. 什么时候会使用HashMap？他有什么特点？是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。 2. 你知道HashMap的工作原理吗？通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。 3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？通过对key的hashCode()进行hashing，并计算下标( (n-1) & hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点 4. 你知道hash的实现吗？为什么要这样实现？在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h >>> 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。 5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/treemap.html":{"url":"java/basis/treemap.html","title":"Java集合——TreeMap","keywords":"","body":"一、概述 A Red-Black tree based NavigableMap implementation. The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used.This implementation provides guaranteed log(n) time cost for the containsKey, get, put and remove operations. Algorithms are adaptations of those in Cormen, Leiserson, and Rivest’s Introduction to Algorithms. 之前已经学习过HashMap和LinkedHashMap了，HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了。 TreeMap tmap = new TreeMap(); tmap.put(1, \"语文\"); tmap.put(3, \"英语\"); tmap.put(2, \"数学\"); tmap.put(4, \"政治\"); tmap.put(5, \"历史\"); tmap.put(6, \"地理\"); tmap.put(7, \"生物\"); tmap.put(8, \"化学\"); for(Entry entry : tmap.entrySet()) { System.out.println(entry.getKey() + \": \" + entry.getValue()); } 其大致的结构如下所示：使用红黑树的好处是能够使得树具有不错的平衡性，这样操作的速度就可以达到log(n)的水平了。具体红黑树的实现不在这里赘述，可以参考数据结构之红黑树、wikipedia-红黑树等的实现。 二、 put函数 Associates the specified value with the specified key in this map.If the map previously contained a mapping for the key, the old value is replaced. 如果存在的话，old value被替换；如果不存在的话，则新添一个节点，然后对做红黑树的平衡操作。 public V put(K key, V value) { Entry t = root; if (t == null) { compare(key, key); // type (and possibly null) check root = new Entry<>(key, value, null); size = 1; modCount++; return null; } int cmp; Entry parent; // split comparator and comparable paths Comparator cpr = comparator; // 如果该节点存在，则替换值直接返回 if (cpr != null) { do { parent = t; cmp = cpr.compare(key, t.key); if (cmp 0) t = t.right; else return t.setValue(value); } while (t != null); } else { if (key == null) throw new NullPointerException(); @SuppressWarnings(\"unchecked\") Comparable k = (Comparable) key; do { parent = t; cmp = k.compareTo(t.key); if (cmp 0) t = t.right; else return t.setValue(value); } while (t != null); } // 如果该节点未存在，则新建 Entry e = new Entry<>(key, value, parent); if (cmp 三、 get函数 get函数则相对来说比较简单，以log(n)的复杂度进行get。 final Entry getEntry(Object key) { // Offload comparator-based version for sake of performance if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); @SuppressWarnings(\"unchecked\") Comparable k = (Comparable) key; Entry p = root; // 按照二叉树搜索的方式进行搜索，搜到返回 while (p != null) { int cmp = k.compareTo(p.key); if (cmp 0) p = p.right; else return p; } return null; } public V get(Object key) { Entry p = getEntry(key); return (p==null ? null : p.value); } 四、successor后继 TreeMap是如何保证其迭代输出是有序的呢？其实从宏观上来讲，就相当于树的中序遍历(LDR)。我们先看一下迭代输出的步骤 for(Entry entry : tmap.entrySet()) { System.out.println(entry.getKey() + \": \" + entry.getValue()); } 根据The enhanced for statement，for语句会做如下转换为： for(Iterator> it = tmap.entrySet().iterator() ; tmap.hasNext(); ) { Entry entry = it.next(); System.out.println(entry.getKey() + \": \" + entry.getValue()); } 在it.next()的调用中会使用nextEntry调用successor这个是过的后继的重点，具体实现如下： static TreeMap.Entry successor(Entry t) { if (t == null) return null; else if (t.right != null) { // 有右子树的节点，后继节点就是右子树的“最左节点” // 因为“最左子树”是右子树的最小节点 Entry p = t.right; while (p.left != null) p = p.left; return p; } else { // 如果右子树为空，则寻找当前节点所在左子树的第一个祖先节点 // 因为左子树找完了，根据LDR该D了 Entry p = t.parent; Entry ch = t; // 保证左子树 while (p != null && ch == p.right) { ch = p; p = p.parent; } return p; } } 怎么理解这个successor呢？只要记住，这个是中序遍历就好了，L-D-R。具体细节如下： a. 空节点，没有后继b. 有右子树的节点，后继就是右子树的“最左节点”c. 无右子树的节点，后继就是该节点所在左子树的第一个祖先节点 a.好理解，不过b, c，有点像绕口令啊，没关系，上图举个例子就懂了！ 有右子树的节点，节点的下一个节点，肯定在右子树中，而右子树中“最左”的那个节点则是右子树中最小的一个，那么当然是右子树的“最左节点”，就好像下图所示： 无右子树的节点，先找到这个节点所在的左子树(右图)，那么这个节点所在的左子树的父节点(绿色节点)，就是下一个节点。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/LinkedHashMap.html":{"url":"java/basis/LinkedHashMap.html","title":"Java集合——LinkedHashMap","keywords":"","body":"一、 概述 在理解了HashMap后，我们来学习LinkedHashMap的工作原理及实现。首先还是类似的，我们写一个简单的LinkedHashMap的程序： LinkedHashMap lmap = new LinkedHashMap(); lmap.put(\"语文\", 1); lmap.put(\"数学\", 2); lmap.put(\"英语\", 3); lmap.put(\"历史\", 4); lmap.put(\"政治\", 5); lmap.put(\"地理\", 6); lmap.put(\"生物\", 7); lmap.put(\"化学\", 8); for(Entry entry : lmap.entrySet()) { System.out.println(entry.getKey() + \": \" + entry.getValue()); } 运行结果是： 语文: 1 数学: 2 英语: 3 历史: 4 政治: 5 地理: 6 生物: 7 化学: 8 我们可以观察到，和HashMap的运行结果不同，LinkedHashMap的迭代输出的结果保持了插入顺序。是什么样的结构使得LinkedHashMap具有如此特性呢？我们还是一样的看看LinkedHashMap的内部结构，对它有一个感性的认识： 没错，正如官方文档所说： Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). LinkedHashMap是Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。 二、 三个重点实现的函数 在HashMap中提到了下面的定义： // Callbacks to allow LinkedHashMap post-actions void afterNodeAccess(Node p) { } void afterNodeInsertion(boolean evict) { } void afterNodeRemoval(Node p) { } LinkedHashMap继承于HashMap，因此也重新实现了这3个函数，顾名思义这三个函数的作用分别是：节点访问后、节点插入后、节点移除后做一些事情。 afterNodeAccess函数 void afterNodeAccess(Node e) { // move node to last LinkedHashMap.Entry last; // 如果定义了accessOrder，那么就保证最近访问节点放到最后 if (accessOrder && (last = tail) != e) { LinkedHashMap.Entry p = (LinkedHashMap.Entry)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else { p.before = last; last.after = p; } tail = p; ++modCount; } } 就是说在进行put之后就算是对节点的访问了，那么这个时候就会更新链表，把最近访问的放到最后，保证链表。 afterNodeInsertion函数 void afterNodeInsertion(boolean evict) { // possibly remove eldest LinkedHashMap.Entry first; // 如果定义了溢出规则，则执行相应的溢出 if (evict && (first = head) != null && removeEldestEntry(first)) { K key = first.key; removeNode(hash(key), key, null, false, true); } } 如果用户定义了removeEldestEntry的规则，那么便可以执行相应的移除操作。 afterNodeRemoval函数 void afterNodeRemoval(Node e) { // unlink // 从链表中移除节点 LinkedHashMap.Entry p = (LinkedHashMap.Entry)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b; } 这个函数是在移除节点后调用的，就是将节点从双向链表中删除。 我们从上面3个函数看出来，基本上都是为了保证双向链表中的节点次序或者双向链表容量所做的一些额外的事情，目的就是保持双向链表中节点的顺序要从eldest到youngest。 三、 put和get函数 put函数在LinkedHashMap中未重新实现，只是实现了afterNodeAccess和afterNodeInsertion两个回调函数。get函数则重新实现并加入了afterNodeAccess来保证访问顺序，下面是get函数的具体实现： public V get(Object key) { Node e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value; } 值得注意的是，在accessOrder模式下，只要执行get或者put等操作的时候，就会产生structural modification。官方文档是这么描述的： A structural modification is any operation that adds or deletes one or more mappings or, in the case of access-ordered linked hash maps, affects iteration order. In insertion-ordered linked hash maps, merely changing the value associated with a key that is already contained in the map is not a structural modification. In access-ordered linked hash maps, merely querying the map with get is a structural modification. 总之，LinkedHashMap不愧是HashMap的儿子，和老子太像了，当然，青出于蓝而胜于蓝，LinkedHashMap的其他的操作也基本上都是为了维护好那个具有访问顺序的双向链表。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/genericity.html":{"url":"java/basis/genericity.html","title":"Java泛型","keywords":"","body":"一、泛型简介 1.引入泛型的目的 了解引入泛型的动机，就先从语法糖开始了解。 语法糖 语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家Peter.J.Landin发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。Java中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖。 泛型的目的： Java 泛型就是把一种语法糖，通过泛型使得在编译阶段完成一些类型转换的工作，避免在运行时强制类型转换而出现ClassCastException，即类型转换异常。 2.泛型初探 JDK 1.5 时才增加了泛型，并在很大程度上都是方便集合的使用，使其能够记住其元素的数据类型。 在泛型（Generic type或Generics）出现之前，是这么写代码的： public static void main(String[] args) { List list = new ArrayList(); list.add(\"123\"); list.add(\"456\"); System.out.println((String)list.get(0)); } 当然这是完全允许的，因为List里面的内容是Object类型的，自然任何对象类型都可以放入、都可以取出，但是这么写会有两个问题： 1、当一个对象放入集合时，集合不会记住此对象的类型，当再次从集合中取出此对象时，该对象的编译类型变成了Object。 2、运行时需要人为地强制转换类型到具体目标，实际的程序绝不会这么简单，一个不小心就会出现java.lang.ClassCastException。 所以，泛型出现之后，上面的代码就改成了大家都熟知的写法： public static void main(String[] args) { List list = new ArrayList(); list.add(\"123\"); list.add(\"456\"); System.out.println(list.get(0)); } 这就是泛型。泛型是对Java语言类型系统的一种扩展，有点类似于C++的模板，可以把类型参数看作是使用参数化类型时指定的类型的一个占位符。引入泛型，是对Java语言一个较大的功能增强，带来了很多的好处。 3.泛型的好处 ①类型安全。类型错误现在在编译期间就被捕获到了，而不是在运行时当作java.lang.ClassCastException展示出来，将类型检查从运行时挪到编译时有助于开发者更容易找到错误，并提高程序的可靠性。 ②消除了代码中许多的强制类型转换，增强了代码的可读性。 ③为较大的优化带来了可能。 二、泛型的使用 1.泛型类和泛型接口 下面是JDK 1.5 以后，List接口，以及ArrayList类的代码片段。 //定义接口时指定了一个类型形参，该形参名为E public interface List extends Collection { //在该接口里，E可以作为类型使用 public E get(int index) {} public void add(E e) {} } //定义类时指定了一个类型形参，该形参名为E public class ArrayList extends AbstractList implements List { //在该类里，E可以作为类型使用 public void set(E e) { ....................... } } 这就是泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、类体内可当成类型使用，几乎所有可使用普通类型的地方都可以使用这种类型形参。 下面具体讲解泛型类的使用。泛型接口的使用与泛型类几乎相同，可以比对自行学习。 泛型类 定义一个容器类，存放键值对key-value，键值对的类型不确定，可以使用泛型来定义，分别指定为K和V。 public class Container { private K key; private V value; public Container(K k, V v) { key = k; value = v; } public K getkey() { return key; } public V getValue() { return value; } public void setKey() { this.key = key; } public void setValue() { this.value = value; } } 在使用Container类时，只需要指定K，V的具体类型即可，从而创建出逻辑上不同的Container实例，用来存放不同的数据类型。 public static void main(String[] args) { Container c1=new Container(\"name\",\"hello\"); Container c2=new Container(\"age\",22); Container c3=new Container(1.1,1.3); System.out.println(c1.getKey() + \" : \" + c1.getValue()); System.out.println(c2.getKey() + \" : \" + c2.getValue()); System.out.println(c3.getKey() + \" : \" + c3.getValue()); } 在JDK 1.7 增加了泛型的“菱形”语法：Java允许在构造器后不需要带完成的泛型信息，只要给出一对尖括号（<>）即可，Java可以推断尖括号里应该是什么泛型信息。如下所示： Container c1=new Container<>(\"name\",\"hello\"); Container c2=new Container<>(\"age\",22); 泛型类派生子类 当创建了带泛型声明的接口、父类之后，可以为该接口创建实现类，或者从该父类派生子类，需要注意：使用这些接口、父类派生子类时不能再包含类型形参，需要传入具体的类型。错误的方式： public class A extends Container{} 正确的方式： public class A extends Container{} 也可以不指定具体的类型，如下： public class A extends Container{} 此时系统会把K,V形参当成Object类型处理。 2.泛型的方法 前面在介绍泛型类和泛型接口中提到，可以在泛型类、泛型接口的方法中，把泛型中声明的类型形参当成普通类型使用。 如下面的方式： public class Container { ........................ public K getkey() { return key; } public void setKey() { this.key = key; } .................... } 但在另外一些情况下，在类、接口中没有使用泛型时，定义方法时想定义类型形参，就会使用泛型方法。如下方式： public class Main{ public static void out(T t){ System.out.println(t); } public static void main(String[] args){ out(\"hansheng\"); out(123); } } 所谓泛型方法，就是在声明方法时定义一个或多个类型形参。 泛型方法的用法格式如下： 修饰符 返回值类型 方法名（形参列表）｛ 方法体 ｝ 注意： 方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。 class Demo{ public T fun(T t){ // 可以接收任意类型的数据 return t ; // 直接把参数返回 } }; public class GenericsDemo26{ public static void main(String args[]){ Demo d = new Demo() ; // 实例化Demo对象 String str = d.fun(\"汤姆\") ; // 传递字符串 int i = d.fun(30) ; // 传递数字，自动装箱 System.out.println(str) ; // 输出内容 System.out.println(i) ; // 输出内容 } }; 当调用fun()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。 3.泛型构造器 正如泛型方法允许在方法签名中声明类型形参一样，Java也允许在构造器签名中声明类型形参，这样就产生了所谓的泛型构造器。和使用普通泛型方法一样没区别，一种是显式指定泛型参数，另一种是隐式推断，如果是显式指定则以显式指定的类型参数为准，如果传入的参数的类型和指定的类型实参不符，将会编译报错。 public class Person { public Person(T t) { System.out.println(t); } } public static void main(String[] args){ //隐式 new Person(22); //显示 new Person(\"hello\"); } 这里唯一需要特殊注明的就是，如果构造器是泛型构造器，同时该类也是一个泛型类的情况下应该如何使用泛型构造器：因为泛型构造器可以显式指定自己的类型参数（需要用到菱形，放在构造器之前），而泛型类自己的类型实参也需要指定（菱形放在构造器之后），这就同时出现了两个菱形了，这就会有一些小问题，具体用法再这里总结一下。以下面这个例子为代表 public class Person { public Person(T t) { System.out.println(t); } } 这种用法：Person a = new Person<>(15);这种语法不允许，会直接编译报错！ 三、类型通配符 顾名思义就是匹配任意类型的类型实参。 类型通配符是一个问号（？)，将一个问号作为类型实参传给List集合，写作：List（意思是元素类型未知的List）。这个问号（？）被成为通配符，它的元素类型可以匹配任何类型。 public void test(List c){ for(int i =0;i 现在可以传入任何类型的List来调用test()方法，程序依然可以访问集合c中的元素，其类型是Object。 List c = new ArrayList(); //编译器报错 c.add(new Object()); 但是并不能把元素加入到其中。因为程序无法确定c集合中元素的类型，所以不能向其添加对象。下面就该引入带限通配符，来确定集合元素中的类型。 带限通配符 简单来讲，使用通配符的目的是来限制泛型的类型参数的类型，使其满足某种条件，固定为某些类。 主要分为两类即：上限通配符和下限通配符。 1.上限通配符 如果想限制使用泛型类别时，只能用某个特定类型或者是其子类型才能实例化该类型时，可以在定义类型时，使用extends关键字指定这个类型必须是继承某个类，或者实现某个接口，也可以是这个类或接口本身。 它表示集合中的所有元素都是Shape类型或者其子类 List 这就是所谓的上限通配符，使用关键字extends来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身。例如： //Circle是其子类 List list = new ArrayList(); 这样就确定集合中元素的类型，虽然不确定具体的类型，但最起码知道其父类。然后进行其他操作。 2.下限通配符 如果想限制使用泛型类别时，只能用某个特定类型或者是其父类型才能实例化该类型时，可以在定义类型时，使用super关键字指定这个类型必须是是某个类的父类，或者是某个接口的父接口，也可以是这个类或接口本身。 它表示集合中的所有元素都是Circle类型或者其父类 List 这就是所谓的下限通配符，使用关键字super来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身。例如： //Shape是其父类 List list = new ArrayList(); 四、类型擦除 Class c1=new ArrayList().getClass(); Class c2=new ArrayList().getClass(); System.out.println(c1==c2); 程序输出： true。 这是因为不管为泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一类处理，在内存中也只占用一块内存空间。从Java泛型这一概念提出的目的来看，其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。 在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/reflection1.html":{"url":"java/basis/reflection1.html","title":"Java反射(一)","keywords":"","body":"一、概述 Java反射机制定义 Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。Java 反射机制的功能 1.在运行时判断任意一个对象所属的类。 2.在运行时构造任意一个类的对象。 3.在运行时判断任意一个类所具有的成员变量和方法。 4.在运行时调用任意一个对象的方法。 5.生成动态代理。 Java 反射机制的应用场景 1.逆向代码 ，例如反编译 2.与注解相结合的框架 例如Retrofit 3.单纯的反射机制应用框架 例如EventBus 4.动态生成类框架 例如Gson 二、通过Java反射查看类信息 获得Class对象每个类被加载之后，系统就会为该类生成一个对应的Class对象。通过该Class对象就可以访问到JVM中的这个类。 在Java程序中获得Class对象通常有如下三种方式： 1.使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定名（必须添加完整包名）。 2.调用某个类的class属性来获取该类对应的Class对象。 3.调用某个对象的getClass()方法。该方法是java.lang.Object类中的一个方法。 //第一种方式 通过Class类的静态方法——forName()来实现 class1 = Class.forName(\"com.lvr.reflection.Person\"); //第二种方式 通过类的class属性 class1 = Person.class; //第三种方式 通过对象getClass方法 Person person = new Person(); Class class1 = person.getClass(); 获取class对象的属性、方法、构造函数等 1.获取class对象的成员变量 Field[] allFields = class1.getDeclaredFields();//获取class对象的所有属性 Field[] publicFields = class1.getFields();//获取class对象的public属性 Field ageField = class1.getDeclaredField(\"age\");//获取class指定属性 Field desField = class1.getField(\"des\");//获取class指定的public属性 2.获取class对象的方法 Method[] methods = class1.getDeclaredMethods();//获取class对象的所有声明方法 Method[] allMethods = class1.getMethods();//获取class对象的所有public方法 包括父类的方法 Method method = class1.getMethod(\"info\", String.class);//返回次Class对象对应类的、带指定形参列表的public方法 Method declaredMethod = class1.getDeclaredMethod(\"info\", String.class);//返回次Class对象对应类的、带指定形参列表的方法 3.获取class对象的构造函数 Constructor[] allConstructors = class1.getDeclaredConstructors();//获取class对象的所有声明构造函数 Constructor[] publicConstructors = class1.getConstructors();//获取class对象public构造函数 Constructor constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数 Constructor publicConstructor = class1.getConstructor(String.class);//获取指定声明的public构造函数 4.其他方法 Annotation[] annotations = (Annotation[]) class1.getAnnotations();//获取class对象的所有注解 Annotation annotation = (Annotation) class1.getAnnotation(Deprecated.class);//获取class对象指定注解 Type genericSuperclass = class1.getGenericSuperclass();//获取class对象的直接超类的 Type Type[] interfaceTypes = class1.getGenericInterfaces();//获取class对象的所有接口的type集合 获取class对象的信息 比较多。 boolean isPrimitive = class1.isPrimitive();//判断是否是基础类型 boolean isArray = class1.isArray();//判断是否是集合类 boolean isAnnotation = class1.isAnnotation();//判断是否是注解类 boolean isInterface = class1.isInterface();//判断是否是接口类 boolean isEnum = class1.isEnum();//判断是否是枚举类 boolean isAnonymousClass = class1.isAnonymousClass();//判断是否是匿名内部类 boolean isAnnotationPresent = class1.isAnnotationPresent(Deprecated.class);//判断是否被某个注解类修饰 String className = class1.getName();//获取class名字 包含包名路径 Package aPackage = class1.getPackage();//获取class的包信息 String simpleName = class1.getSimpleName();//获取class类名 int modifiers = class1.getModifiers();//获取class访问权限 Class[] declaredClasses = class1.getDeclaredClasses();//内部类 Class declaringClass = class1.getDeclaringClass();//外部类 三、通过Java反射生成并操作对象 生成类的实例对象 1.使用Class对象的newInstance()方法来创建该Class对象对应类的实例。这种方式要求该Class对象的对应类有默认构造器，而执行newInstance()方法时实际上是利用默认构造器来创建该类的实例。 2.先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以选择使用指定的构造器来创建实例。 //第一种方式 Class对象调用newInstance()方法生成 Object obj = class1.newInstance(); //第二种方式 对象获得对应的Constructor对象，再通过该Constructor对象的newInstance()方法生成 Constructor constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数 obj = constructor.newInstance(\"hello\"); 调用类的方法 1.通过Class对象的getMethods()方法或者getMethod()方法获得指定方法，返回Method数组或对象。 2.调用Method对象中的Object invoke(Object obj, Object... args)方法。第一个参数对应调用该方法的实例对象，第二个参数对应该方法的参数。 // 生成新的对象：用newInstance()方法 Object obj = class1.newInstance(); //首先需要获得与该方法对应的Method对象 Method method = class1.getDeclaredMethod(\"setAge\", int.class); //调用指定的函数并传递参数 method.invoke(obj, 28); 当通过Method的invoke()方法来调用对应的方法时，Java会要求程序必须有调用该方法的权限。如果程序确实需要调用某个对象的private方法，则可以先调用Method对象的如下方法。setAccessible(boolean flag)：将Method对象的acessible设置为指定的布尔值。值为true，指示该Method在使用时应该取消Java语言的访问权限检查；值为false，则知识该Method在使用时要实施Java语言的访问权限检查。 访问成员变量值 1.通过Class对象的getFields()方法或者getField()方法获得指定方法，返回Field数组或对象。 2.Field提供了两组方法来读取或设置成员变量的值：getXXX(Object obj):获取obj对象的该成员变量的值。此处的XXX对应8种基本类型。如果该成员变量的类型是引用类型，则取消get后面的XXX。setXXX(Object obj,XXX val)：将obj对象的该成员变量设置成val值。 //生成新的对象：用newInstance()方法 Object obj = class1.newInstance(); //获取age成员变量 Field field = class1.getField(\"age\"); //将obj对象的age的值设置为10 field.setInt(obj, 10); //获取obj对象的age的值 field.getInt(obj); Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/reflection2.html":{"url":"java/basis/reflection2.html","title":"Java反射(二)","keywords":"","body":"一、代理模式 定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。 1、代理模式的理解 代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问。现实世界的代理人被授权执行当事人的一些事宜，无需当事人出面，从第三方的角度看，似乎当事人并不存在，因为他只和代理人通信。而事实上代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。在软件设计中，使用代理模式的意图也很多，比如因为安全原因需要屏蔽客户端直接访问真实对象，或者在远程调用中需要使用代理类处理远程方法调用的技术细节，也可能为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。 2、代理模式的参与者 代理模式的角色分四种： 主题接口：Subject 是委托对象和代理对象都共同实现的接口，即代理类的所实现的行为接口。Request() 是委托对象和代理对象共同拥有的方法。目标对象：ReaSubject 是原对象，也就是被代理的对象。代理对象：Proxy 是代理对象，用来封装真是主题类的代理类。客户端 ：使用代理类和主题接口完成一些工作。 3、代理模式的分类 代理的实现分为： 静态代理：代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。动态代理：代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。 4、代理模式的实现思路 1.代理对象和目标对象均实现同一个行为接口。 2.代理类和目标类分别具体实现接口逻辑。 3.在代理类的构造函数中实例化一个目标对象。 4.在代理类中调用目标对象的行为接口。 5.客户端想要调用目标对象的行为接口，只能通过代理类来操作。 5、静态代理模式的简单实现 public class ProxyDemo { public static void main(String args[]){ RealSubject subject = new RealSubject(); Proxy p = new Proxy(subject); p.request(); } } interface Subject{ void request(); } class RealSubject implements Subject{ public void request(){ System.out.println(\"request\"); } } class Proxy implements Subject{ private Subject subject; public Proxy(Subject subject){ this.subject = subject; } public void request(){ System.out.println(\"PreProcess\"); subject.request(); System.out.println(\"PostProcess\"); } } 目标对象(RealSubject )以及代理对象（Proxy）都实现了主题接口（Subject）。在代理对象（Proxy）中，通过构造函数传入目标对象(RealSubject )，然后重写主题接口（Subject）的request()方法，在该方法中调用目标对象(RealSubject )的request()方法，并可以添加一些额外的处理工作在目标对象(RealSubject )的request()方法的前后。 代理模式的好处： 假如有这样的需求，要在某些模块方法调用前后加上一些统一的前后处理操作，比如在添加购物车、修改订单等操作前后统一加上登陆验证与日志记录处理，该怎样实现？首先想到最简单的就是直接修改源码，在对应模块的对应方法前后添加操作。如果模块很多，你会发现，修改源码不仅非常麻烦、难以维护，而且会使代码显得十分臃肿。 这时候就轮到代理模式上场了，它可以在被调用方法前后加上自己的操作，而不需要更改被调用类的源码，大大地降低了模块之间的耦合性，体现了极大的优势。 静态代理比较简单，上面的简单实例就是静态代理的应用方式，下面介绍本篇文章的主题：动态代理。 二、Java反射机制与动态代理 动态代理的思路和上述思路一致，下面主要讲解如何实现。 1、动态代理介绍 动态代理是指在运行时动态生成代理类。即，代理类的字节码将在运行时生成并载入当前代理的 ClassLoader。与静态处理类相比，动态类有诸多好处。 ①不需要为(RealSubject )写一个形式上完全一样的封装类，假如主题接口（Subject）中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则目标对象和代理类都要修改，不利于系统维护； ②使用一些动态代理的生成方法甚至可以在运行时制定代理类的执行逻辑，从而大大提升系统的灵活性。 2、动态代理涉及的主要类 主要涉及两个类，这两个类都是java.lang.reflect包下的类，内部主要通过反射来实现的。 java.lang.reflect.Proxy:这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类。Proxy提供了用户创建动态代理类和代理对象的静态方法，它是所有动态代理类的父类。 java.lang.reflect.InvocationHandler:这里称他为\"调用处理器\"，它是一个接口。当调用动态代理类中的方法时，将会直接转接到执行自定义的InvocationHandler中的invoke()方法。即我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口，通过重写invoke()方法来执行具体内容。 Proxy提供了如下两个方法来创建动态代理类和动态代理实例。 static Class getProxyClass(ClassLoader loader, Class... interfaces) 返回代理类的java.lang.Class对象。第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区），第二个参数是接口（表明你这个代理类需要实现哪些接口），第三个参数是调用处理器类实例（指定代理类中具体要干什么），该代理类将实现interfaces所指定的所有接口，执行代理对象的每个方法时都会被替换执行InvocationHandler对象的invoke方法。 static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 返回代理类实例。参数与上述方法一致。 对应上述两种方法创建动态代理对象的方式： //创建一个InvocationHandler对象 InvocationHandler handler = new MyInvocationHandler(.args..); //使用Proxy生成一个动态代理类 Class proxyClass = Proxy.getProxyClass(RealSubject.class.getClassLoader(),RealSubject.class.getInterfaces(), handler); //获取proxyClass类中一个带InvocationHandler参数的构造器 Constructor constructor = proxyClass.getConstructor(InvocationHandler.class); //调用constructor的newInstance方法来创建动态实例 RealSubject real = (RealSubject)constructor.newInstance(handler); //创建一个InvocationHandler对象 InvocationHandler handler = new MyInvocationHandler(.args..); //使用Proxy直接生成一个动态代理对象 RealSubject real =Proxy.newProxyInstance(RealSubject.class.getClassLoader(),RealSubject.class.getInterfaces(), handler); newProxyInstance这个方法实际上做了两件事：第一，创建了一个新的类【代理类】，这个类实现了Class[] interfaces中的所有接口，并通过你指定的ClassLoader将生成的类的字节码加载到JVM中，创建Class对象；第二，以你传入的InvocationHandler作为参数创建一个代理类的实例并返回。 Proxy 类还有一些静态方法，比如： InvocationHandler getInvocationHandler(Object proxy):获得代理对象对应的调用处理器对象。 Class getProxyClass(ClassLoader loader, Class[] interfaces):根据类加载器和实现的接口获得代理类。 InvocationHandler 接口中有方法： invoke(Object proxy, Method method, Object[] args)这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，第一个参数是代理对象（表示哪个代理对象调用了method方法），第二个参数是 Method 对象（表示哪个方法被调用了），第三个参数是指定调用方法的参数。 3、动态代理模式的简单实现 public class DynamicProxyDemo { public static void main(String[] args) { //1.创建目标对象 RealSubject realSubject = new RealSubject(); //2.创建调用处理器对象 ProxyHandler handler = new ProxyHandler(realSubject); //3.动态生成代理对象 Subject proxySubject = (Subject)Proxy.newProxyInstance(RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(), handler); //4.通过代理对象调用方法 proxySubject.request(); } } /** * 主题接口 */ interface Subject{ void request(); } /** * 目标对象类 */ class RealSubject implements Subject{ public void request(){ System.out.println(\"====RealSubject Request====\"); } } /** * 代理类的调用处理器 */ class ProxyHandler implements InvocationHandler{ private Subject subject; public ProxyHandler(Subject subject){ this.subject = subject; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作 System.out.println(\"====before====\"); //调用RealSubject中的方法 Object result = method.invoke(subject, args); System.out.println(\"====after====\"); return result; } } 可以看到，我们通过newProxyInstance就产生了一个Subject 的实例，即代理类的实例，然后就可以通过Subject .request()，就会调用InvocationHandler中的invoke()方法，传入方法Method对象，以及调用方法的参数，通过Method.invoke调用RealSubject中的方法的request()方法。同时可以在InvocationHandler中的invoke()方法加入其他执行逻辑。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/reflection3.html":{"url":"java/basis/reflection3.html","title":"Java反射(三)","keywords":"","body":"一、泛型和Class类 从JDK 1.5 后，Java中引入泛型机制，Class类也增加了泛型功能，从而允许使用泛型来限制Class类，例如：String.class的类型实际上是Class。如果Class对应的类暂时未知，则使用Class(?是通配符)。通过反射中使用泛型，可以避免使用反射生成的对象需要强制类型转换。 泛型的好处众多，最主要的一点就是避免类型转换，防止出现ClassCastException，即类型转换异常。以下面程序为例： public class ObjectFactory { public static Object getInstance(String name){ try { //创建指定类对应的Class对象 Class cls = Class.forName(name); //返回使用该Class对象创建的实例 return cls.newInstance(); } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) { e.printStackTrace(); return null; } } } 上面程序是个工厂类，通过指定的字符串创建Class对象并创建一个类的实例对象返回。但是这个对象的类型是Object对象，取出实例后需要强制类型转换。如下例： Date date = (Date) ObjectFactory.getInstance(\"java.util.Date\"); 或者如下： String string = (String) ObjectFactory.getInstance(\"java.util.Date\"); 上面代码在编译时不会有任何问题，但是运行时将抛出ClassCastException异常，因为程序试图将一个Date对象转换成String对象。 但是泛型的出现后，就可以避免这种情况。 public class ObjectFactory { public static T getInstance(Class cls) { try { // 返回使用该Class对象创建的实例 return cls.newInstance(); } catch (InstantiationException | IllegalAccessException e) { e.printStackTrace(); return null; } } } 在上面程序的getInstance()方法中传入一个Class参数，这是一个泛型化的Class对象，调用该Class对象的newInstance()方法将返回一个T对象。 String instance = ObjectFactory.getInstance(String.class); 通过传入String.class便知道T代表String，所以返回的对象是String类型的，避免强制类型转换。 当然Class类引入泛型的好处不止这一点，在以后的实际应用中会更加能体会到。 二、使用反射来获取泛型信息 通过指定类对应的 Class 对象，可以获得该类里包含的所有 Field，不管该 Field 是使用 private 修饰，还是使用 public 修饰。获得了 Field 对象后，就可以很容易地获得该 Field 的数据类型，即使用如下代码即可获得指定 Field 的类型。 // 获取 Field 对象 f 的类型 Class a = f.getType(); 但这种方式只对普通类型的 Field 有效。如果该 Field 的类型是有泛型限制的类型，如 Map 类型，则不能准确地得到该 Field 的泛型参数。 为了获得指定 Field 的泛型类型，应先使用如下方法来获取指定 Field 的类型。 // 获得 Field 实例的泛型类型 Type type = f.getGenericType(); 然后将 Type 对象强制类型转换为 ParameterizedType 对象，ParameterizedType 代表被参数化的类型，也就是增加了泛型限制的类型。ParameterizedType 类提供了如下两个方法。 getRawType()：返回没有泛型信息的原始类型。 getActualTypeArguments()：返回泛型参数的类型。 下面是一个获取泛型类型的完整程序。 public class GenericTest { private Map score; public static void main(String[] args) throws Exception { Class clazz = GenericTest.class; Field f = clazz.getDeclaredField(\"score\"); // 直接使用getType()取出Field类型只对普通类型的Field有效 Class a = f.getType(); // 下面将看到仅输出java.util.Map System.out.println(\"score的类型是:\" + a); // 获得Field实例f的泛型类型 Type gType = f.getGenericType(); // 如果gType类型是ParameterizedType对象 if(gType instanceof ParameterizedType) { // 强制类型转换 ParameterizedType pType = (ParameterizedType)gType; // 获取原始类型 Type rType = pType.getRawType(); System.out.println(\"原始类型是：\" + rType); // 取得泛型类型的泛型参数 Type[] tArgs = pType.getActualTypeArguments(); System.out.println(\"泛型类型是:\"); for (int i = 0; i 输出结果： score 的类型是: interface java.util.Map原始类型是: interface java.util.Map泛型类型是:第 0 个泛型类型是: class java.lang.String第 1 个泛型类型是：class java.lang.Integer 从上面的运行结果可以看出，直接使用 Field 的 getType() 方法只能获取普通类型的 Field 的数据类型：对于增加了泛型参数的类型的 Field，应该使用 getGenericType() 方法来取得其类型。 Type 也是 java.lang.reflect 包下的一个接口，该接口代表所有类型的公共高级接口，Class 是 Type 接口的实现类。Type 包括原始类型、参数化类型、数组类型、类型变量和基本类型等。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/annotation.html":{"url":"java/basis/annotation.html","title":"Java注解","keywords":"","body":"一、元数据 要想理解注解（Annotation）的作用，就要先理解Java中元数据的概念。 1.元数据概念 元数据是关于数据的数据。在编程语言上下文中，元数据是添加到程序元素如方法、字段、类和包上的额外信息。对数据进行说明描述的数据。 2.元数据的作用 一般来说，元数据可以用于创建文档（根据程序元素上的注释创建文档），跟踪代码中的依赖性（可声明方法是重载，依赖父类的方法），执行编译时检查（可声明是否编译期检测），代码分析。如下：1） 编写文档：通过代码里标识的元数据生成文档　　2）代码分析：通过代码里标识的元数据对代码进行分析　　3）编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查 3.Java平台元数据 注解Annotation就是java平台的元数据，是 J2SE5.0新增加的功能，该机制允许在Java 代码中添加自定义注释，并允许通过反射（reflection），以编程方式访问元数据注释。通过提供为程序元素（类、方法等）附加额外数据的标准方法，元数据功能具有简化和改进许多应用程序开发领域的潜在能力，其中包括配置管理、框架实现和代码生成。 二、注解（Annotation） 1.注解（Annotation）的概念 注解(Annotation)在JDK1.5之后增加的一个新特性，注解的引入意义很大，有很多非常有名的框架，比如Hibernate、Spring等框架中都大量使用注解。注解作为程序的元数据嵌入到程序。注解可以被解析工具或编译工具解析。 关于注解（Annotation）的作用，其实就是上述元数据的作用。 注意：Annotation能被用来为程序元素（类、方法、成员变量等）设置元素据。Annotaion不影响程序代码的执行，无论增加、删除Annotation，代码都始终如一地执行。如果希望让程序中的Annotation起一定的作用，只有通过解析工具或编译工具对Annotation中的信息进行解析和处理。 2.内建注解 Java提供了多种内建的注解，下面接下几个比较常用的注解：@Override、@Deprecated、@SuppressWarnings以及@FunctionalInterface这4个注解。内建注解主要实现了元数据的第二个作用：编译检查。 @Override用途：用于告知编译器，我们需要覆写超类的当前方法。如果某个方法带有该注解但并没有覆写超类相应的方法，则编译器会生成一条错误信息。如果父类没有这个要覆写的方法，则编译器也会生成一条错误信息。 @Override可适用元素为方法，仅仅保留在java源文件中。 @Deprecated用途：使用这个注解，用于告知编译器，某一程序元素(比如方法，成员变量)不建议使用了（即过时了）。例如：Person类中的info()方法使用@Deprecated表示该方法过时了。 public class Person { @Deprecated public void info(){ } } 调用info()方法会编译器会出现警告，告知该方法已过时。 注解类型分析：@Deprecated可适合用于除注解类型声明之外的所有元素，保留时长为运行时。 @SuppressWarnings用途：用于告知编译器忽略特定的警告信息，例在泛型中使用原生数据类型，编译器会发出警告，当使用该注解后，则不会发出警告。 注解类型分析： @SuppressWarnings可适合用于除注解类型声明和包名之外的所有元素，仅仅保留在java源文件中。 该注解有方法value(）,可支持多个字符串参数，用户指定忽略哪种警告，例如： @SupressWarning(value={\"uncheck\",\"deprecation\"}) @FunctionalInterface用途：用户告知编译器，检查这个接口，保证该接口是函数式接口，即只能包含一个抽象方法，否则就会编译出错。 注解类型分析： @FunctionalInterface可适合用于注解类型声明，保留时长为运行时。 3.元Annotation JDK除了在java.lang提供了上述内建注解外，还在java.lang。annotation包下提供了6个Meta Annotation(元Annotataion)，其中有5个元Annotation都用于修饰其他的Annotation定义。其中@Repeatable专门用户定义Java 8 新增的可重复注解。 我们先介绍其中4个常用的修饰其他Annotation的元Annotation。在此之前，我们先了解如何自定义Annotation。 当一个接口直接继承java.lang.annotation.Annotation接口时，仍是接口，而并非注解。要想自定义注解类型，只能通过@interface关键字的方式，其实通过该方式会隐含地继承.Annotation接口。 @Documented @Documented用户指定被该元Annotation修饰的Annotation类将会被javadoc工具提取成文档，如果定义Annotation类时使用了@Documented修饰，则所有使用该Annotation修饰的程序元素的API文档中将会包含该Annotation说明。 例如： @Documented @Retention(RetentionPolicy.RUNTIME) @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE}) public @interface Deprecated { } 定义@Deprecated时使用了@Documented，则任何元素使用@Deprecated修饰时，在生成API文档时，将会包含@Deprecated的说明以下是String的一个过时的构造方法： @Deprecated public String(byte[] ascii,int hibyte,int offset, int count) 该注解实现了元数据的第一个功能：编写文档。 @Inherited @Inherited指定被它修饰的Annotation将具有继承性——如果某个类使用了@Xxx注解（定义该Annotation时使用了@Inherited修饰）修饰，则其子类将自动被@Xxx修饰。 @Retention @Retention：表示该注解类型的注解保留的时长。当注解类型声明中没有@Retention元注解，则默认保留策略为RetentionPolicy.CLASS。关于保留策略(RetentionPolicy)是枚举类型，共定义3种保留策略，如下表： @Target @Target：表示该注解类型的所适用的程序元素类型。当注解类型声明中没有@Target元注解，则默认为可适用所有的程序元素。如果存在指定的@Target元注解，则编译器强制实施相应的使用限制。关于程序元素(ElementType)是枚举类型，共定义8种程序元素，如下表： 三、自定义注解（Annotation） 创建自定义注解，与创建接口有几分相似，但注解需要以@开头。 @Documented @Target(ElementType.METHOD) @Inherited @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotataion{ String name(); String website() default \"hello\"; int revision() default 1; } 自定义注解中定义成员变量的规则： 其定义是以无形参的方法形式来声明的。即：注解方法不带参数，比如name()，website()；注解方法返回值类型：基本类型、String、Enums、Annotation以及前面这些类型的数组类型注解方法可有默认值，比如default \"hello\"，默认website=”hello” 当然注解中也可以不存在成员变量，在使用解析注解进行操作时，仅以是否包含该注解来进行操作。当注解中有成员变量时，若没有默认值，需要在使用注解时，指定成员变量的值。 public class AnnotationDemo { @MyAnnotataion(name=\"lvr\", website=\"hello\", revision=1) public static void main(String[] args) { System.out.println(\"I am main method\"); } @SuppressWarnings({ \"unchecked\", \"deprecation\" }) @MyAnnotataion(name=\"lvr\", website=\"hello\", revision=2) public void demo(){ System.out.println(\"I am demo method\"); } } 由于该注解的保留策略为RetentionPolicy.RUNTIME，故可在运行期通过反射机制来使用，否则无法通过反射机制来获取。这时候注解实现的就是元数据的第二个作用：代码分析。下面来具体介绍如何通过反射机制来进行注解解析。 四、注解解析 接下来，通过反射技术来解析自定义注解。关于反射类位于包java.lang.reflect，其中有一个接口AnnotatedElement，该接口主要有如下几个实现类：Class，Constructor，Field，Method，Package。除此之外，该接口定义了注释相关的几个核心方法，如下：因此，当获取了某个类的Class对象，然后获取其Field,Method等对象，通过上述4个方法提取其中的注解，然后获得注解的详细信息。 public class AnnotationParser { public static void main(String[] args) throws SecurityException, ClassNotFoundException { String clazz = \"com.lvr.annotation.AnnotationDemo\"; Method[] demoMethod = AnnotationParser.class .getClassLoader().loadClass(clazz).getMethods(); for (Method method : demoMethod) { if (method.isAnnotationPresent(MyAnnotataion.class)) { MyAnnotataion annotationInfo = method.getAnnotation(MyAnnotataion.class); System.out.println(\"method: \"+ method); System.out.println(\"name= \"+ annotationInfo.name() + \" , website= \"+ annotationInfo.website() + \" , revision= \"+annotationInfo.revision()); } } } } 以上仅是一个示例，其实可以根据拿到的注解信息做更多有意义的事。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/java-io1.html":{"url":"java/basis/java-io1.html","title":"Java IO(一)","keywords":"","body":"一、字符与字节 在Java中有输入、输出两种IO流，每种输入、输出流又分为字节流和字符流两大类。关于字节，我们在学习8大基本数据类型中都有了解，每个字节(byte)有8bit组成，每种数据类型又几个字节组成等。关于字符，我们可能知道代表一个汉字或者英文字母。 但是字节与字符之间的关系是怎样的？ Java采用unicode编码，2个字节来表示一个字符，这点与C语言中不同，C语言中采用ASCII，在大多数系统中，一个字符通常占1个字节，但是在0~127整数之间的字符映射，unicode向下兼容ASCII。而Java采用unicode来表示字符，一个中文或英文字符的unicode编码都占2个字节。但如果采用其他编码方式，一个字符占用的字节数则各不相同。可能有点晕，举个例子解释下。 例如：Java中的String类是按照unicode进行编码的，当使用String(byte[] bytes, String encoding)构造字符串时，encoding所指的是bytes中的数据是按照那种方式编码的，而不是最后产生的String是什么编码方式，换句话说，是让系统把bytes中的数据由encoding编码方式转换成unicode编码。如果不指明，bytes的编码方式将由jdk根据操作系统决定。 getBytes(String charsetName)使用指定的编码方式将此String编码为 byte 序列，并将结果存储到一个新的 byte 数组中。如果不指定将使用操作系统默认的编码方式，我的电脑默认的是GBK编码。 public class Hel { public static void main(String[] args){ String str = \"你好hello\"; int byte_len = str.getBytes().length; int len = str.length(); System.out.println(\"字节长度为：\" + byte_len); System.out.println(\"字符长度为：\" + len); System.out.println(\"系统默认编码方式：\" + System.getProperty(\"file.encoding\")); } } 输出结果 字节长度为：9字符长度为：7系统默认编码方式：GBK 这是因为：在 GB 2312 编码或 GBK 编码中，一个英文字母字符存储需要1个字节，一个汉字字符存储需要2个字节。 在UTF-8编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。在UTF-16编码中，一个英文字母字符存储需要2个字节，一个汉字字符储存需要3到4个字节（Unicode扩展区的一些汉字存储需要4个字节）。在UTF-32编码中，世界上任何字符的存储都需要4个字节。 简单来讲，一个字符表示一个汉字或英文字母，具体字符与字节之间的大小比例视编码情况而定。有时候读取的数据是乱码，就是因为编码方式不一致，需要进行转换，然后再按照unicode进行编码。 二、File类 File类是java.io包下代表与平台无关的文件和目录，也就是说，如果希望在程序中操作文件和目录，都可以通过File类来完成。 ①构造函数 //构造函数File(String pathname) File f1 =new File(\"c:\\\\abc\\\\1.txt\"); //File(String parent,String child) File f2 =new File(\"c:\\\\abc\",\"2.txt\"); //File(File parent,String child) File f3 =new File(\"c:\"+File.separator+\"abc\");//separator 跨平台分隔符 File f4 =new File(f3,\"3.txt\"); System.out.println(f1);//c:\\abc\\1.txt 路径分隔符：windows： \"/\" \"\\\" 都可以linux/unix： \"/\"注意:如果windows选择用\"\\\"做分割符的话,那么请记得替换成\"\\\",因为Java中\"\\\"代表转义字符所以推荐都使用\"/\"，也可以直接使用代码File.separator，表示跨平台分隔符。路径：相对路径：./表示当前路径../表示上一级路径其中当前路径：默认情况下，java.io 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性 user.dir 指定，通常是 Java 虚拟机的调用目录。” 绝对路径：绝对路径名是完整的路径名，不需要任何其他信息就可以定位自身表示的文件 ②创建与删除方法 //如果文件存在返回false，否则返回true并且创建文件 boolean createNewFile(); //创建一个File对象所对应的目录，成功返回true，否则false。且File对象必须为路径而不是文件。只会创建最后一级目录，如果上级目录不存在就抛异常。 boolean mkdir(); //创建一个File对象所对应的目录，成功返回true，否则false。且File对象必须为路径而不是文件。创建多级目录，创建路径中所有不存在的目录 boolean mkdirs() ; //如果文件存在返回true并且删除文件，否则返回false boolean delete(); //在虚拟机终止时，删除File对象所表示的文件或目录。 void deleteOnExit(); ③判断方法 boolean canExecute() ;//判断文件是否可执行 boolean canRead();//判断文件是否可读 boolean canWrite();//判断文件是否可写 boolean exists();//判断文件是否存在 boolean isDirectory();//判断是否是目录 boolean isFile();//判断是否是文件 boolean isHidden();//判断是否是隐藏文件或隐藏目录 boolean isAbsolute();//判断是否是绝对路径 文件不存在也能判断 ③获取方法 String getName();//返回文件或者是目录的名称 String getPath();//返回路径 String getAbsolutePath();//返回绝对路径 String getParent();//返回父目录，如果没有父目录则返回null long lastModified();//返回最后一次修改的时间 long length();//返回文件的长度 File[] listRoots();// 列出所有的根目录（Window中就是所有系统的盘符） String[] list() ;//返回一个字符串数组，给定路径下的文件或目录名称字符串 String[] list(FilenameFilter filter);//返回满足过滤器要求的一个字符串数组 File[] listFiles();//返回一个文件对象数组，给定路径下文件或目录 File[] listFiles(FilenameFilter filter);//返回满足过滤器要求的一个文件对象数组 其中包含了一个重要的接口FileNameFilter，该接口是个文件过滤器，包含了一个accept(File dir,String name)方法，该方法依次对指定File的所有子目录或者文件进行迭代，按照指定条件，进行过滤，过滤出满足条件的所有文件。 // 文件过滤 File[] files = file.listFiles(new FilenameFilter() { @Override public boolean accept(File file, String filename) { return filename.endsWith(\".mp3\"); } }); file目录下的所有子文件如果满足后缀是.mp3的条件的文件都会被过滤出来。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/java-io2.html":{"url":"java/basis/java-io2.html","title":"Java IO(二)","keywords":"","body":"一、IO流的概念 Java的IO流是实现输入/输出的基础，它可以方便地实现数据的输入/输出操作，在Java中把不同的输入/输出源抽象表述为\"流\"。流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。流有输入和输出，输入时是流从数据源流向程序。输出时是流从程序传向数据源，而数据源可以是内存，文件，网络或程序等。 二、IO流的分类 1.输入流和输出流 根据数据流向不同分为：输入流和输出流。 输入流:只能从中读取数据，而不能向其写入数据。输出流：只能向其写入数据，而不能从中读取数据。 如下如所示：对程序而言，向右的箭头，表示输入，向左的箭头，表示输出。 2.字节流和字符流 字节流和字符流和用法几乎完全一样，区别在于字节流和字符流所操作的数据单元不同。字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。字节流和字符流的区别：（1）读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。（2）处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。 只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。 3.节点流和处理流 按照流的角色来分，可以分为节点流和处理流。可以从/向一个特定的IO设备（如磁盘、网络）读/写数据的流，称为节点流，节点流也被成为低级流。处理流是对一个已存在的流进行连接或封装，通过封装后的流来实现数据读/写功能，处理流也被称为高级流。 //节点流，直接传入的参数是IO设备 FileInputStream fis = new FileInputStream(\"test.txt\"); //处理流，直接传入的参数是流对象 BufferedInputStream bis = new BufferedInputStream(fis); 当使用处理流进行输入/输出时，程序并不会直接连接到实际的数据源，没有和实际的输入/输出节点连接。使用处理流的一个明显好处是，只要使用相同的处理流，程序就可以采用完全相同的输入/输出代码来访问不同的数据源，随着处理流所包装节点流的变化，程序实际所访问的数据源也相应地发生变化。实际上，Java使用处理流来包装节点流是一种典型的装饰器设计模式，通过使用处理流来包装不同的节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入/输出功能。 三、IO流的四大基类 根据流的流向以及操作的数据单元不同，将流分为了四种类型，每种类型对应一种抽象基类。这四种抽象基类分别为：InputStream,Reader,OutputStream以及Writer。四种基类下，对应不同的实现类，具有不同的特性。在这些实现类中，又可以分为节点流和处理流。下面就是整个由着四大基类支撑下，整个IO流的框架图。InputStream,Reader,OutputStream以及Writer，这四大抽象基类，本身并不能创建实例来执行输入/输出，但它们将成为所有输入/输出流的模版，所以它们的方法是所有输入/输出流都可以使用的方法。类似于集合中的Collection接口。 1.InputStream InputStream 是所有的输入字节流的父类，它是一个抽象类，主要包含三个方法： //读取一个字节并以整数的形式返回(0~255),如果返回-1已到输入流的末尾。 int read() ； //读取一系列字节并存储到一个数组buffer，返回实际读取的字节数，如果读取前已到输入流的末尾返回-1。 int read(byte[] buffer) ； //读取length个字节并存储到一个字节数组buffer，从off位置开始存,最多len， 返回实际读取的字节数，如果读取前以到输入流的末尾返回-1。 int read(byte[] buffer, int off, int len) ； 2.Reader Reader 是所有的输入字符流的父类，它是一个抽象类，主要包含三个方法： //读取一个字符并以整数的形式返回(0~255),如果返回-1已到输入流的末尾。 int read() ； //读取一系列字符并存储到一个数组buffer，返回实际读取的字符数，如果读取前已到输入流的末尾返回-1。 int read(char[] cbuf) ； //读取length个字符,并存储到一个数组buffer，从off位置开始存,最多读取len，返回实际读取的字符数，如果读取前以到输入流的末尾返回-1。 int read(char[] cbuf, int off, int len) 对比InputStream和Reader所提供的方法，就不难发现两个基类的功能基本一样的，只不过读取的数据单元不同。 在执行完流操作后，要调用close()方法来关系输入流，因为程序里打开的IO资源不属于内存资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。 除此之外，InputStream和Reader还支持如下方法来移动流中的指针位置： //在此输入流中标记当前的位置 //readlimit - 在标记位置失效前可以读取字节的最大限制。 void mark(int readlimit) // 测试此输入流是否支持 mark 方法 boolean markSupported() // 跳过和丢弃此输入流中数据的 n 个字节/字符 long skip(long n) //将此流重新定位到最后一次对此输入流调用 mark 方法时的位置 void reset() 3.OutputStream OutputStream 是所有的输出字节流的父类，它是一个抽象类，主要包含如下四个方法： //向输出流中写入一个字节数据,该字节数据为参数b的低8位。 void write(int b) ; //将一个字节类型的数组中的数据写入输出流。 void write(byte[] b); //将一个字节类型的数组中的从指定位置（off）开始的,len个字节写入到输出流。 void write(byte[] b, int off, int len); //将输出流中缓冲的数据全部写出到目的地。 void flush(); 4.Writer Writer 是所有的输出字符流的父类，它是一个抽象类,主要包含如下六个方法： //向输出流中写入一个字符数据,该字节数据为参数b的低16位。 void write(int c); //将一个字符类型的数组中的数据写入输出流， void write(char[] cbuf) //将一个字符类型的数组中的从指定位置（offset）开始的,length个字符写入到输出流。 void write(char[] cbuf, int offset, int length); //将一个字符串中的字符写入到输出流。 void write(String string); //将一个字符串从offset开始的length个字符写入到输出流。 void write(String string, int offset, int length); //将输出流中缓冲的数据全部写出到目的地。 void flush() 可以看出，Writer比OutputStream多出两个方法，主要是支持写入字符和字符串类型的数据。 使用Java的IO流执行输出时，不要忘记关闭输出流，关闭输出流除了可以保证流的物理资源被回收之外，还能将输出流缓冲区的数据flush到物理节点里（因为在执行close()方法之前，自动执行输出流的flush()方法） 以上内容就是整个IO流的框架介绍。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/randomaccessfile.html":{"url":"java/basis/randomaccessfile.html","title":"RandomAccessFile","keywords":"","body":"一、RandomAccessFile简介 RandomAccessFile既可以读取文件内容，也可以向文件输出数据。同时，RandomAccessFile支持“随机访问”的方式，程序快可以直接跳转到文件的任意地方来读写数据。 由于RandomAccessFile可以自由访问文件的任意位置，所以如果需要访问文件的部分内容，而不是把文件从头读到尾，使用RandomAccessFile将是更好的选择。 与OutputStream、Writer等输出流不同的是，RandomAccessFile允许自由定义文件记录指针，RandomAccessFile可以不从开始的地方开始输出，因此RandomAccessFile可以向已存在的文件后追加内容。如果程序需要向已存在的文件后追加内容，则应该使用RandomAccessFile。 RandomAccessFile的方法虽然多，但它有一个最大的局限，就是只能读写文件，不能读写其他IO节点。 RandomAccessFile的一个重要使用场景就是网络请求中的多线程下载及断点续传。 二、RandomAccessFile中的方法 1.RandomAccessFile的构造函数 RandomAccessFile类有两个构造函数，其实这两个构造函数基本相同，只不过是指定文件的形式不同——一个需要使用String参数来指定文件名，一个使用File参数来指定文件本身。除此之外，创建RandomAccessFile对象时还需要指定一个mode参数，该参数指定RandomAccessFile的访问模式，一共有4种模式。 \"r\": 以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。\"rw\": 打开以便读取和写入。\"rws\": 打开以便读取和写入。相对于 \"rw\"，\"rws\" 还要求对“文件的内容”或“元数据”的每个更新都同步写入到基础存储设备。\"rwd\" : 打开以便读取和写入，相对于 \"rw\"，\"rwd\" 还要求对“文件的内容”的每个更新都同步写入到基础存储设备。 2.RandomAccessFile的重要方法 RandomAccessFile既可以读文件，也可以写文件，所以类似于InputStream的read()方法，以及类似于OutputStream的write()方法，RandomAccessFile都具备。除此之外，RandomAccessFile具备两个特有的方法，来支持其随机访问的特性。 RandomAccessFile对象包含了一个记录指针，用以标识当前读写处的位置，当程序新创建一个RandomAccessFile对象时，该对象的文件指针记录位于文件头（也就是0处），当读/写了n个字节后，文件记录指针将会后移n个字节。除此之外，RandomAccessFile还可以自由移动该记录指针。下面就是RandomAccessFile具有的两个特殊方法，来操作记录指针，实现随机访问： long getFilePointer( )：返回文件记录指针的当前位置void seek(long pos )：将文件指针定位到pos位置 三、RandomAccessFile的使用 利用RandomAccessFile实现文件的多线程下载，即多线程下载一个文件时，将文件分成几块，每块用不同的线程进行下载。下面是一个利用多线程在写文件时的例子，其中预先分配文件所需要的空间，然后在所分配的空间中进行分块，然后写入： /** * 测试利用多线程进行文件的写操作 */ public class Test { public static void main(String[] args) throws Exception { // 预分配文件所占的磁盘空间，磁盘中会创建一个指定大小的文件 RandomAccessFile raf = new RandomAccessFile(\"D://abc.txt\", \"rw\"); raf.setLength(1024*1024); // 预分配 1M 的文件空间 raf.close(); // 所要写入的文件内容 String s1 = \"第一个字符串\"; String s2 = \"第二个字符串\"; String s3 = \"第三个字符串\"; String s4 = \"第四个字符串\"; String s5 = \"第五个字符串\"; // 利用多线程同时写入一个文件 new FileWriteThread(1024*1,s1.getBytes()).start(); // 从文件的1024字节之后开始写入数据 new FileWriteThread(1024*2,s2.getBytes()).start(); // 从文件的2048字节之后开始写入数据 new FileWriteThread(1024*3,s3.getBytes()).start(); // 从文件的3072字节之后开始写入数据 new FileWriteThread(1024*4,s4.getBytes()).start(); // 从文件的4096字节之后开始写入数据 new FileWriteThread(1024*5,s5.getBytes()).start(); // 从文件的5120字节之后开始写入数据 } // 利用线程在文件的指定位置写入指定数据 static class FileWriteThread extends Thread{ private int skip; private byte[] content; public FileWriteThread(int skip,byte[] content){ this.skip = skip; this.content = content; } public void run(){ RandomAccessFile raf = null; try { raf = new RandomAccessFile(\"D://abc.txt\", \"rw\"); raf.seek(skip); raf.write(content); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { try { raf.close(); } catch (Exception e) { } } } } } 当RandomAccessFile向指定文件中插入内容时，将会覆盖掉原有内容。如果不想覆盖掉，则需要将原有内容先读取出来，然后先把插入内容插入后再把原有内容追加到插入内容后。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/java-nio.html":{"url":"java/basis/java-nio.html","title":"Java NIO","keywords":"","body":"一、NIO的概念 Java NIO(New IO)是一个可以替代标准Java IO API的IO API(从Java1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。 所以Java NIO是一种新式的IO标准，与之间的普通IO的工作方式不同。标准的IO基于字节流和字符流进行操作的，而NIO是基于通道(Channel)和缓冲区(Buffer)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道也类似。 由上面的定义就说明NIO是一种新型的IO，但NIO不仅仅就是等于Non-blocking IO（非阻塞IO），NIO中有实现非阻塞IO的具体类，但不代表NIO就是Non-blocking IO（非阻塞IO）。 Java NIO 由以下几个核心部分组成： Buffer Channel Selector 传统的IO操作面向数据流，意味着每次从流中读一个或多个字节，直至完成，数据没有被缓存在任何地方。NIO操作面向缓冲区，数据从Channel读取到Buffer缓冲区，随后在Buffer中处理数据。 二、Buffer的使用 利用Buffer读写数据，通常遵循四个步骤： 把数据写入buffer； 调用flip； 从Buffer中读取数据； 调用buffer.clear() 当写入数据到buffer中时，buffer会记录已经写入的数据大小。当需要读数据时，通过flip()方法把buffer从写模式调整为读模式；在读模式下，可以读取所有已经写入的数据。 当读取完数据后，需要清空buffer，以满足后续写入操作。清空buffer有两种方式：调用clear()，一旦读完Buffer中的数据，需要让Buffer准备好再次被写入，clear会恢复状态值，但不会擦除数据。 Buffer的容量，位置，上限（Buffer Capacity, Position and Limit） buffer缓冲区实质上就是一块内存，用于写入数据，也供后续再次读取数据。这块内存被NIO Buffer管理，并提供一系列的方法用于更简单的操作这块内存。 一个Buffer有三个属性是必须掌握的，分别是： capacity容量 position位置 limit限制 position和limit的具体含义取决于当前buffer的模式。capacity在两种模式下都表示容量。下面有张示例图，描诉了不同模式下position和limit的含义： 容量（Capacity） 作为一块内存，buffer有一个固定的大小，叫做capacity容量。也就是最多只能写入容量值得字节，整形等数据。一旦buffer写满了就需要清空已读数据以便下次继续写入新的数据。 位置（Position） 当写入数据到Buffer的时候需要中一个确定的位置开始，默认初始化时这个位置position为0，一旦写入了数据比如一个字节，整形数据，那么position的值就会指向数据之后的一个单元，position最大可以到capacity-1。当从Buffer读取数据时，也需要从一个确定的位置开始。buffer从写入模式变为读取模式时，position会归零，每次读取后，position向后移动。 上限（Limit）在写模式，limit的含义是我们所能写入的最大数据量。它等同于buffer的容量。一旦切换到读模式，limit则代表我们所能读取的最大数据量，他的值等同于写模式下position的位置。数据读取的上限时buffer中已有的数据，也就是limit的位置（原position所指的位置）。 分配一个Buffer（Allocating a Buffer） 为了获取一个Buffer对象，你必须先分配。每个Buffer实现类都有一个allocate()方法用于分配内存。下面看一个实例,开辟一个48字节大小的buffer： ByteBuffer buf = ByteBuffer.allocate(48); 开辟一个1024个字符的CharBuffer： CharBuffer buf = CharBuffer.allocate(1024); Buffer的实现类 其中MappedByteBuffer比较特殊。Java类库中的NIO包相对于IO 包来说有一个新功能是内存映射文件，日常编程中并不是经常用到，但是在处理大文件时是比较理想的提高效率的手段。其中MappedByteBuffer实现的就是内存映射文件，可以实现大文件的高效读写。 可以参考这两篇文章理解： [Java][IO]JAVA NIO之浅谈内存映射文件原理与DirectMemory，深入浅出MappedByteBuffer。 三、Channel的使用 Java NIO Channel通道和流非常相似，主要有以下几点区别： 通道可以读也可以写，流一般来说是单向的（只能读或者写）。 通道可以异步读写。 通道总是基于缓冲区Buffer来读写。 正如上面提到的，我们可以从通道中读取数据，写入到buffer；也可以中buffer内读数据，写入到通道中。下面有个示意图： Channel的实现类有： FileChannel DatagramChannel SocketChannel ServerSocketChannel 还有一些异步IO类，后面有介绍。 FileChannel用于文件的数据读写。 DatagramChannel用于UDP的数据读写。 SocketChannel用于TCP的数据读写。 ServerSocketChannel允许我们监听TCP链接请求，每个请求会创建会一个SocketChannel。 Channel使用实例 RandomAccessFile aFile = new RandomAccessFile(\"data/nio-data.txt\", \"rw\"); FileChannel inChannel = aFile.getChannel(); ByteBuffer buf = ByteBuffer.allocate(48); int bytesRead = inChannel.read(buf); while (bytesRead != -1) { System.out.println(\"Read \" + bytesRead); buf.flip(); while(buf.hasRemaining()){ System.out.print((char) buf.get()); } buf.clear(); bytesRead = inChannel.read(buf); } aFile.close(); 上面介绍了NIO中的两个关键部分Buffer/Channel，对于Selector的介绍，先放一放，先介绍阻塞/非阻塞/同步/非同步的关系。 四、阻塞/非阻塞/同步/非同步的关系 为什么要介绍这四者的关系，就是因为Selector是对于多个非阻塞IO流的调度器，通过Selector来实现读写操作。所以有必要理解一下什么是阻塞/非阻塞？ 本文讨论的背景是UNIX环境下的network IO。本文最重要的参考文献是Richard Stevens的“UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking ”，6.2节“I/O Models ”，Stevens在这节中详细说明了各种IO的特点和区别。 Stevens在文章中一共比较了五种IO Model： blocking IO nonblocking IO IO multiplexing signal driven IO asynchronous IO。 由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。再说一下IO发生时涉及的对象和步骤。对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。 当一个read操作发生时，它会经历两个阶段：1 等待数据准备 (Waiting for the data to be ready)2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process) 记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。 blocking IO 在UNIX中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样： 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。所以，blocking IO的特点就是在IO执行的两个阶段都被block了。 non-blocking IO UNIX下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。所以，用户进程其实是需要不断的主动询问kernel数据好了没有。 IO multiplexing IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图： 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。） 在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。 Asynchronous I/O UNIX下的asynchronous IO其实用得很少。先看一下它的流程：用户进程发起read操作之后，立刻就可以开始去做其它的事。 而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 到目前为止，已经将四个IO Model都介绍完了。现在回过头来回答最初的那几个问题： blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪？ 先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。 在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：A synchronous I/O operation causes the requesting process to be blocked until that I/O operationcompletes; An asynchronous I/O operation does not cause the requesting process to be blocked; 两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。 按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。 有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。 各个IO Model的比较如图所示： 经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。 五、NIO中的blocking IO/nonblocking IO/IO multiplexing/asynchronous IO 上面讲完了IO中的几种模式，虽然是基于UNIX环境下，具体操作系统的知识个人认识很浅，下面就说下自己的个人理解，不对的地方欢迎指正。 首先，标准的IO显然属于blocking IO。 其次，NIO中的实现了SelectableChannel类的对象，可以通过如下方法设置是否支持非阻塞模式： SelectableChannel configureBlocking(boolean block)：调整此通道的阻塞模式。 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式设置为false的NIO类将是nonblocking IO。 再其次，通过Selector监听实现多个NIO对象的读写操作，显然属于IO multiplexing。关于Selector，其负责调度多个非阻塞式IO，当有其感兴趣的读写操作到来时，再执行相应的操作。Selector执行select()方法来进行轮询查找是否到来了读写操作，这个过程是阻塞的，具体详细使用下面介绍。 最后，在Java 7中增加了asynchronous IO，具体结构和实现类框架如下： 篇幅有限，具体使用可以看这篇文章：Java 学习之路 之 基于TCP协议的网络编程（八十二）。 六、Selector使用 Selector是Java NIO中的一个组件，用于检查一个或多个NIO Channel的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。 通过上面的了解我们知道Selector是一种IO multiplexing的情况。 下面这幅图描述了单线程处理三个channel的情况： 创建Selector(Creating a Selector)。创建一个Selector可以通过Selector.open()方法： Selector selector = Selector.open(); 注册Channel到Selector上： channel.configureBlocking(false); SelectionKey key = channel.register(selector, SelectionKey.OP_READ); Channel必须是非阻塞的。上面对IO multiplexing的图解中可以看出。所以FileChannel不适用Selector，因为FileChannel不能切换为非阻塞模式。Socket channel可以正常使用。 注意register的第二个参数，这个参数是一个“关注集合”，代表我们关注的channel状态，有四种基础类型可供监听： Connect Accept Read Write 一个channel触发了一个事件也可视作该事件处于就绪状态。 因此当channel与server连接成功后，那么就是“Connetct”状态。server channel接收请求连接时处于“Accept”状态。channel有数据可读时处于“Read”状态。channel可以进行数据写入时处于“Writer”状态。当注册到Selector的所有Channel注册完后，调用Selector的select()方法，将会不断轮询检查是否有以上设置的状态产生，如果产生便会加入到SelectionKey集合中，进行后续操作。 上述的四种就绪状态用SelectionKey中的常量表示如下： SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 如果对多个事件感兴趣可利用位的或运算结合多个常量，比如： int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; 从Selector中选择channel(Selecting Channels via a Selector) 一旦我们向Selector注册了一个或多个channel后，就可以调用select来获取channel。select方法会返回所有处于就绪状态的channel。 select方法具体如下： int select()int select(long timeout)int selectNow() select()方法在返回channel之前处于阻塞状态。 select(long timeout)和select做的事一样，不过他的阻塞有一个超时限制。 selectNow()不会阻塞，根据当前状态立刻返回合适的channel。 select()方法的返回值是一个int整形，代表有多少channel处于就绪了。也就是自上一次select后有多少channel进入就绪。 举例来说，假设第一次调用select时正好有一个channel就绪，那么返回值是1，并且对这个channel做任何处理，接着再次调用select，此时恰好又有一个新的channel就绪，那么返回值还是1，现在我们一共有两个channel处于就绪，但是在每次调用select时只有一个channel是就绪的。 selectedKeys() 在调用select并返回了有channel就绪之后，可以通过选中的key集合来获取channel，这个操作通过调用selectedKeys()方法： Set selectedKeys = selector.selectedKeys(); 遍历这些SelectionKey可以通过如下方法： Set selectedKeys = selector.selectedKeys(); Iterator keyIterator = selectedKeys.iterator(); while(keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if(key.isAcceptable()) { // a connection was accepted by a ServerSocketChannel. } else if (key.isConnectable()) { // a connection was established with a remote server. } else if (key.isReadable()) { // a channel is ready for reading } else if (key.isWritable()) { // a channel is ready for writing } keyIterator.remove(); } 上述循环会迭代key集合，针对每个key我们单独判断他是处于何种就绪状态。 注意keyIterater.remove()方法的调用，Selector本身并不会移除SelectionKey对象，这个操作需要我们手动执行。当下次channel处于就绪是，Selector任然会把这些key再次加入进来。 SelectionKey.channel返回的channel实例需要强转为我们实际使用的具体的channel类型，例如ServerSocketChannel或SocketChannel. wakeUp() 由于调用select而被阻塞的线程，可以通过调用Selector.wakeup()来唤醒即便此时已然没有channel处于就绪状态。具体操作是，在另外一个线程调用wakeup，被阻塞与select方法的线程就会立刻返回。 close() 当操作Selector完毕后，需要调用close方法。close的调用会关闭Selector并使相关的SelectionKey都无效。channel本身不管被关闭。 完整的Selector案例 这有一个完整的案例，首先打开一个Selector,然后注册channel，最后调用select()获取感兴趣的操作： Selector selector = Selector.open(); channel.configureBlocking(false); SelectionKey key = channel.register(selector, SelectionKey.OP_READ); while(true) { int readyChannels = selector.select(); if(readyChannels == 0) continue; Set selectedKeys = selector.selectedKeys(); Iterator keyIterator = selectedKeys.iterator(); while(keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if(key.isAcceptable()) { // a connection was accepted by a ServerSocketChannel. } else if (key.isConnectable()) { // a connection was established with a remote server. } else if (key.isReadable()) { // a channel is ready for reading } else if (key.isWritable()) { // a channel is ready for writing } keyIterator.remove(); } } Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/throwable.html":{"url":"java/basis/throwable.html","title":"Java异常详解","keywords":"","body":"Java异常简介 Java异常是Java提供的一种识别及响应错误的一致性机制。 Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪“抛出，异常信息回答了“为什么“会抛出。 Java异常机制用到的几个关键字：try、catch、finally、throw、throws。 • try -- 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。 • catch -- 用于捕获异常。catch用来捕获try语句块中发生的异常。 • finally -- finally语句块总是会被执行。它主要用于回收在try块里打开的物理资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。 • throw -- 用于抛出异常。 • throws -- 用在方法签名中，用于声明该方法可能抛出的异常。 下面通过几个示例对这几个关键字进行简单了解。 示例一: 了解try和catch基本用法 public class Demo1 { public static void main(String[] args) { try { int i = 10/0; System.out.println(\"i=\"+i); } catch (ArithmeticException e) { System.out.println(\"Caught Exception\"); System.out.println(\"e.getMessage(): \" + e.getMessage()); System.out.println(\"e.toString(): \" + e.toString()); System.out.println(\"e.printStackTrace():\"); e.printStackTrace(); } } } 运行结果： Caught Exception e.getMessage(): / by zero e.toString(): java.lang.ArithmeticException: / by zero e.printStackTrace(): java.lang.ArithmeticException: / by zero at Demo1.main(Demo1.java:6) 结果说明：在try语句块中有除数为0的操作，该操作会抛出java.lang.ArithmeticException异常。通过catch，对该异常进行捕获。 观察结果我们发现，并没有执行System.out.println(\"i=\"+i)。这说明try语句块发生异常之后，try语句块中的剩余内容就不会再被执行了。 示例二: 了解finally的基本用法 在\"示例一\"的基础上，我们添加finally语句。 public class Demo2 { public static void main(String[] args) { try { int i = 10/0; System.out.println(\"i=\"+i); } catch (ArithmeticException e) { System.out.println(\"Caught Exception\"); System.out.println(\"e.getMessage(): \" + e.getMessage()); System.out.println(\"e.toString(): \" + e.toString()); System.out.println(\"e.printStackTrace():\"); e.printStackTrace(); } finally { System.out.println(\"run finally\"); } } } 运行结果： Caught Exception e.getMessage(): / by zero e.toString(): java.lang.ArithmeticException: / by zero e.printStackTrace(): java.lang.ArithmeticException: / by zero at Demo2.main(Demo2.java:6) run finally 结果说明：最终执行了finally语句块。 示例三: 了解throws和throw的基本用法 throws是用于声明抛出的异常，而throw是用于抛出异常。 class MyException extends Exception { public MyException() {} public MyException(String msg) { super(msg); } } public class Demo3 { public static void main(String[] args) { try { test(); } catch (MyException e) { System.out.println(\"Catch My Exception\"); e.printStackTrace(); } } public static void test() throws MyException{ try { int i = 10/0; System.out.println(\"i=\"+i); } catch (ArithmeticException e) { throw new MyException(\"This is MyException\"); } } } 运行结果： Catch My Exception MyException: This is MyException at Demo3.test(Demo3.java:24) at Demo3.main(Demo3.java:13) 结果说明： MyException是继承于Exception的子类。test()的try语句块中产生ArithmeticException异常(除数为0)，并在catch中捕获该异常；接着抛出MyException异常。main()方法对test()中抛出的MyException进行捕获处理。 Java异常框架 1. Throwable Throwable是 Java 语言中所有错误或异常的超类。 Throwable包含两个子类: Error 和 Exception。它们通常用于指示发生了异常情况。 Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。 2. Exception Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。 3. RuntimeException RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 编译器不会检查RuntimeException异常。例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既\"没有通过throws声明抛出ArithmeticException异常\"，也\"没有通过try...catch...处理该异常\"，也能通过编译。这就是我们所说的\"编译器不会检查RuntimeException异常\"！ 如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！ 4. Error 和Exception一样，Error也是Throwable的子类。它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。 和RuntimeException一样，编译器也不会检查Error。 Java将可抛出(Throwable)的结构分为三种类型：被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。 (01) 运行时异常 定义: RuntimeException及其子类都被称为运行时异常。 特点: Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既\"没有通过throws声明抛出它\"，也\"没有用try-catch语句捕获它\"，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fast机制产生的ConcurrentModificationException异常等，都属于运行时异常。 虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。 如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！ (02) 被检查的异常 定义: Exception类本身，以及Exception的子类中除了\"运行时异常\"之外的其它子类都属于被检查异常。 特点: Java编译器会检查它。此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。 被检查异常通常都是可以恢复的。 (03) 错误 定义: Error类及其子类。 特点: 和运行时异常一样，编译器也不会对错误进行检查。 当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。 按照Java惯例，我们是不应该实现任何新的Error子类的！ Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/abstract_interface.html":{"url":"java/basis/abstract_interface.html","title":"Java抽象类和接口的区别","keywords":"","body":"理解抽象 abstract class和interface是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。 abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于 abstract class和interface的选择显得比较随意。 其实，两者之间还是有很大的区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。本文将对它们之间的区别进行一番剖析，试图给开发者提供一个在二者之间进行选择的依据。 语法定义理解 抽象类 abstract class Demo ｛ abstract void method1(); abstract void method2(); … ｝ 接口 interface Demo { void method1(); void method2(); … } 在abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface方式的实现中，Demo只能够有静态的不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊形式的abstract class。 编程角度理解 首先，abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多重继承的支持方面的一种折中考虑吧。 其次，在abstract class的定义中，我们可以赋予方法的默认行为。 但是在interface的定义中，方法却不能拥有默认行为，不过在JDK1.8中可以使用default关键字实现默认方法。 interface InterfaceA { default void foo() { System.out.println(\"InterfaceA foo\"); } } 在 Java 8 之前，接口与其实现类之间的 耦合度 太高了（tightly coupled），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在 lambda 表达式作为Java 8 语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。 一般性理解 接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。从设计理念上，接口反映的是 “like-a” 关系，抽象类反映的是 “is-a” 关系。 抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。 人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它. 所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。 总结 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 抽象类要被子类继承，接口要被类实现。 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 抽象类里可以没有抽象方法。 接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。 接口中没有 this 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法。 抽象类不能在Java 8 的 lambda 表达式中使用。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/copy.html":{"url":"java/basis/copy.html","title":"Java深拷贝和浅拷贝","keywords":"","body":"一、引言 对象拷贝(Object Copy)就是将一个对象的属性拷贝到另一个有着相同类类型的对象中去。在程序中拷贝对象是很常见的，主要是为了在新的上下文环境中复用对象的部分或全部数据。Java中有三种类型的对象拷贝：浅拷贝(Shallow Copy)、深拷贝(Deep Copy)、延迟拷贝(Lazy Copy)。 二、浅拷贝 1、什么是浅拷贝 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。 ​ 在上图中，SourceObject有一个int类型的属性 \"field1\"和一个引用类型属性\"refObj\"（引用ContainedObject类型的对象）。当对SourceObject做浅拷贝时，创建了CopiedObject，它有一个包含\"field1\"拷贝值的属性\"field2\"以及仍指向refObj本身的引用。由于\"field1\"是基本类型，所以只是将它的值拷贝给\"field2\"，但是由于\"refObj\"是一个引用类型, 所以CopiedObject指向\"refObj\"相同的地址。因此对SourceObject中的\"refObj\"所做的任何改变都会影响到CopiedObject。 2、如何实现浅拷贝 下面是实现浅拷贝的一个例子 public class Subject { private String name; public Subject(String s) { name = s; } public String getName() { return name; } public void setName(String s) { name = s; } } public class Student implements Cloneable { // 对象引用 private Subject subj; private String name; public Student(String s, String sub) { name = s; subj = new Subject(sub); } public Subject getSubj() { return subj; } public String getName() { return name; } public void setName(String s) { name = s; } /** * 重写clone()方法 * @return */ public Object clone() { //浅拷贝 try { // 直接调用父类的clone()方法 return super.clone(); } catch (CloneNotSupportedException e) { return null; } } } public class CopyTest { public static void main(String[] args) { // 原始对象 Student stud = new Student(\"John\", \"Algebra\"); System.out.println(\"Original Object: \" + stud.getName() + \" - \" + stud.getSubj().getName()); // 拷贝对象 Student clonedStud = (Student) stud.clone(); System.out.println(\"Cloned Object: \" + clonedStud.getName() + \" - \" + clonedStud.getSubj().getName()); // 原始对象和拷贝对象是否一样： System.out.println(\"Is Original Object the same with Cloned Object: \" + (stud == clonedStud)); // 原始对象和拷贝对象的name属性是否一样 System.out.println(\"Is Original Object's field name the same with Cloned Object: \" + (stud.getName() == clonedStud.getName())); // 原始对象和拷贝对象的subj属性是否一样 System.out.println(\"Is Original Object's field subj the same with Cloned Object: \" + (stud.getSubj() == clonedStud.getSubj())); stud.setName(\"Dan\"); stud.getSubj().setName(\"Physics\"); System.out.println(\"Original Object after it is updated: \" + stud.getName() + \" - \" + stud.getSubj().getName()); System.out.println(\"Cloned Object after updating original object: \" + clonedStud.getName() + \" - \" + clonedStud.getSubj().getName()); } } ​ 输出结果如下： Original Object: John - Algebra Cloned Object: John - Algebra Is Original Object the same with Cloned Object: false Is Original Object's field name the same with Cloned Object: true Is Original Object's field subj the same with Cloned Object: true Original Object after it is updated: Dan - Physics Cloned Object after updating original object: John - Physics 在这个例子中，我让要拷贝的类Student实现了Clonable接口并重写Object类的clone()方法，然后在方法内部调用super.clone()方法。从输出结果中我们可以看到，对原始对象stud的\"name\"属性所做的改变并没有影响到拷贝对象clonedStud，但是对引用对象subj的\"name\"属性所做的改变影响到了拷贝对象clonedStud。 三、深拷贝 1、什么是深拷贝 深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 ​ 在上图中，SourceObject有一个int类型的属性 \"field1\"和一个引用类型属性\"refObj1\"（引用ContainedObject类型的对象）。当对SourceObject做深拷贝时，创建了CopiedObject，它有一个包含\"field1\"拷贝值的属性\"field2\"以及包含\"refObj1\"拷贝值的引用类型属性\"refObj2\" 。因此对SourceObject中的\"refObj\"所做的任何改变都不会影响到CopiedObject 2、如何实现深拷贝 下面是实现深拷贝的一个例子。只是在浅拷贝的例子上做了一点小改动，Subject 和CopyTest 类都没有变化。 public class Student implements Cloneable { // 对象引用 private Subject subj; private String name; public Student(String s, String sub) { name = s; subj = new Subject(sub); } public Subject getSubj() { return subj; } public String getName() { return name; } public void setName(String s) { name = s; } /** * 重写clone()方法 * * @return */ public Object clone() { // 深拷贝，创建拷贝类的一个新对象，这样就和原始对象相互独立 Student s = new Student(name, subj.getName()); return s; } } ​ 输出结果如下： Original Object: John - Algebra Cloned Object: John - Algebra Is Original Object the same with Cloned Object: false Is Original Object's field name the same with Cloned Object: true Is Original Object's field subj the same with Cloned Object: false Original Object after it is updated: Dan - Physics Cloned Object after updating original object: John - Algebra 很容易发现clone()方法中的一点变化。因为它是深拷贝，所以你需要创建拷贝类的一个对象。因为在Student类中有对象引用，所以需要在Student类中实现Cloneable接口并且重写clone方法。 3、通过序列化实现深拷贝 也可以通过序列化来实现深拷贝。序列化是干什么的?它将整个对象图写入到一个持久化存储文件中并且当需要的时候把它读取回来, 这意味着当你需要把它读取回来时你需要整个对象图的一个拷贝。这就是当你深拷贝一个对象时真正需要的东西。请注意，当你通过序列化进行深拷贝时，必须确保对象图中所有类都是可序列化的。 public class ColoredCircle implements Serializable { private int x; private int y; public ColoredCircle(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public void setX(int x) { this.x = x; } public int getY() { return y; } public void setY(int y) { this.y = y; } @Override public String toString() { return \"x=\" + x + \", y=\" + y; } } public class DeepCopy { public static void main(String[] args) throws IOException { ObjectOutputStream oos = null; ObjectInputStream ois = null; try { // 创建原始的可序列化对象 ColoredCircle c1 = new ColoredCircle(100, 100); System.out.println(\"Original = \" + c1); ColoredCircle c2 = null; // 通过序列化实现深拷贝 ByteArrayOutputStream bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); // 序列化以及传递这个对象 oos.writeObject(c1); oos.flush(); ByteArrayInputStream bin = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bin); // 返回新的对象 c2 = (ColoredCircle) ois.readObject(); // 校验内容是否相同 System.out.println(\"Copied = \" + c2); // 改变原始对象的内容 c1.setX(200); c1.setY(200); // 查看每一个现在的内容 System.out.println(\"Original = \" + c1); System.out.println(\"Copied = \" + c2); } catch (Exception e) { System.out.println(\"Exception in main = \" + e); } finally { oos.close(); ois.close(); } } } ​ ​ 输出结果如下： Original = x=100, y=100 Copied = x=100, y=100 Original = x=200, y=200 Copied = x=100, y=100 这里，你只需要做以下几件事儿: 确保对象图中的所有类都是可序列化的 创建输入输出流 使用这个输入输出流来创建对象输入和对象输出流 将你想要拷贝的对象传递给对象输出流 从对象输入流中读取新的对象并且转换回你所发送的对象的类 在这个例子中，我创建了一个ColoredCircle对象c1然后将它序列化 (将它写到ByteArrayOutputStream中). 然后我反序列化这个序列化后的对象并将它保存到c2中。随后我修改了原始对象c1。然后结果如你所见，c1不同于c2，对c1所做的任何修改都不会影响c2。 注意，序列化这种方式有其自身的限制和问题： 因为无法序列化transient变量, 使用这种方法将无法拷贝transient变量。 再就是性能问题。创建一个socket, 序列化一个对象, 通过socket传输它, 然后反序列化它，这个过程与调用已有对象的方法相比是很慢的。所以在性能上会有天壤之别。如果性能对你的代码来说是至关重要的，建议不要使用这种方式。它比通过实现Clonable接口这种方式来进行深拷贝几乎多花100倍的时间。 四、延迟拷贝 延迟拷贝是浅拷贝和深拷贝的一个组合，实际上很少会使用。 当最开始拷贝一个对象时，会使用速度较快的浅拷贝，还会使用一个计数器来记录有多少对象共享这个数据。当程序想要修改原始的对象时，它会决定数据是否被共享（通过检查计数器）并根据需要进行深拷贝。 延迟拷贝从外面看起来就是深拷贝，但是只要有可能它就会利用浅拷贝的速度。当原始对象中的引用不经常改变的时候可以使用延迟拷贝。由于存在计数器，效率下降很高，但只是常量级的开销。而且, 在某些情况下, 循环引用会导致一些问题。 五、如何选择 如果对象的属性全是基本类型的，那么可以使用浅拷贝，但是如果对象有引用属性，那就要基于具体的需求来选择浅拷贝还是深拷贝。我的意思是如果对象引用任何时候都不会被改变，那么没必要使用深拷贝，只需要使用浅拷贝就行了。如果对象引用经常改变，那么就要使用深拷贝。没有一成不变的规则，一切都取决于具体需求。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/transient.html":{"url":"java/basis/transient.html","title":"Java transient关键字","keywords":"","body":"一、 transient的作用及使用方法 我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。 然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。 总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。 示例code如下： import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; /** * @description 使用transient关键字不序列化某个变量 * 注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致 * * @author Alexia * @date 2013-10-15 */ public class TransientTest { public static void main(String[] args) { User user = new User(); user.setUsername(\"Alexia\"); user.setPasswd(\"123456\"); System.out.println(\"read before Serializable: \"); System.out.println(\"username: \" + user.getUsername()); System.err.println(\"password: \" + user.getPasswd()); try { ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream(\"C:/user.txt\")); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } try { ObjectInputStream is = new ObjectInputStream(new FileInputStream( \"C:/user.txt\")); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println(\"\\nread after Serializable: \"); System.out.println(\"username: \" + user.getUsername()); System.err.println(\"password: \" + user.getPasswd()); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } class User implements Serializable { private static final long serialVersionUID = 8294180014912103005L; private String username; private transient String passwd; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPasswd() { return passwd; } public void setPasswd(String passwd) { this.passwd = passwd; } } 输出为： read before Serializable: username: Alexia password: 123456 read after Serializable: username: Alexia password: null 二、transient使用小结 1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 第三点可能有些人很迷惑，因为发现在User类中的username字段前加上static关键字后，程序运行结果依然不变，即static类型的username也读出来为“Alexia”了，这不与第三点说的矛盾吗？实际上是这样的：第三点确实没错（一个静态变量不管是否被transient修饰，均不能被序列化），反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的，不相信？好吧，下面我来证明： import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; /** * @description 使用transient关键字不序列化某个变量 * 注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致 * * @author Alexia * @date 2013-10-15 */ public class TransientTest { public static void main(String[] args) { User user = new User(); user.setUsername(\"Alexia\"); user.setPasswd(\"123456\"); System.out.println(\"read before Serializable: \"); System.out.println(\"username: \" + user.getUsername()); System.err.println(\"password: \" + user.getPasswd()); try { ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream(\"C:/user.txt\")); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } try { // 在反序列化之前改变username的值 User.username = \"jmwang\"; ObjectInputStream is = new ObjectInputStream(new FileInputStream( \"C:/user.txt\")); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println(\"\\nread after Serializable: \"); System.out.println(\"username: \" + user.getUsername()); System.err.println(\"password: \" + user.getPasswd()); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } class User implements Serializable { private static final long serialVersionUID = 8294180014912103005L; public static String username; private transient String passwd; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPasswd() { return passwd; } public void setPasswd(String passwd) { this.passwd = passwd; } } 输出为： read before Serializable: username: Alexia password: 123456 read after Serializable: username: jmwang password: null 三、transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？ 思考下面的例子： import java.io.Externalizable; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInput; import java.io.ObjectInputStream; import java.io.ObjectOutput; import java.io.ObjectOutputStream; /** * @descripiton Externalizable接口的使用 * * @author Alexia * @date 2013-10-15 * */ public class ExternalizableTest implements Externalizable { private transient String content = \"是的，我将会被序列化，不管我是否被transient关键字修饰\"; @Override public void writeExternal(ObjectOutput out) throws IOException { out.writeObject(content); } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { content = (String) in.readObject(); } public static void main(String[] args) throws Exception { ExternalizableTest et = new ExternalizableTest(); ObjectOutput out = new ObjectOutputStream(new FileOutputStream( new File(\"test\"))); out.writeObject(et); ObjectInput in = new ObjectInputStream(new FileInputStream(new File( \"test\"))); et = (ExternalizableTest) in.readObject(); System.out.println(et.content); out.close(); in.close(); } } content变量会被序列化吗？好吧，我把答案都输出来了，是的，运行结果就是： 是的，我将会被序列化，不管我是否被transient关键字修饰 这是为什么呢，不是说类的变量被transient关键字修饰以后将不能序列化了吗？ 我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。因此第二个例子输出的是变量content初始化的内容，而不是null。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/finally-return.html":{"url":"java/basis/finally-return.html","title":"Java finally与return执行顺序","keywords":"","body":"网上有很多人探讨Java中异常捕获机制try...catch...finally块中的finally语句是不是一定会被执行？很多人都说不是，当然他们的回答是正确的，经过我试验，至少有两种情况下finally语句是不会被执行的： （1）try语句没有被执行到，如在try语句之前就返回了，这样finally语句就不会执行，这也说明了finally语句被执行的必要而非充分条件是：相应的try语句一定被执行到。 （2）在try块中有System.exit(0);这样的语句，System.exit(0);是终止Java虚拟机JVM的，连JVM都停止了，所有都结束了，当然finally语句也不会被执行到。 当然还有很多人探讨finally语句的执行与return的关系，颇为让人迷惑，不知道finally语句是在try的return之前执行还是之后执行？我也是一头雾水，我觉得他们的说法都不正确，我觉得应该是：finally语句是在try的return语句执行之后，return返回之前执行。这样的说法有点矛盾，也许是我表述不太清楚，下面我给出自己试验的一些结果和示例进行佐证，有什么问题欢迎大家提出来。 1. finally语句在return语句执行之后return返回之前执行的。 public class FinallyTest1 { public static void main(String[] args) { System.out.println(test1()); } public static int test1() { int b = 20; try { System.out.println(\"try block\"); return b += 80; } catch (Exception e) { System.out.println(\"catch block\"); } finally { System.out.println(\"finally block\"); if (b > 25) { System.out.println(\"b>25, b = \" + b); } } return b; } } 运行结果是： try block finally block b>25, b = 100 100 说明return语句已经执行了再去执行finally语句，不过并没有直接返回，而是等finally语句执行完了再返回结果。 如果觉得这个例子还不足以说明这个情况的话，下面再加个例子加强证明结论： public class FinallyTest1 { public static void main(String[] args) { System.out.println(test11()); } public static String test11() { try { System.out.println(\"try block\"); return test12(); } finally { System.out.println(\"finally block\"); } } public static String test12() { System.out.println(\"return statement\"); return \"after return\"; } } 运行结果为： try block return statement finally block after return 说明try中的return语句先执行了但并没有立即返回，等到finally执行结束后再返回。 这里大家可能会想：如果finally里也有return语句，那么是不是就直接返回了，try中的return就不能返回了？看下面。 2. finally块中的return语句会覆盖try块中的return返回。 public class FinallyTest2 { public static void main(String[] args) { System.out.println(test2()); } public static int test2() { int b = 20; try { System.out.println(\"try block\"); return b += 80; } catch (Exception e) { System.out.println(\"catch block\"); } finally { System.out.println(\"finally block\"); if (b > 25) { System.out.println(\"b>25, b = \" + b); } return 200; } // return b; } } 运行结果是： try block finally block b>25, b = 100 200 这说明finally里的return直接返回了，就不管try中是否还有返回语句，这里还有个小细节需要注意，finally里加上return过后，finally外面的return b就变成不可到达语句了，也就是永远不能被执行到，所以需要注释掉否则编译器报错。 这里大家可能又想：如果finally里没有return语句，但修改了b的值，那么try中return返回的是修改后的值还是原值？看下面。 3. 如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变。 测试用例1： public class FinallyTest3 { public static void main(String[] args) { System.out.println(test3()); } public static int test3() { int b = 20; try { System.out.println(\"try block\"); return b += 80; } catch (Exception e) { System.out.println(\"catch block\"); } finally { System.out.println(\"finally block\"); if (b > 25) { System.out.println(\"b>25, b = \" + b); } b = 150; } return 2000; } } 运行结果是： try block finally block b>25, b = 100 100 测试用例2： import java.util.*; public class FinallyTest6 { public static void main(String[] args) { System.out.println(getMap().get(\"KEY\").toString()); } public static Map getMap() { Map map = new HashMap(); map.put(\"KEY\", \"INIT\"); try { map.put(\"KEY\", \"TRY\"); return map; } catch (Exception e) { map.put(\"KEY\", \"CATCH\"); } finally { map.put(\"KEY\", \"FINALLY\"); map = null; } return map; } } 运行结果是： FINALLY 为什么测试用例1中finally里的b = 150;并没有起到作用而测试用例2中finally的map.put(\"KEY\", \"FINALLY\");起了作用而map = null;却没起作用呢？这就是Java到底是传值还是传址的问题了，具体请看精选30道Java笔试题解答，里面有详细的解答，简单来说就是：Java中只有传值没有传址，这也是为什么map = null这句不起作用。这同时也说明了返回语句是try中的return语句而不是 finally外面的return b;这句，不相信的话可以试下，将return b;改为return 294，对原来的结果没有一点影响。 这里大家可能又要想：是不是每次返回的一定是try中的return语句呢？那么finally外的return b不是一点作用没吗？请看下面。 4. try块里的return语句在异常的情况下不会被执行，这样具体返回哪个看情况。 public class FinallyTest4 { public static void main(String[] args) { System.out.println(test4()); } public static int test4() { int b = 20; try { System.out.println(\"try block\"); b = b / 0; return b += 80; } catch (Exception e) { b += 15; System.out.println(\"catch block\"); } finally { System.out.println(\"finally block\"); if (b > 25) { System.out.println(\"b>25, b = \" + b); } b += 50; } return b; } } 运行结果是： try block catch block finally block b>25, b = 35 85 这里因 为在return之前发生了除0异常，所以try中的return不会被执行到，而是接着执行捕获异常的catch 语句和最终的finally语句，此时两者对b的修改都影响了最终的返回值，这时return b;就起到作用了。当然如果你这里将return b改为return 300什么的，最后返回的就是300，这毋庸置疑。 这里大家可能又有疑问：如果catch中有return语句呢？当然只有在异常的情况下才有可能会执行，那么是在finally之前就返回吗？看下面。 5. 当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。 public class FinallyTest5 { public static void main(String[] args) { System.out.println(test5()); } public static int test5() { int b = 20; try { System.out.println(\"try block\"); b = b /0; return b += 80; } catch (Exception e) { System.out.println(\"catch block\"); return b += 15; } finally { System.out.println(\"finally block\"); if (b > 25) { System.out.println(\"b>25, b = \" + b); } b += 50; } //return b; } } 运行结果如下： try block catch block finally block b>25, b = 35 35 说明了发生异常后，catch中的return语句先执行，确定了返回值后再去执行finally块，执行完了catch再返回，finally里对b的改变对返回值无影响，原因同前面一样，也就是说情况与try中的return语句执行完全一样。 最后总结：finally块的语句在try或catch中的return语句执行之后返回之前执行且finally里的修改语句可能影响也可能不影响try或catch中 return已经确定的返回值，若finally里也有return语句则覆盖try或catch中的return语句直接返回。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/basis/java-8.html":{"url":"java/basis/java-8.html","title":"Java 8 新特性","keywords":"","body":"1. 简介 毫无疑问，Java 8是Java自Java 5（发布于2004年）之后的最重要的版本。这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。在本文中我们将学习这些新特性，并用实际的例子说明在什么场景下适合使用。 这个教程包含Java开发者经常面对的几类问题： 语言 编译器 库 工具 运行时（JVM） 2. Java语言的新特性 Java 8是Java的一个重大版本，有人认为，虽然这些新特性领Java开发人员十分期待，但同时也需要花不少精力去学习。在这一小节中，我们将介绍Java 8的大部分新特性。 2.1 Lambda表达式和函数式接口 Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。 Lambda的设计耗费了很多时间和很大的社区力量，最终找到一种折中的实现方案，可以实现简洁而紧凑的语言结构。最简单的Lambda表达式可由逗号分隔的参数列表、->符号和语句块组成，例如： Arrays.asList( \"a\", \"b\", \"d\" ).forEach( e -> System.out.println( e ) ); 在上面这个代码中的参数e的类型是由编译器推理得出的，你也可以显式指定该参数的类型，例如： Arrays.asList( \"a\", \"b\", \"d\" ).forEach( ( String e ) -> System.out.println( e ) ); 如果Lambda表达式需要更复杂的语句块，则可以使用花括号将该语句块括起来，类似于Java中的函数体，例如： Arrays.asList( \"a\", \"b\", \"d\" ).forEach( e -> { System.out.print( e ); System.out.print( e ); } ); Lambda表达式可以引用类成员和局部变量（会将这些变量隐式得转换成final的），例如下列两个代码块的效果完全相同： String separator = \",\"; Arrays.asList( \"a\", \"b\", \"d\" ).forEach( ( String e ) -> System.out.print( e + separator ) ); 和 final String separator = \",\"; Arrays.asList( \"a\", \"b\", \"d\" ).forEach( ( String e ) -> System.out.print( e + separator ) ); Lambda表达式有返回值，返回值的类型也由编译器推理得出。如果Lambda表达式中的语句块只有一行，则可以不用使用return语句，下列两个代码片段效果相同： Arrays.asList( \"a\", \"b\", \"d\" ).sort( ( e1, e2 ) -> e1.compareTo( e2 ) ); 和 Arrays.asList( \"a\", \"b\", \"d\" ).sort( ( e1, e2 ) -> { int result = e1.compareTo( e2 ); return result; } ); Lambda的设计者们为了让现有的功能与Lambda表达式良好兼容，考虑了很多方法，于是产生了函数接口这个概念。函数接口指的是只有一个函数的接口，这样的接口可以隐式转换为Lambda表达式。java.lang.Runnable和java.util.concurrent.Callable是函数式接口的最佳例子。在实践中，函数式接口非常脆弱：只要某个开发者在该接口中添加一个函数，则该接口就不再是函数式接口进而导致编译失败。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8 提供了一个特殊的注解@FunctionalInterface（Java 库中的所有相关接口都已经带有这个注解了），举个简单的函数式接口的定义： @FunctionalInterface public interface Functional { void method(); } 不过有一点需要注意，默认方法和静态方法不会破坏函数式接口的定义，因此如下的代码是合法的。 @FunctionalInterface public interface FunctionalDefaultMethods { void method(); default void defaultMethod() { } } Lambda表达式作为Java 8的最大卖点，它有潜力吸引更多的开发者加入到JVM平台，并在纯Java编程中使用函数式编程的概念。如果你需要了解更多Lambda表达式的细节，可以参考官方文档。 2.2 接口的默认方法和静态方法 Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。默认方法使得接口有点类似traits，不过要实现的目标不一样。默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。 默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下： private interface Defaulable { // Interfaces now allow default methods, the implementer may or // may not implement (override) them. default String notRequired() { return \"Default implementation\"; } } private static class DefaultableImpl implements Defaulable { } private static class OverridableImpl implements Defaulable { @Override public String notRequired() { return \"Overridden implementation\"; } } Defaulable接口使用关键字default定义了一个默认方法notRequired()。DefaultableImpl类实现了这个接口，同时默认继承了这个接口中的默认方法；OverridableImpl类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。 Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，例子代码如下： private interface DefaulableFactory { // Interfaces now allow static methods static Defaulable create( Supplier supplier ) { return supplier.get(); } } 下面的代码片段整合了默认方法和静态方法的使用场景： public static void main( String[] args ) { Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::new ); System.out.println( defaulable.notRequired() ); defaulable = DefaulableFactory.create( OverridableImpl::new ); System.out.println( defaulable.notRequired() ); } 这段代码的输出结果如下： Default implementation Overridden implementation 由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给java.util.Collection接口添加新方法，如stream()、parallelStream()、forEach()和removeIf()等等。 尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。如果你想了解更多细节，可以参考官方文档。 2.3 方法引用 方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。 西门的例子中，Car类是不同方法引用的例子，可以帮助读者区分四种类型的方法引用。 public static class Car { public static Car create( final Supplier supplier ) { return supplier.get(); } public static void collide( final Car car ) { System.out.println( \"Collided \" + car.toString() ); } public void follow( final Car another ) { System.out.println( \"Following the \" + another.toString() ); } public void repair() { System.out.println( \"Repaired \" + this.toString() ); } } 第一种方法引用的类型是构造器引用，语法是Class::new，或者更一般的形式：Class::new。注意：这个构造器没有参数。 final Car car = Car.create( Car::new ); final List cars = Arrays.asList( car ); 第二种方法引用的类型是静态方法引用，语法是Class::static_method。注意：这个方法接受一个Car类型的参数。 cars.forEach( Car::collide ); 第三种方法引用的类型是某个类的成员方法的引用，语法是Class::method，注意，这个方法没有定义入参： cars.forEach( Car::repair ); 第四种方法引用的类型是某个实例对象的成员方法的引用，语法是instance::method。注意：这个方法接受一个Car类型的参数： final Car police = Car.create( Car::new ); cars.forEach( police::follow ); 运行上述例子，可以在控制台看到如下输出（Car实例可能不同）： Collided com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d Repaired com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d Following the com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d 如果想了解和学习更详细的内容，可以参考官方文档 2.4 重复注解 自从Java 5中引入注解以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。 在Java 8中使用@Repeatable注解定义重复注解，实际上，这并不是语言层面的改进，而是编译器做的一个trick，底层的技术仍然相同。可以利用下面的代码说明： package com.javacodegeeks.java8.repeatable.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Repeatable; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; public class RepeatingAnnotations { @Target( ElementType.TYPE ) @Retention( RetentionPolicy.RUNTIME ) public @interface Filters { Filter[] value(); } @Target( ElementType.TYPE ) @Retention( RetentionPolicy.RUNTIME ) @Repeatable( Filters.class ) public @interface Filter { String value(); }; @Filter( \"filter1\" ) @Filter( \"filter2\" ) public interface Filterable { } public static void main(String[] args) { for( Filter filter: Filterable.class.getAnnotationsByType( Filter.class ) ) { System.out.println( filter.value() ); } } } 正如我们所见，这里的Filter类使用@Repeatable(Filters.class)注解修饰，而Filters是存放Filter注解的容器，编译器尽量对开发者屏蔽这些细节。这样，Filterable接口可以用两个Filter注解注释（这里并没有提到任何关于Filters的信息）。 另外，反射API提供了一个新的方法：getAnnotationsByType()，可以返回某个类型的重复注解，例如Filterable.class.getAnnoation(Filters.class)将返回两个Filter实例，输出到控制台的内容如下所示： filter1 filter2 如果你希望了解更多内容，可以参考官方文档。 2.5 更好的类型推断 Java 8编译器在类型推断方面有很大的提升，在很多场景下编译器可以推导出某个参数的数据类型，从而使得代码更为简洁。例子代码如下： package com.javacodegeeks.java8.type.inference; public class Value { public static T defaultValue() { return null; } public T getOrDefault( T value, T defaultValue ) { return ( value != null ) ? value : defaultValue; } } 下列代码是Value类型的应用： package com.javacodegeeks.java8.type.inference; public class TypeInference { public static void main(String[] args) { final Value value = new Value<>(); value.getOrDefault( \"22\", Value.defaultValue() ); } } 参数Value.defaultValue()的类型由编译器推导得出，不需要显式指明。在Java 7中这段代码会有编译错误，除非使用Value.defaultValue()。 2.6 拓宽注解的应用场景 Java 8拓宽了注解的应用场景。现在，注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。下面是一些例子： package com.javacodegeeks.java8.annotations; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import java.util.ArrayList; import java.util.Collection; public class Annotations { @Retention( RetentionPolicy.RUNTIME ) @Target( { ElementType.TYPE_USE, ElementType.TYPE_PARAMETER } ) public @interface NonEmpty { } public static class Holder extends @NonEmpty Object { public void method() throws @NonEmpty Exception { } } @SuppressWarnings( \"unused\" ) public static void main(String[] args) { final Holder holder = new @NonEmpty Holder(); @NonEmpty Collection strings = new ArrayList<>(); } } ElementType.TYPE_USER和ElementType.TYPE_PARAMETER是Java 8新增的两个注解，用于描述注解的使用场景。Java 语言也做了对应的改变，以识别这些新增的注解。 3. Java编译器的新特性 3.1 参数名称 为了在运行时获得Java程序中方法的参数名称，老一辈的Java程序员必须使用不同方法，例如Paranamer liberary。Java 8终于将这个特性规范化，在语言层面（使用反射API和Parameter.getName()方法）和字节码层面（使用新的javac编译器以及-parameters参数）提供支持。 package com.javacodegeeks.java8.parameter.names; import java.lang.reflect.Method; import java.lang.reflect.Parameter; public class ParameterNames { public static void main(String[] args) throws Exception { Method method = ParameterNames.class.getMethod( \"main\", String[].class ); for( final Parameter parameter: method.getParameters() ) { System.out.println( \"Parameter: \" + parameter.getName() ); } } } 在Java 8中这个特性是默认关闭的，因此如果不带-parameters参数编译上述代码并运行，则会输出如下结果： Parameter: arg0 如果带-parameters参数，则会输出如下结果（正确的结果）： Parameter: args 如果你使用Maven进行项目管理，则可以在maven-compiler-plugin编译器的配置项中配置-parameters参数： org.apache.maven.plugins maven-compiler-plugin 3.1 -parameters 1.8 1.8 4. Java官方库的新特性 Java 8增加了很多新的工具类（date/time类），并扩展了现存的工具类，以支持现代的并发编程、函数式编程等。 4.1 Optional Java应用中最常见的bug就是空值异常。在Java 8之前，Google Guava引入了Optionals类来解决NullPointerException，从而避免源码被各种null检查污染，以便开发者写出更加整洁的代码。Java 8也将Optional加入了官方库。 Optional仅仅是一个容易：存放T类型的值或者null。它提供了一些有用的接口来避免显式的null检查，可以参考Java 8官方文档了解更多细节。 接下来看一点使用Optional的例子：可能为空的值或者某个类型的值： Optional fullName = Optional.ofNullable( null ); System.out.println( \"Full Name is set? \" + fullName.isPresent() ); System.out.println( \"Full Name: \" + fullName.orElseGet( () -> \"[none]\" ) ); System.out.println( fullName.map( s -> \"Hey \" + s + \"!\" ).orElse( \"Hey Stranger!\" ) ); 如果Optional实例持有一个非空值，则isPresent()方法返回true，否则返回false；orElseGet()方法，Optional实例持有null，则可以接受一个lambda表达式生成的默认值；map()方法可以将现有的Opetional实例的值转换成新的值；orElse()方法与orElseGet()方法类似，但是在持有null的时候返回传入的默认值。 上述代码的输出结果如下： Full Name is set? false Full Name: [none] Hey Stranger! 再看下另一个简单的例子： Optional firstName = Optional.of( \"Tom\" ); System.out.println( \"First Name is set? \" + firstName.isPresent() ); System.out.println( \"First Name: \" + firstName.orElseGet( () -> \"[none]\" ) ); System.out.println( firstName.map( s -> \"Hey \" + s + \"!\" ).orElse( \"Hey Stranger!\" ) ); System.out.println(); 这个例子的输出是： First Name is set? true First Name: Tom Hey Tom! 如果想了解更多的细节，请参考官方文档。 4.2 Streams 新增的Stream API（java.util.stream）将生成环境的函数式编程引入了Java库中。这是目前为止最大的一次对Java库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。 Stream API极大得简化了集合操作（后面我们会看到不止是集合），首先看下这个叫Task的类： public class Streams { private enum Status { OPEN, CLOSED }; private static final class Task { private final Status status; private final Integer points; Task( final Status status, final Integer points ) { this.status = status; this.points = points; } public Integer getPoints() { return points; } public Status getStatus() { return status; } @Override public String toString() { return String.format( \"[%s, %d]\", status, points ); } } } Task类有一个分数（或伪复杂度）的概念，另外还有两种状态：OPEN或者CLOSED。现在假设有一个task集合： final Collection tasks = Arrays.asList( new Task( Status.OPEN, 5 ), new Task( Status.OPEN, 13 ), new Task( Status.CLOSED, 8 ) ); 首先看一个问题：在这个task集合中一共有多少个OPEN状态的点？在Java 8之前，要解决这个问题，则需要使用foreach循环遍历task集合；但是在Java 8中可以利用steams解决：包括一系列元素的列表，并且支持顺序和并行处理。 // Calculate total points of all active tasks using sum() final long totalPointsOfOpenTasks = tasks .stream() .filter( task -> task.getStatus() == Status.OPEN ) .mapToInt( Task::getPoints ) .sum(); System.out.println( \"Total points: \" + totalPointsOfOpenTasks ); 运行这个方法的控制台输出是： Total points: 18 这里有很多知识点值得说。首先，tasks集合被转换成steam表示；其次，在steam上的filter操作会过滤掉所有CLOSED的task；第三，mapToInt操作基于每个task实例的Task::getPoints方法将task流转换成Integer集合；最后，通过sum方法计算总和，得出最后的结果。 在学习下一个例子之前，还需要记住一些steams（点此更多细节）的知识点。Steam之上的操作可分为中间操作和晚期操作。 中间操作会返回一个新的steam——执行一个中间操作（例如filter）并不会执行实际的过滤操作，而是创建一个新的steam，并将原steam中符合条件的元素放入新创建的steam。 晚期操作（例如forEach或者sum），会遍历steam并得出结果或者附带结果；在执行晚期操作之后，steam处理线已经处理完毕，就不能使用了。在几乎所有情况下，晚期操作都是立刻对steam进行遍历。 steam的另一个价值是创造性地支持并行处理（parallel processing）。对于上述的tasks集合，我们可以用下面的代码计算所有任务的点数之和： // Calculate total points of all tasks final double totalPoints = tasks .stream() .parallel() .map( task -> task.getPoints() ) // or map( Task::getPoints ) .reduce( 0, Integer::sum ); System.out.println( \"Total points (all tasks): \" + totalPoints ); 这里我们使用parallel方法并行处理所有的task，并使用reduce方法计算最终的结果。控制台输出如下： Total points（all tasks）: 26.0 对于一个集合，经常需要根据某些条件对其中的元素分组。利用steam提供的API可以很快完成这类任务，代码如下： // Group tasks by their status final Map > map = tasks .stream() .collect( Collectors.groupingBy( Task::getStatus ) ); System.out.println( map ); 控制台的输出如下： {CLOSED=[[CLOSED, 8]], OPEN=[[OPEN, 5], [OPEN, 13]]} 最后一个关于tasks集合的例子问题是：如何计算集合中每个任务的点数在集合中所占的比重，具体处理的代码如下： // Calculate the weight of each tasks (as percent of total points) final Collection result = tasks .stream() // Stream .mapToInt( Task::getPoints ) // IntStream .asLongStream() // LongStream .mapToDouble( points -> points / totalPoints ) // DoubleStream .boxed() // Stream .mapToLong( weigth -> ( long )( weigth * 100 ) ) // LongStream .mapToObj( percentage -> percentage + \"%\" ) // Stream .collect( Collectors.toList() ); // List System.out.println( result ); 控制台输出结果如下： [19%, 50%, 30%] 最后，正如之前所说，Steam API不仅可以作用于Java集合，传统的IO操作（从文件或者网络一行一行得读取数据）可以受益于steam处理，这里有一个小例子： final Path path = new File( filename ).toPath(); try( Stream lines = Files.lines( path, StandardCharsets.UTF_8 ) ) { lines.onClose( () -> System.out.println(\"Done!\") ).forEach( System.out::println ); } Stream的方法onClose 返回一个等价的有额外句柄的Stream，当Stream的close（）方法被调用的时候这个句柄会被执行。Stream API、Lambda表达式还有接口默认方法和静态方法支持的方法引用，是Java 8对软件开发的现代范式的响应。 4.3 Date/Time API(JSR 310) Java 8引入了新的Date-Time API(JSR 310)来改进时间、日期的处理。时间和日期的管理一直是最令Java开发者痛苦的问题。java.util.Date和后来的java.util.Calendar一直没有解决这个问题（甚至令开发者更加迷茫）。 因为上面这些原因，诞生了第三方库Joda-Time，可以替代Java的时间管理API。Java 8中新的时间和日期管理API深受Joda-Time影响，并吸收了很多Joda-Time的精华。新的java.time包包含了所有关于日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。新设计的API认真考虑了这些类的不变性（从java.util.Calendar吸取的教训），如果某个实例需要修改，则返回一个新的对象。 我们接下来看看java.time包中的关键类和各自的使用例子。首先，Clock类使用时区来返回当前的纳秒时间和日期。Clock可以替代System.currentTimeMillis()和TimeZone.getDefault()。 // Get the system clock as UTC offset final Clock clock = Clock.systemUTC(); System.out.println( clock.instant() ); System.out.println( clock.millis() ); 这个例子的输出结果是： 2014-04-12T15:19:29.282Z 1397315969360 第二，关注下LocalDate和LocalTime类。LocalDate仅仅包含ISO-8601日历系统中的日期部分；LocalTime则仅仅包含该日历系统中的时间部分。这两个类的对象都可以使用Clock对象构建得到。 // Get the local date and local time final LocalDate date = LocalDate.now(); final LocalDate dateFromClock = LocalDate.now( clock ); System.out.println( date ); System.out.println( dateFromClock ); // Get the local date and local time final LocalTime time = LocalTime.now(); final LocalTime timeFromClock = LocalTime.now( clock ); System.out.println( time ); System.out.println( timeFromClock ); 上述例子的输出结果如下： 2014-04-12 2014-04-12 11:25:54.568 15:25:54.568 LocalDateTime类包含了LocalDate和LocalTime的信息，但是不包含ISO-8601日历系统中的时区信息。这里有一些关于LocalDate和LocalTime的例子： // Get the local date/time final LocalDateTime datetime = LocalDateTime.now(); final LocalDateTime datetimeFromClock = LocalDateTime.now( clock ); System.out.println( datetime ); System.out.println( datetimeFromClock ); 上述这个例子的输出结果如下： 2014-04-12T11:37:52.309 2014-04-12T15:37:52.309 如果你需要特定时区的data/time信息，则可以使用ZoneDateTime，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。下面是一些使用不同时区的例子： // Get the zoned date/time final ZonedDateTime zonedDatetime = ZonedDateTime.now(); final ZonedDateTime zonedDatetimeFromClock = ZonedDateTime.now( clock ); final ZonedDateTime zonedDatetimeFromZone = ZonedDateTime.now( ZoneId.of( \"America/Los_Angeles\" ) ); System.out.println( zonedDatetime ); System.out.println( zonedDatetimeFromClock ); System.out.println( zonedDatetimeFromZone ); 这个例子的输出结果是： 2014-04-12T11:47:01.017-04:00[America/New_York] 2014-04-12T15:47:01.017Z 2014-04-12T08:47:01.017-07:00[America/Los_Angeles] 最后看下Duration类，它持有的时间精确到秒和纳秒。这使得我们可以很容易得计算两个日期之间的不同，例子代码如下： // Get duration between two dates final LocalDateTime from = LocalDateTime.of( 2014, Month.APRIL, 16, 0, 0, 0 ); final LocalDateTime to = LocalDateTime.of( 2015, Month.APRIL, 16, 23, 59, 59 ); final Duration duration = Duration.between( from, to ); System.out.println( \"Duration in days: \" + duration.toDays() ); System.out.println( \"Duration in hours: \" + duration.toHours() ); 这个例子用于计算2014年4月16日和2015年4月16日之间的天数和小时数，输出结果如下： Duration in days: 365 Duration in hours: 8783 对于Java 8的新日期时间的总体印象还是比较积极的，一部分是因为Joda-Time的积极影响，另一部分是因为官方终于听取了开发人员的需求。如果希望了解更多细节，可以参考官方文档。 4.4 Nashorn JavaScript引擎 Java 8提供了新的Nashorn JavaScript引擎，使得我们可以在JVM上开发和运行JS应用。Nashorn JavaScript引擎是javax.script.ScriptEngine的另一个实现版本，这类Script引擎遵循相同的规则，允许Java和JavaScript交互使用，例子代码如下： ScriptEngineManager manager = new ScriptEngineManager(); ScriptEngine engine = manager.getEngineByName( \"JavaScript\" ); System.out.println( engine.getClass().getName() ); System.out.println( \"Result:\" + engine.eval( \"function f() { return 1; }; f() + 1;\" ) ); 这个代码的输出结果如下： jdk.nashorn.api.scripting.NashornScriptEngine Result: 2 4.5 Base64 对Base64编码的支持已经被加入到Java 8官方库中，这样不需要使用第三方库就可以进行Base64编码，例子代码如下： package com.javacodegeeks.java8.base64; import java.nio.charset.StandardCharsets; import java.util.Base64; public class Base64s { public static void main(String[] args) { final String text = \"Base64 finally in Java 8!\"; final String encoded = Base64 .getEncoder() .encodeToString( text.getBytes( StandardCharsets.UTF_8 ) ); System.out.println( encoded ); final String decoded = new String( Base64.getDecoder().decode( encoded ), StandardCharsets.UTF_8 ); System.out.println( decoded ); } } 这个例子的输出结果如下： QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ== Base64 finally in Java 8! 新的Base64API也支持URL和MINE的编码解码。 (Base64.getUrlEncoder() / Base64.getUrlDecoder(), Base64.getMimeEncoder() / Base64.getMimeDecoder())。 4.6 并行数组 Java8版本新增了很多新的方法，用于支持并行数组处理。最重要的方法是parallelSort()，可以显著加快多核机器上的数组排序。下面的例子论证了parallexXxx系列的方法： package com.javacodegeeks.java8.parallel.arrays; import java.util.Arrays; import java.util.concurrent.ThreadLocalRandom; public class ParallelArrays { public static void main( String[] args ) { long[] arrayOfLong = new long [ 20000 ]; Arrays.parallelSetAll( arrayOfLong, index -> ThreadLocalRandom.current().nextInt( 1000000 ) ); Arrays.stream( arrayOfLong ).limit( 10 ).forEach( i -> System.out.print( i + \" \" ) ); System.out.println(); Arrays.parallelSort( arrayOfLong ); Arrays.stream( arrayOfLong ).limit( 10 ).forEach( i -> System.out.print( i + \" \" ) ); System.out.println(); } } 上述这些代码使用parallelSetAll()方法生成20000个随机数，然后使用parallelSort()方法进行排序。这个程序会输出乱序数组和排序数组的前10个元素。上述例子的代码输出的结果是： Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378 Sorted: 39 220 263 268 325 607 655 678 723 793 4.7 并发性 基于新增的lambda表达式和steam特性，为Java 8中为java.util.concurrent.ConcurrentHashMap类添加了新的方法来支持聚焦操作；另外，也为java.util.concurrentForkJoinPool类添加了新的方法来支持通用线程池操作（更多内容可以参考我们的并发编程课程）。 Java 8还添加了新的java.util.concurrent.locks.StampedLock类，用于支持基于容量的锁——该锁有三个模型用于支持读写操作（可以把这个锁当做是java.util.concurrent.locks.ReadWriteLock的替代者）。 在java.util.concurrent.atomic包中也新增了不少工具类，列举如下： DoubleAccumulator DoubleAdder LongAccumulator LongAdder 5. 新的Java工具 Java 8提供了一些新的命令行工具，这部分会讲解一些对开发者最有用的工具。 5.1 Nashorn引擎：jjs jjs是一个基于标准Nashorn引擎的命令行工具，可以接受js源码并执行。例如，我们写一个func.js文件，内容如下： function f() { return 1; }; print( f() + 1 ); 可以在命令行中执行这个命令：jjs func.js，控制台输出结果是： 2 如果需要了解细节，可以参考官方文档。 5.2 类依赖分析器：jdeps jdeps是一个相当棒的命令行工具，它可以展示包层级和类层级的Java类依赖关系，它以.class文件、目录或者Jar文件为输入，然后会把依赖关系输出到控制台。 我们可以利用jedps分析下Spring Framework库，为了让结果少一点，仅仅分析一个JAR文件：org.springframework.core-3.0.5.RELEASE.jar。 jdeps org.springframework.core-3.0.5.RELEASE.jar 这个命令会输出很多结果，我们仅看下其中的一部分：依赖关系按照包分组，如果在classpath上找不到依赖，则显示\"not found\". org.springframework.core-3.0.5.RELEASE.jar -> C:\\Program Files\\Java\\jdk1.8.0\\jre\\lib\\rt.jar org.springframework.core (org.springframework.core-3.0.5.RELEASE.jar) -> java.io -> java.lang -> java.lang.annotation -> java.lang.ref -> java.lang.reflect -> java.util -> java.util.concurrent -> org.apache.commons.logging not found -> org.springframework.asm not found -> org.springframework.asm.commons not found org.springframework.core.annotation (org.springframework.core-3.0.5.RELEASE.jar) -> java.lang -> java.lang.annotation -> java.lang.reflect -> java.util 更多的细节可以参考官方文档。 6. JVM的新特性 使用Metaspace（JEP 122）代替持久代（PermGen space）。在JVM参数方面，使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/concurrence.html":{"url":"java/concurrence.html","title":"Java并发","keywords":"","body":"一、前言 本部分内容是关于Java并发的一些知识总结，既是学习的难点，同时也是面试中几乎必问的知识点。 面试中可能会问的一些问题： 创建线程的方式 Synchronized/ReentrantLock 生产者/消费者模式 volatile关键字 乐观锁/悲观锁 死锁 了解的并发集合 因此针对以上问题，整理了相关内容。 二、目录 Java创建线程的三种方式 Java线程池 死锁 Synchronized/ReentrantLock 生产者/消费者模式 volatile关键字 CAS原子操作 AbstractQueuedSynchronizer详解 深入理解ReentrantLock Java并发集合——ArrayBlockingQueue Java并发集合——LinkedBlockingQueue Java并发集合——ConcurrentHashMap Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/concurrence/CreateThread.html":{"url":"java/concurrence/CreateThread.html","title":"Java创建线程的三种方式","keywords":"","body":"一、继承Thread类创建线程类 （1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 （2）创建Thread子类的实例，即创建了线程对象。 （3）调用线程对象的start()方法来启动该线程。 public class FirstThreadTest extends Thread { int i = 0; //重写run方法，run方法的方法体就是现场执行体 public void run() { for (; i 上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName()方法返回调用该方法的线程的名字。 二、通过Runnable接口创建线程类 （1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 （2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 （3）调用线程对象的start()方法来启动该线程。 public class RunnableThreadTest implements Runnable { private int i; public void run() { for (i = 0; i 三、通过Callable和Future创建线程 （1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 （2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 （3）使用FutureTask对象作为Thread对象的target创建并启动新线程。 （4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值，调用get()方法会阻塞线程。 public class CallableThreadTest implements Callable { public static void main(String[] args) { CallableThreadTest ctt = new CallableThreadTest(); FutureTask ft = new FutureTask<>(ctt); for (int i = 0; i 四、创建线程的三种方式的对比 采用实现Runnable、Callable接口的方式创见多线程时，优势是： 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 劣势是： 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 使用继承Thread类的方式创建多线程时优势是： 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。 劣势是： 线程类已经继承了Thread类，所以不能再继承其他父类。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/concurrence/thread-pool.html":{"url":"java/concurrence/thread-pool.html","title":"Java线程池","keywords":"","body":"一、概述 在我们的开发中经常会使用到多线程。例如在Android中，由于主线程的诸多限制，像网络请求等一些耗时的操作我们必须在子线程中运行。我们往往会通过new Thread来开启一个子线程，待子线程操作完成以后通过Handler切换到主线程中运行。这么以来我们无法管理我们所创建的子线程，并且无限制的创建子线程，它们相互之间竞争，很有可能由于占用过多资源而导致死机或者OOM。所以在Java中为我们提供了线程池来管理我们所创建的线程。 线程池的优势 ①降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗； ②提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行； ③方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或oom等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率； ④更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。 二、ThreadPoolExecutor 我们可以通过ThreadPoolExecutor来创建一个线程池。 ExecutorService service = new ThreadPoolExecutor(....); 下面我们就来看一下ThreadPoolExecutor中的一个构造方法。 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ThreadPoolExecutor参数含义 1. corePoolSize 线程池中的核心线程数，默认情况下，核心线程一直存活在线程池中，即便他们在线程池中处于闲置状态。除非我们将ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这时候处于闲置的核心线程在等待新任务到来时会有超时策略，这个超时时间由keepAliveTime来指定。一旦超过所设置的超时时间，闲置的核心线程就会被终止。 2. maximumPoolSize 线程池中所容纳的最大线程数，如果活动的线程达到这个数值以后，后续的新任务将会被阻塞。包含核心线程数+非核心线程数。 3. keepAliveTime 非核心线程闲置时的超时时长，对于非核心线程，闲置时间超过这个时间，非核心线程就会被回收。只有对ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这个超时时间才会对核心线程产生效果。 4. unit 用于指定keepAliveTime参数的时间单位。他是一个枚举，可以使用的单位有天（TimeUnit.DAYS），小时（TimeUnit.HOURS），分钟（TimeUnit.MINUTES），毫秒(TimeUnit.MILLISECONDS)，微秒(TimeUnit.MICROSECONDS, 千分之一毫秒)和毫微秒(TimeUnit.NANOSECONDS, 千分之一微秒); 5. workQueue 线程池中保存等待执行的任务的阻塞队列。通过线程池中的execute方法提交的Runable对象都会存储在该队列中。我们可以选择下面几个阻塞队列。 阻塞队列 说明 ArrayBlockingQueue 基于数组实现的有界的阻塞队列,该队列按照FIFO（先进先出）原则对队列中的元素进行排序。 LinkedBlockingQueue 基于链表实现的阻塞队列，该队列按照FIFO（先进先出）原则对队列中的元素进行排序。 SynchronousQueue 内部没有任何容量的阻塞队列。在它内部没有任何的缓存空间。对于SynchronousQueue中的数据元素只有当我们试着取走的时候才可能存在。 PriorityBlockingQueue 具有优先级的无限阻塞队列。 我们还能够通过实现BlockingQueue接口来自定义我们所需要的阻塞队列。 6. threadFactory 线程工厂，为线程池提供新线程的创建。ThreadFactory是一个接口，里面只有一个newThread方法。 默认为DefaultThreadFactory类。 7. handler 是RejectedExecutionHandler对象，而RejectedExecutionHandler是一个接口，里面只有一个rejectedExecution方法。当任务队列已满并且线程池中的活动线程已经达到所限定的最大值或者是无法成功执行任务，这时候ThreadPoolExecutor会调用RejectedExecutionHandler中的rejectedExecution方法。在ThreadPoolExecutor中有四个内部类实现了RejectedExecutionHandler接口。在线程池中它默认是AbortPolicy，在无法处理新任务时抛出RejectedExecutionException异常。 下面是在ThreadPoolExecutor中提供的四个可选值。 可选值 说明 CallerRunsPolicy 只用调用者所在线程来运行任务。 AbortPolicy 直接抛出RejectedExecutionException异常。 DiscardPolicy 丢弃掉该任务，不进行处理。 DiscardOldestPolicy 丢弃队列里最近的一个任务，并执行当前任务。 我们也可以通过实现RejectedExecutionHandler接口来自定义我们自己的handler。如记录日志或持久化不能处理的任务。 ThreadPoolExecutor的使用 ExecutorService service = new ThreadPoolExecutor(5, 10, 10, TimeUnit.SECONDS, new LinkedBlockingQueue<>()); 对于ThreadPoolExecutor有多个构造方法，对于上面的构造方法中的其他参数都采用默认值。可以通过execute和submit两种方式来向线程池提交一个任务。 execute 当我们使用execute来提交任务时，由于execute方法没有返回值，所以说我们也就无法判定任务是否被线程池执行成功。 service.execute(new Runnable() { public void run() { System.out.println(\"execute方式\"); } }); submit 当我们使用submit来提交任务时,它会返回一个future,我们就可以通过这个future来判断任务是否执行成功，还可以通过future的get方法来获取返回值。如果子线程任务没有完成，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时候有可能任务并没有执行完。 Future future = service.submit(new Callable() { @Override public Integer call() throws Exception { System.out.println(\"submit方式\"); return 2; } }); try { Integer number = future.get(); } catch (ExecutionException e) { // TODO Auto-generated catch block e.printStackTrace(); } 线程池关闭 调用线程池的shutdown()或shutdownNow()方法来关闭线程池 shutdown原理：将线程池状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。 shutdownNow原理：将线程池的状态设置成STOP状态，然后中断所有任务(包括正在执行的)的线程，并返回等待执行任务的列表。 中断采用interrupt方法，所以无法响应中断的任务可能永远无法终止。 但调用上述的两个关闭之一，isShutdown()方法返回值为true，当所有任务都已关闭，表示线程池关闭完成，则isTerminated()方法返回值为true。当需要立刻中断所有的线程，不一定需要执行完任务，可直接调用shutdownNow()方法。 三、线程池执行流程 ①如果在线程池中的线程数量没有达到核心的线程数量，这时候就回启动一个核心线程来执行任务。 ②如果线程池中的线程数量已经超过核心线程数，这时候任务就会被插入到任务队列中排队等待执行。 ③由于任务队列已满，无法将任务插入到任务队列中。这个时候如果线程池中的线程数量没有达到线程池所设定的最大值，那么这时候就会立即启动一个非核心线程来执行任务。 ④如果线程池中的数量达到了所规定的最大值，那么就会拒绝执行此任务，这时候就会调用RejectedExecutionHandler中的rejectedExecution方法来通知调用者。 四、四种线程池类 Java中四种具有不同功能常见的线程池。他们都是直接或者间接配置ThreadPoolExecutor来实现他们各自的功能。这四种线程池分别是newFixedThreadPool,newCachedThreadPool,newScheduledThreadPool和newSingleThreadExecutor。这四个线程池可以通过Executors类获取。 1. newFixedThreadPool 通过Executors中的newFixedThreadPool方法来创建，该线程池是一种线程数量固定的线程池。 ExecutorService service = Executors.newFixedThreadPool(4); 在这个线程池中 所容纳最大的线程数就是我们设置的核心线程数。 如果线程池的线程处于空闲状态的话，它们并不会被回收，除非是这个线程池被关闭。如果所有的线程都处于活动状态的话，新任务就会处于等待状态，直到有线程空闲出来。 由于newFixedThreadPool只有核心线程，并且这些线程都不会被回收，也就是 它能够更快速的响应外界请求 。从下面的newFixedThreadPool方法的实现可以看出，newFixedThreadPool只有核心线程，并且不存在超时机制，采用LinkedBlockingQueue，所以对于任务队列的大小也是没有限制的。 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); } 2. newCachedThreadPool 通过Executors中的newCachedThreadPool方法来创建。 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue()); } 通过s上面的newCachedThreadPool方法在这里我们可以看出它的 核心线程数为0， 线程池的最大线程数Integer.MAX_VALUE。而Integer.MAX_VALUE是一个很大的数，也差不多可以说 这个线程池中的最大线程数可以任意大。 当线程池中的线程都处于活动状态的时候，线程池就会创建一个新的线程来处理任务。该线程池中的线程超时时长为60秒，所以当线程处于闲置状态超过60秒的时候便会被回收。 这也就意味着若是整个线程池的线程都处于闲置状态超过60秒以后，在newCachedThreadPool线程池中是不存在任何线程的，所以这时候它几乎不占用任何的系统资源。 对于newCachedThreadPool他的任务队列采用的是SynchronousQueue，上面说到在SynchronousQueue内部没有任何容量的阻塞队列。SynchronousQueue内部相当于一个空集合，我们无法将一个任务插入到SynchronousQueue中。所以说在线程池中如果现有线程无法接收任务,将会创建新的线程来执行任务。 3. newScheduledThreadPool 通过Executors中的newScheduledThreadPool方法来创建。 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); } 它的核心线程数是固定的，对于非核心线程几乎可以说是没有限制的，并且当非核心线程处于限制状态的时候就会立即被回收。 创建一个可定时执行或周期执行任务的线程池： ScheduledExecutorService service = Executors.newScheduledThreadPool(4); service.schedule(new Runnable() { public void run() { System.out.println(Thread.currentThread().getName()+\"延迟三秒执行\"); } }, 3, TimeUnit.SECONDS); service.scheduleAtFixedRate(new Runnable() { public void run() { System.out.println(Thread.currentThread().getName()+\"延迟三秒后每隔2秒执行\"); } }, 3, 2, TimeUnit.SECONDS); 输出结果： pool-1-thread-2延迟三秒后每隔2秒执行 pool-1-thread-1延迟三秒执行 pool-1-thread-1延迟三秒后每隔2秒执行 pool-1-thread-2延迟三秒后每隔2秒执行 pool-1-thread-2延迟三秒后每隔2秒执行 schedule(Runnable command, long delay, TimeUnit unit)：延迟一定时间后执行Runnable任务； schedule(Callable callable, long delay, TimeUnit unit)：延迟一定时间后执行Callable任务； scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)：延迟一定时间后，以间隔period时间的频率周期性地执行任务； scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,TimeUnit unit):与scheduleAtFixedRate()方法很类似，但是不同的是scheduleWithFixedDelay()方法的周期时间间隔是以上一个任务执行结束到下一个任务开始执行的间隔，而scheduleAtFixedRate()方法的周期时间间隔是以上一个任务开始执行到下一个任务开始执行的间隔，也就是这一些任务系列的触发时间都是可预知的。 ScheduledExecutorService功能强大，对于定时执行的任务，建议多采用该方法。 4. newSingleThreadExecutor 通过Executors中的newSingleThreadExecutor方法来创建，在这个线程池中只有一个核心线程，对于任务队列没有大小限制，也就意味着这一个任务处于活动状态时，其他任务都会在任务队列中排队等候依次执行。 newSingleThreadExecutor将所有的外界任务统一到一个线程中支持，所以在这个任务执行之间我们不需要处理线程同步的问题。 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue())); } 五、线程池的使用技巧 需要针对具体情况而具体处理，不同的任务类别应采用不同规模的线程池，任务类别可划分为CPU密集型任务、IO密集型任务和混合型任务。(N代表CPU个数) 任务类别 说明 CPU密集型任务 线程池中线程个数应尽量少，如配置N+1个线程的线程池。 IO密集型任务 由于IO操作速度远低于CPU速度，那么在运行这类任务时，CPU绝大多数时间处于空闲状态，那么线程池可以配置尽量多些的线程，以提高CPU利用率，如2*N。 混合型任务 可以拆分为CPU密集型任务和IO密集型任务，当这两类任务执行时间相差无几时，通过拆分再执行的吞吐率高于串行执行的吞吐率，但若这两类任务执行时间有数据级的差距，那么没有拆分的意义。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/concurrence/deadlock.html":{"url":"java/concurrence/deadlock.html","title":"死锁","keywords":"","body":"一、死锁产生的条件 一般来说，要出现死锁问题需要满足以下条件： 互斥条件：一个资源每次只能被一个线程使用。 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。 在JAVA编程中，有3种典型的死锁类型：静态的锁顺序死锁，动态的锁顺序死锁，协作对象之间发生的死锁。 二、静态的锁顺序死锁 a和b两个方法都需要获得A锁和B锁。一个线程执行a方法且已经获得了A锁，在等待B锁；另一个线程执行了b方法且已经获得了B锁，在等待A锁。这种状态，就是发生了静态的锁顺序死锁。 //可能发生静态锁顺序死锁的代码 class StaticLockOrderDeadLock { private final Object lockA = new Object(); private final Object lockB = new Object(); public void a() { synchronized (lockA) { synchronized (lockB) { System.out.println(\"function a\"); } } } public void b() { synchronized (lockB) { synchronized (lockA) { System.out.println(\"function b\"); } } } } 解决静态的锁顺序死锁的方法就是：所有需要多个锁的线程，都要以相同的顺序来获得锁。 //正确的代码 class StaticLockOrderDeadLock { private final Object lockA = new Object(); private final Object lockB = new Object(); public void a() { synchronized (lockA) { synchronized (lockB) { System.out.println(\"function a\"); } } } public void b() { synchronized (lockA) { synchronized (lockB) { System.out.println(\"function b\"); } } } } 三、动态的锁顺序死锁： 动态的锁顺序死锁是指两个线程调用同一个方法时，传入的参数颠倒造成的死锁。如下代码，一个线程调用了transferMoney方法并传入参数accountA,accountB；另一个线程调用了transferMoney方法并传入参数accountB,accountA。此时就可能发生在静态的锁顺序死锁中存在的问题，即：第一个线程获得了accountA锁并等待accountB锁，第二个线程获得了accountB锁并等待accountA锁。 //可能发生动态锁顺序死锁的代码 class DynamicLockOrderDeadLock { public void transefMoney(Account fromAccount, Account toAccount, Double amount) { synchronized (fromAccount) { synchronized (toAccount) { //... fromAccount.minus(amount); toAccount.add(amount); //... } } } } 动态的锁顺序死锁解决方案如下：使用System.identifyHashCode来定义锁的顺序。确保所有的线程都以相同的顺序获得锁。 //正确的代码 class DynamicLockOrderDeadLock { private final Object myLock = new Object(); public void transefMoney(final Account fromAccount, final Account toAccount, final Double amount) { class Helper { public void transfer() { //... fromAccount.minus(amount); toAccount.add(amount); //... } } int fromHash = System.identityHashCode(fromAccount); int toHash = System.identityHashCode(toAccount); if (fromHash toHash) { synchronized (toAccount) { synchronized (fromAccount) { new Helper().transfer(); } } } else { synchronized (myLock) { synchronized (fromAccount) { synchronized (toAccount) { new Helper().transfer(); } } } } } } 四、协作对象之间发生的死锁： 有时，死锁并不会那么明显，比如两个相互协作的类之间的死锁，比如下面的代码：一个线程调用了Taxi对象的setLocation方法，另一个线程调用了Dispatcher对象的getImage方法。此时可能会发生，第一个线程持有Taxi对象锁并等待Dispatcher对象锁，另一个线程持有Dispatcher对象锁并等待Taxi对象锁。 //可能发生死锁 class Taxi { private Point location, destination; private final Dispatcher dispatcher; public Taxi(Dispatcher dispatcher) { this.dispatcher = dispatcher; } public synchronized Point getLocation() { return location; } public synchronized void setLocation(Point location) { this.location = location; if (location.equals(destination)) dispatcher.notifyAvailable(this);//外部调用方法，可能等待Dispatcher对象锁 } } class Dispatcher { private final Set taxis; private final Set availableTaxis; public Dispatcher() { taxis = new HashSet(); availableTaxis = new HashSet(); } public synchronized void notifyAvailable(Taxi taxi) { availableTaxis.add(taxi); } public synchronized Image getImage() { Image image = new Image(); for (Taxi t : taxis) image.drawMarker(t.getLocation());//外部调用方法，可能等待Taxi对象锁 return image; } } 上面的代码中， 我们在持有锁的情况下调用了外部的方法，这是非常危险的（可能发生死锁）。为了避免这种危险的情况发生， 我们使用开放调用。如果调用某个外部方法时不需要持有锁，我们称之为开放调用。 解决协作对象之间发生的死锁：需要使用开放调用，即避免在持有锁的情况下调用外部的方法。 //正确的代码 class Taxi { private Point location, destination; private final Dispatcher dispatcher; public Taxi(Dispatcher dispatcher) { this.dispatcher = dispatcher; } public synchronized Point getLocation() { return location; } public void setLocation(Point location) { boolean flag = false; synchronized (this) { this.location = location; flag = location.equals(destination); } if (flag) dispatcher.notifyAvailable(this);//使用开放调用 } } class Dispatcher { private final Set taxis; private final Set availableTaxis; public Dispatcher() { taxis = new HashSet(); availableTaxis = new HashSet(); } public synchronized void notifyAvailable(Taxi taxi) { availableTaxis.add(taxi); } public Image getImage() { Set copy; synchronized (this) { copy = new HashSet(taxis); } Image image = new Image(); for (Taxi t : copy) image.drawMarker(t.getLocation());//使用开放调用 return image; } } 五、总结 综上，是常见的3种死锁的类型。即：静态的锁顺序死锁，动态的锁顺序死锁，协作对象之间的死锁。在写代码时，要确保线程在获取多个锁时采用一致的顺序。同时，要避免在持有锁的情况下调用外部方法。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/concurrence/synchronized-reentrantlock.html":{"url":"java/concurrence/synchronized-reentrantlock.html","title":"Synchronized/ReentrantLock","keywords":"","body":"一、线程同步问题的产生及解决方案 问题的产生： Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突。 如下例：假设有一个卖票系统，一共有100张票，有4个窗口同时卖。 public class Ticket implements Runnable { // 当前拥有的票数 private int num = 100; public void run() { while (true) { if (num > 0) { try { Thread.sleep(10); } catch (InterruptedException e) { } // 输出卖票信息 System.out.println(Thread.currentThread().getName() + \".....sale....\" + num--); } } } } public class Nothing { public static void main(String[] args) { Ticket t = new Ticket();//创建一个线程任务对象。 //创建4个线程同时卖票 Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); //启动线程 t1.start(); t2.start(); t3.start(); t4.start(); } } 输出部分结果： Thread-1.....sale....2 Thread-0.....sale....3 Thread-2.....sale....1 Thread-0.....sale....0 Thread-1.....sale....0 Thread-3.....sale....1 显然上述结果是不合理的，对于同一张票进行了多次售出。这就是多线程情况下，出现了数据“脏读”情况。即多个线程访问余票num时，当一个线程获得余票的数量，要在此基础上进行-1的操作之前，其他线程可能已经卖出多张票，导致获得的num不是最新的，然后-1后更新的数据就会有误。这就需要线程同步的实现了。 问题的解决： 因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。 一共有两种锁，来实现线程同步问题，分别是：synchronized和ReentrantLock。下面我们就带着上述问题，看看这两种锁是如何解决的。 二、synchronized关键字 1.synchronized简介 synchronized实现同步的基础：Java中每个对象都可以作为锁。当线程试图访问同步代码时，必须先获得对象锁，退出或抛出异常时必须释放锁。 Synchronzied实现同步的表现形式分为：代码块同步 和 方法同步。 2.synchronized原理 JVM基于进入和退出Monitor对象来实现 代码块同步 和 方法同步 ，两者实现细节不同。 代码块同步： 在编译后通过将monitorenter指令插入到同步代码块的开始处，将monitorexit指令插入到方法结束处和异常处，通过反编译字节码可以观察到。任何一个对象都有一个monitor与之关联，线程执行monitorenter指令时，会尝试获取对象对应的monitor的所有权，即尝试获得对象的锁。 方法同步： synchronized方法在method_info结构有ACC_synchronized标记，线程执行时会识别该标记，获取对应的锁，实现方法同步。 两者虽然实现细节不同，但本质上都是对一个对象的监视器（monitor）的获取。任意一个对象都拥有自己的监视器，当同步代码块或同步方法时，执行方法的线程必须先获得该对象的监视器才能进入同步块或同步方法，没有获取到监视器的线程将会被阻塞，并进入同步队列，状态变为BLOCKED。当成功获取监视器的线程释放了锁后，会唤醒阻塞在同步队列的线程，使其重新尝试对监视器的获取。 对象、监视器、同步队列和执行线程间的关系如下图： 3.synchronized的使用场景 ①方法同步 public synchronized void method1 锁住的是该对象,类的其中一个实例，当该对象(仅仅是这一个对象)在不同线程中执行这个同步方法时，线程之间会形成互斥。达到同步效果，但如果不同线程同时对该类的不同对象执行这个同步方法时，则线程之间不会形成互斥，因为他们拥有的是不同的锁。 ②代码块同步 synchronized(this){ //TODO } 描述同① ③方法同步 public synchronized static void method3 锁住的是该类，当所有该类的对象(多个对象)在不同线程中调用这个static同步方法时，线程之间会形成互斥，达到同步效果。 ④代码块同步 synchronized(Test.class){ //TODO} 同③ ⑤代码块同步 synchronized(o) {} 这里面的o可以是一个任何Object对象或数组，并不一定是它本身对象或者类，谁拥有o这个锁，谁就能够操作该块程序代码。 4.解决线程同步的实例 针对上述方法，具体的解决方式如下： public class Ticket implements Runnable { // 当前拥有的票数 private int num = 100; public void run() { while (true) { try { Thread.sleep(10); } catch (InterruptedException e) { } synchronized (this) { // 输出卖票信息 if (num > 0) { System.out.println(Thread.currentThread().getName() + \".....sale....\" + num--); } } } } } 输出部分结果： Thread-2.....sale....10 Thread-1.....sale....9 Thread-3.....sale....8 Thread-0.....sale....7 Thread-2.....sale....6 Thread-1.....sale....5 Thread-2.....sale....4 Thread-1.....sale....3 Thread-3.....sale....2 Thread-0.....sale....1 可以看出实现了线程同步。同时改了一下逻辑，在进入到同步代码块时，先判断现在是否有没有票，然后再买票，防止出现没票还要售出的情况。通过同步代码块实现了线程同步，其他方法也一样可以实现该效果。 三、ReentrantLock锁 ReentrantLock，一个可重入的互斥锁，它具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。（重入锁后面介绍） 1.Lock接口 Lock，锁对象。在Java中锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但有的锁可以允许多个线程并发访问共享资源，比如读写锁，后面我们会分析）。在Lock接口出现之前，Java程序是靠synchronized关键字（后面分析）实现锁功能的，而JAVA SE5.0之后并发包中新增了Lock接口用来实现锁的功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁，缺点就是缺少像synchronized那样隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。 Lock接口的主要方法（还有两个方法比较复杂，暂不介绍）： void lock(): 执行此方法时，如果锁处于空闲状态，当前线程将获取到锁。相反，如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获取到锁。 boolean tryLock()： 如果锁可用，则获取锁，并立即返回true，否则返回false. 该方法和lock()的区别在于，tryLock()只是\"试图\"获取锁，如果锁不可用，不会导致当前线程被禁用，当前线程仍然继续往下执行代码。而lock()方法则是一定要获取到锁，如果锁不可用，就一直等待，在未获得锁之前,当前线程并不继续向下执行. 通常采用如下的代码形式调用tryLock()方法： void unlock()： 执行此方法时，当前线程将释放持有的锁. 锁只能由持有者释放，如果线程并不持有锁，却执行该方法，可能导致异常的发生. Condition newCondition()： 条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将缩放锁。 2.ReentrantLock的使用 关于ReentrantLock的使用很简单，只需要显示调用，获得同步锁，释放同步锁即可。 ReentrantLock lock = new ReentrantLock(); //参数默认false，不公平锁 ..................... lock.lock(); //如果被其它资源锁定，会在此等待锁释放，达到暂停的效果 try { //操作 } finally { lock.unlock(); //释放锁 } 3.解决线程同步的实例 针对上述方法，具体的解决方式如下： public class Ticket implements Runnable { // 当前拥有的票数 private int num = 100; ReentrantLock lock = new ReentrantLock(); public void run() { while (true) { try { Thread.sleep(10); } catch (InterruptedException e) { } lock.lock(); // 输出卖票信息 if (num > 0) { System.out.println(Thread.currentThread().getName() + \".....sale....\" + num--); } lock.unlock(); } } } 四、重入锁 当一个线程得到一个对象后，再次请求该对象锁时是可以再次得到该对象的锁的。 具体概念就是：自己可以再次获取自己的内部锁。 Java里面内置锁(synchronized)和Lock(ReentrantLock)都是可重入的。 public class SynchronizedTest { public void method1() { synchronized (SynchronizedTest.class) { System.out.println(\"方法1获得ReentrantTest的锁运行了\"); method2(); } } public void method2() { synchronized (SynchronizedTest.class) { System.out.println(\"方法1里面调用的方法2重入锁,也正常运行了\"); } } public static void main(String[] args) { new SynchronizedTest().method1(); } } 上面便是synchronized的重入锁特性，即调用method1()方法时，已经获得了锁，此时内部调用method2()方法时，由于本身已经具有该锁，所以可以再次获取。 public class ReentrantLockTest { private Lock lock = new ReentrantLock(); public void method1() { lock.lock(); try { System.out.println(\"方法1获得ReentrantLock锁运行了\"); method2(); } finally { lock.unlock(); } } public void method2() { lock.lock(); try { System.out.println(\"方法1里面调用的方法2重入ReentrantLock锁,也正常运行了\"); } finally { lock.unlock(); } } public static void main(String[] args) { new ReentrantLockTest().method1(); } } 上面便是ReentrantLock的重入锁特性，即调用method1()方法时，已经获得了锁，此时内部调用method2()方法时， 由于本身已经具有该锁，所以可以再次获取。 五、公平锁 CPU在调度线程的时候是在等待队列里随机挑选一个线程，由于这种随机性所以是无法保证线程先到先得的（synchronized控制的锁就是这种非公平锁）。但这样就会产生饥饿现象，即有些线程（优先级较低的线程）可能永远也无法获取CPU的执行权，优先级高的线程会不断的强制它的资源。那么如何解决饥饿问题呢，这就需要公平锁了。公平锁可以保证线程按照时间的先后顺序执行，避免饥饿现象的产生。但公平锁的效率比较低，因为要实现顺序执行，需要维护一个有序队列。 ReentrantLock便是一种公平锁，通过在构造方法中传入true就是公平锁，传入false，就是非公平锁。 public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } 以下是使用公平锁实现的效果： public class LockFairTest implements Runnable{ //创建公平锁 private static ReentrantLock lock=new ReentrantLock(true); public void run() { while(true){ lock.lock(); try{ System.out.println(Thread.currentThread().getName()+\"获得锁\"); }finally{ lock.unlock(); } } } public static void main(String[] args) { LockFairTest lft=new LockFairTest(); Thread th1=new Thread(lft); Thread th2=new Thread(lft); th1.start(); th2.start(); } } 输出结果： Thread-1获得锁 Thread-0获得锁 Thread-1获得锁 Thread-0获得锁 Thread-1获得锁 Thread-0获得锁 Thread-1获得锁 Thread-0获得锁 Thread-1获得锁 Thread-0获得锁 Thread-1获得锁 Thread-0获得锁 Thread-1获得锁 Thread-0获得锁 Thread-1获得锁 Thread-0获得锁 这是截取的部分执行结果，分析结果可看出两个线程是交替执行的，几乎不会出现同一个线程连续执行多次。 六、synchronized和ReentrantLock的比较 1.区别： 1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现； 2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； 3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 5）Lock可以提高多个线程进行读操作的效率。 总结：ReentrantLock相比synchronized，增加了一些高级的功能。但也有一定缺陷。 在ReentrantLock类中定义了很多方法，比如： isFair() //判断锁是否是公平锁 isLocked() //判断锁是否被任何线程获取了 isHeldByCurrentThread() //判断锁是否被当前线程获取了 hasQueuedThreads() //判断是否有线程在等待该锁 2.两者在锁的相关概念上区别： 1)可中断锁 顾名思义，就是可以响应中断的锁。 在Java中，synchronized就不是可中断锁，而Lock是可中断锁。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。 lockInterruptibly()的用法体现了Lock的可中断性。 2)公平锁 公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁（并不是绝对的，大体上是这种顺序），这种就是公平锁。 非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。 在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。ReentrantLock可以设置成公平锁。 3)读写锁 读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。 正因为有了读写锁，才使得多个线程之间的读操作可以并发进行，不需要同步，而写操作需要同步进行，提高了效率。 ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。 可以通过readLock()获取读锁，通过writeLock()获取写锁。 4)绑定多个条件 一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多余一个条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这么做，只需要多次调用new Condition()方法即可。 3.性能比较 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而 当竞争资源非常激烈时（即有大量线程同时竞争），此时ReentrantLock的性能要远远优于synchronized 。所以说，在具体使用时要根据适当情况选择。 在JDK1.5中，synchronized是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的ReentrankLock对象，性能更高一些。到了JDK1.6，发生了变化，对synchronize加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在JDK1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/concurrence/producer-consumer.html":{"url":"java/concurrence/producer-consumer.html","title":"生产者/消费者模式","keywords":"","body":"一、线程间通信的两种方式 1.wait()/notify() Object类中相关的方法有notify方法和wait方法。因为wait和notify方法定义在Object类中，因此会被所有的类所继承。这些方法都是final的，即它们都是不能被重写的，不能通过子类覆写去改变它们的行为。 ①wait()方法： 让当前线程进入等待，并释放锁。 ②wait(long)方法： 让当前线程进入等待，并释放锁，不过等待时间为long，超过这个时间没有对当前线程进行唤醒，将自动唤醒。 ③notify()方法： 让当前线程通知那些处于等待状态的线程，当前线程执行完毕后释放锁，并从其他线程中唤醒其中一个继续执行。 ④notifyAll()方法： 让当前线程通知那些处于等待状态的线程，当前线程执行完毕后释放锁，将唤醒所有等待状态的线程。 wait()方法使用注意事项 ①当前的线程必须拥有当前对象的monitor，也即lock，就是锁，才能调用wait()方法，否则将抛出异常java.lang.IllegalMonitorStateException。 ②线程调用wait()方法，释放它对锁的拥有权，然后等待另外的线程来通知它（通知的方式是notify()或者notifyAll()方法），这样它才能重新获得锁的拥有权和恢复执行。 ③要确保调用wait()方法的时候拥有锁，即，wait()方法的调用必须放在synchronized方法或synchronized块中。 wait()与sleep()比较 当线程调用了wait()方法时，它会释放掉对象的锁。 Thread.sleep()，它会导致线程睡眠指定的毫秒数，但线程在睡眠的过程中是不会释放掉对象的锁的。 notify()方法使用注意事项 ①如果多个线程在等待，它们中的一个将会选择被唤醒。这种选择是随意的，和具体实现有关。（线程等待一个对象的锁是由于调用了wait()方法）。 ②被唤醒的线程是不能被执行的，需要等到当前线程放弃这个对象的锁，当前线程会在方法执行完毕后释放锁。 wait()/notify()协作的两个注意事项 ①通知过早 如果通知过早，则会打乱程序的运行逻辑。 public class MyRun { private String lock = new String(\"\"); public Runnable runnableA = new Runnable() { @Override public void run() { try { synchronized (lock) { System.out.println(\"begin wait\"); lock.wait(); System.out.println(\"end wait\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }; public Runnable runnableB = new Runnable() { @Override public void run() { synchronized (lock) { System.out.println(\"begin notify\"); lock.notify(); System.out.println(\"end notify\"); } } }; } 两个方法，分别执行wait()/notify()方法。 public static void main(String[] args) throws InterruptedException { MyRun run = new MyRun(); Thread bThread = new Thread(run.runnableB); bThread.start(); Thread.sleep(100); Thread aThread = new Thread(run.runnableA); aThread.start(); } 如果notify()方法先执行，将导致wait()方法释放锁进入等待状态后，永远无法被唤醒，影响程序逻辑。应避免这种情况。 ②等待wait的条件发生变化 在使用wait/notify模式时，还需要注意另外一种情况，也就是wait等待条件发生了变化，也容易造成程序逻辑的混乱。 Add类，执行加法操作，然后通知Subtract类 public class Add { private String lock; public Add(String lock) { super(); this.lock = lock; } public void add(){ synchronized (lock) { ValueObject.list.add(\"anyThing\"); lock.notifyAll(); } } } Subtract类，执行减法操作，执行完后进入等待状态，等待Add类唤醒notify public class Subtract { private String lock; public Subtract(String lock) { super(); this.lock = lock; } public void subtract(){ try { synchronized (lock) { if(ValueObject.list.size()==0){ System.out.println(\"wait begin ThreadName=\"+Thread.currentThread().getName()); lock.wait(); System.out.println(\"wait end ThreadName=\"+Thread.currentThread().getName()); } ValueObject.list.remove(0); System.out.println(\"list size =\"+ValueObject.list.size()); } } catch (InterruptedException e) { e.printStackTrace(); } } } 线程ThreadAdd public class ThreadAdd extends Thread{ private Add pAdd; public ThreadAdd(Add pAdd) { super(); this.pAdd = pAdd; } @Override public void run() { pAdd.add(); } } 线程ThreadSubtract public class ThreadSubtract extends Thread{ private Subtract rSubtract; public ThreadSubtract(Subtract rSubtract) { super(); this.rSubtract = rSubtract; } @Override public void run() { rSubtract.subtract(); } } 先开启两个ThreadSubtract线程，由于list中没有元素，进入等待状态。再开启一个ThreadAdd线程，向list中增加一个元素，然后唤醒两个ThreadSubtract线程。 public static void main(String[] args) throws InterruptedException { String lock = new String(\"\"); Add add = new Add(lock); Subtract subtract = new Subtract(lock); ThreadSubtract subtractThread1 = new ThreadSubtract(subtract); subtractThread1.setName(\"subtractThread1\"); subtractThread1.start(); ThreadSubtract subtractThread2 = new ThreadSubtract(subtract); subtractThread2.setName(\"subtractThread2\"); subtractThread2.start(); Thread.sleep(1000); ThreadAdd addThread = new ThreadAdd(add); addThread.setName(\"addThread\"); addThread.start(); } 输出结果 wait begin ThreadName=subtractThread1wait begin ThreadName=subtractThread2wait end ThreadName=subtractThread2Exception in thread \"subtractThread1\" list size =0wait end ThreadName=subtractThread1java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 at java.util.ArrayList.rangeCheck(Unknown Source) at java.util.ArrayList.remove(Unknown Source) at com.lvr.communication.Subtract.subtract(Subtract.java:18) at com.lvr.communication.ThreadSubtract.run(ThreadSubtract.java:12) 当第二个ThreadSubtract线程执行减法操作时，抛出下标越界异常。 原因分析：一开始两个ThreadSubtract线程等待状态，当ThreadAdd线程添加一个元素并唤醒所有线程后，第一个ThreadSubtract线程接着原来的执行到的地点开始继续执行，删除一个元素并输出集合大小。同样，第二个ThreadSubtract线程也如此，可是此时集合中已经没有元素了，所以抛出异常。 解决办法：从等待状态被唤醒后，重新判断条件，看看是否扔需要进入等待状态，不需要进入再进行下一步操作。即把if()判断，改成while()。 public void subtract(){ try { synchronized (lock) { while(ValueObject.list.size()==0){ System.out.println(\"wait begin ThreadName=\"+Thread.currentThread().getName()); lock.wait(); System.out.println(\"wait end ThreadName=\"+Thread.currentThread().getName()); } ValueObject.list.remove(0); System.out.println(\"list size =\"+ValueObject.list.size()); } } catch (InterruptedException e) { e.printStackTrace(); } } 这是线程间协作中经常出现的一种情况，需要避免。 2.Condition实现等待/通知 关键字synchronized与wait()和notify()/notifyAll()方法相结合可以实现等待/通知模式，类似ReentrantLock也可以实现同样的功能，但需要借助于Condition对象。 关于Condition实现等待/通知就不详细介绍了，可以完全类比wait()/notify()，基本使用和注意事项完全一致。就只简单介绍下类比情况： condition.await()————>lock.wait() condition.await(long time, TimeUnit unit)————>lock.wait(long timeout) condition.signal()————>lock.notify() condition.signaAll()————>lock.notifyAll() 特殊之处：synchronized相当于整个ReentrantLock对象只有一个单一的Condition对象情况。而一个ReentrantLock却可以拥有多个Condition对象，来实现通知部分线程。 具体实现方式：假设有两个Condition对象：ConditionA和ConditionB。那么由ConditionA.await()方法进入等待状态的线程，由ConditionA.signalAll()通知唤醒；由ConditionB.await()方法进入等待状态的线程，由ConditionB.signalAll()通知唤醒。篇幅有限，代码示例就不写了。 二、生产者/消费者模式实现 1.一生产与一消费 下面情形是一个生产者，一个消费者的模式。假设场景：一个String对象，其中生产者为其设置值，消费者拿走其中的值，不断的循环往复，实现生产者/消费者的情形。 wait()/notify()实现 生产者 public class Product { private String lock; public Product(String lock) { super(); this.lock = lock; } public void setValue(){ try { synchronized (lock) { if(!StringObject.value.equals(\"\")){ //有值，不生产 lock.wait(); } String value = System.currentTimeMillis()+\"\"+System.nanoTime(); System.out.println(\"set的值是：\"+value); StringObject.value = value; lock.notify(); } } catch (InterruptedException e) { e.printStackTrace(); } } } 消费者 public class Consumer { private String lock; public Consumer(String lock) { super(); this.lock = lock; } public void getValue(){ try { synchronized (lock) { if(StringObject.value.equals(\"\")){ //没值，不进行消费 lock.wait(); } System.out.println(\"get的值是：\"+StringObject.value); StringObject.value = \"\"; lock.notify(); } } catch (InterruptedException e) { e.printStackTrace(); } } } 生产者线程 public class ThreadProduct extends Thread{ private Product product; public ThreadProduct(Product product) { super(); this.product = product; } @Override public void run() { //死循环，不断的生产 while(true){ product.setValue(); } } } 消费者线程 public class ThreadConsumer extends Thread{ private Consumer consumer; public ThreadConsumer(Consumer consumer) { super(); this.consumer = consumer; } @Override public void run() { //死循环，不断的消费 while(true){ consumer.getValue(); } } } 开启生产者/消费者模式 public class Test { public static void main(String[] args) throws InterruptedException { String lock = new String(\"\"); Product product = new Product(lock); Consumer consumer = new Consumer(lock); ThreadProduct pThread = new ThreadProduct(product); ThreadConsumer cThread = new ThreadConsumer(consumer); pThread.start(); cThread.start(); } } 输出结果： set的值是：148827033184127168687409691get的值是：148827033184127168687409691set的值是：148827033184127168687449887get的值是：148827033184127168687449887set的值是：148827033184127168687475117get的值是：148827033184127168687475117 Condition方式实现类似，篇幅有限不全部贴出来。 2.多生产与多消费 特殊情况： 按照上述一生产与一消费的情况，通过创建多个生产者和消费者线程，实现多生产与多消费的情况，将会出现“假死”。 具体原因： 多个生产者和消费者线程。当全部运行后，生产者线程生产数据后，可能唤醒的同类即生产者线程。此时可能会出现如下情况：所有生产者线程进入等待状态，然后消费者线程消费完数据后，再次唤醒的还是消费者线程，直至所有消费者线程都进入等待状态，此时将进入“假死”。 解决方法： 将notify()或signal()方法改为notifyAll()或signalAll()方法，这样就不怕因为唤醒同类而进入“假死”状态了。 Condition方式实现 生产者 public class Product { private ReentrantLock lock; private Condition condition; public Product(ReentrantLock lock, Condition condition) { super(); this.lock = lock; this.condition = condition; } public void setValue() { try { lock.lock(); while (!StringObject.value.equals(\"\")) { // 有值，不生产 condition.await(); } String value = System.currentTimeMillis() + \"\" + System.nanoTime(); System.out.println(\"set的值是：\" + value); StringObject.value = value; condition.signalAll(); } catch (InterruptedException e) { e.printStackTrace(); }finally { lock.unlock(); } } } 消费者 public class Consumer { private ReentrantLock lock; private Condition condition; public Consumer(ReentrantLock lock,Condition condition) { super(); this.lock = lock; this.condition = condition; } public void getValue(){ try { lock.lock(); while(StringObject.value.equals(\"\")){ //没值，不进行消费 condition.await(); } System.out.println(\"get的值是：\"+StringObject.value); StringObject.value = \"\"; condition.signalAll(); } catch (InterruptedException e) { e.printStackTrace(); }finally { lock.unlock(); } } } 生产者线程和消费者线程与一生产一消费的模式相同。 开启多生产/多消费模式 public static void main(String[] args) throws InterruptedException { ReentrantLock lock = new ReentrantLock(); Condition newCondition = lock.newCondition(); Product product = new Product(lock,newCondition); Consumer consumer = new Consumer(lock,newCondition); for(int i=0;i 输出结果: set的值是：148827212374628960540784817get的值是：148827212374628960540784817set的值是：148827212374628960540810047get的值是：148827212374628960540810047 可见交替地进行get/set实现多生产/多消费模式。 注意：相比一生产一消费的模式，改动了两处。①signal()-->signalAll()避免进入“假死”状态。②if()判断-->while()循环，重新判断条件，避免逻辑混乱。 以上就是Java线程间通信的相关知识，以生产者/消费者模式为例，讲解线程间通信的使用以及注意事项。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/concurrence/volatile.html":{"url":"java/concurrence/volatile.html","title":"volatile关键字","keywords":"","body":"一、Java内存模型 想要理解volatile为什么能确保可见性，就要先理解Java中的内存模型是什么样的。 Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 基于此种内存模型，便产生了多线程编程中的数据“脏读”等问题。 举个简单的例子：在java中，执行下面这个语句： i = 10; 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。 比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？ 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。 最终结果i的值是11，而不是12。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。 那么如何确保共享变量在多线程访问时能够正确输出结果呢？ 在解决这个问题之前，我们要先了解并发编程的三大概念：原子性，有序性，可见性。 二、原子性 1.定义 原子性：即一个操作或者多个操作，要么全部执行，并且执行的过程不会被任何因素打断，要么就都不执行。 2.实例 一个很经典的例子就是银行账户转账问题： 比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。 同样地反映到并发编程中会出现什么结果呢？ 举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？ i = 9; 假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。 那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。 3.Java中的原子性 在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i： 请分析以下哪些操作是原子性操作： x = 10; //语句1 y = x; //语句2 x++; //语句3 x = x + 1; //语句4 咋一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及将x的值写入工作内存，这2个操作都是原子性操作，但是合起来就不是原子性操作了。 同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。 所以上面4个语句只有语句1的操作具备原子性。 也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 三、可见性 1.定义 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 2.实例 举个简单的例子，看下面这段代码： //线程1执行的代码 int i = 0; i = 10; //线程2执行的代码 j = i; 由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。 此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 3.Java中的可见性 对于可见性，Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 四、有序性 1.定义 有序性：即程序执行的顺序按照代码的先后顺序执行。 2.实例 举个简单的例子，看下面这段代码： int i = 0; boolean flag = false; i = 1; //语句1 flag = true; //语句2 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子： int a = 10; //语句1 int r = 2; //语句2 a = a + 3; //语句3 r = a*a; //语句4 这段代码有4个语句，那么可能的一个执行顺序是： 　　 　　 那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子： //线程1: context = loadContext(); //语句1 inited = true; //语句2 //线程2: while(!inited ){ sleep() } doSomethingwithconfig(context); 上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。 3.Java中的有序性 在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 下面就来具体介绍下happens-before原则（先行发生原则）： ①程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 ②锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作 ③volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 ④传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C ⑤线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作 ⑥线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 ⑦线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 ⑧对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始 这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。 下面我们来解释一下前4条规则： 对于程序次序规则来说，就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，但是虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。 第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。 第三条规则是一条比较重要的规则。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。 第四条规则实际上就是体现happens-before原则具备传递性。 五、深入理解volatile关键字 1.volatile保证可见性 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 2）禁止进行指令重排序。 先看一段代码，假如线程1先执行，线程2后执行： //线程1 boolean stop = false; while(!stop){ doSomething(); } //线程2 stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 但是用volatile修饰之后就变得不一样了： 第一：使用volatile关键字会强制将修改的值立即写入主存； 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）； 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 那么线程1读取到的就是最新的正确的值。 2.volatile不能确保原子性 下面看一个例子： public class Nothing { private volatile int inc = 0; private volatile static int count = 10; private void increase() { ++inc; } public static void main(String[] args) { int loop = 10; Nothing nothing = new Nothing(); while (loop-- > 0) { nothing.operation(); } } private void operation() { final Nothing test = new Nothing(); for (int i = 0; i { for (int j = 0; j 0) { } System.out.println(\"最后的数据为：\" + test.inc); } } 运行结果为： 最后的数据为：5919956 最后的数据为：3637231 最后的数据为：2144549 最后的数据为：2403538 最后的数据为：1762639 最后的数据为：2878721 最后的数据为：2658645 最后的数据为：2534078 最后的数据为：2031751 最后的数据为：2924506 大家想一下这段程序的输出结果是多少？也许有些朋友认为是1000000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于1000000的数字。 可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000000次操作，那么最终inc的值应该是1000000*10=10000000。 这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。 可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现： 假如某个时刻变量inc的值为10，线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，也不会导致主存中的值刷新， 所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加了1。 根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。 解决方案：可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过AtomicInteger。 在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。 3.volatile保证有序性 在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 volatile关键字禁止指令重排序有两层意思： 1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 2）在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 可能上面说的比较绕，举个简单的例子： // x、y为非volatile变量 // flag为volatile变量 x = 2; //语句1 y = 0; //语句2 flag = true; //语句3 x = 4; //语句4 y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 那么我们回到前面举的一个例子： //线程1: context = loadContext(); //语句1 inited = true; //语句2 //线程2: while(!inited ){ sleep() } doSomethingwithconfig(context); 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。 六、volatile的实现原理 1.可见性 处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。 如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。 但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期， 当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。 2.有序性 Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。 七、volatile的应用场景 synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件： 1）对变量的写操作不依赖于当前值 2）该变量没有包含在具有其他变量的不变式中 下面列举几个Java中使用volatile的几个场景。 ①.状态标记量 volatile boolean flag = false; //线程1 while(!flag){ doSomething(); } //线程2 public void setFlag() { flag = true; } 根据状态标记，终止线程。 ②.单例模式中的double check class Singleton { private volatile static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) instance = new Singleton(); } } return instance; } } 为什么要使用volatile 修饰instance？ 主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情: 1.给 instance 分配内存 2.调用 Singleton 的构造函数来初始化成员变量 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:02 "},"java/concurrence/CAS.html":{"url":"java/concurrence/CAS.html","title":"CAS原子操作","keywords":"","body":"乐观锁与悲观锁 我们都知道，cpu是时分复用的，也就是把cpu的时间片，分配给不同的thread/process轮流执行，时间片与时间片之间，需要进行cpu切换，也就是会发生进程的切换。切换涉及到清空寄存器，缓存数据。然后重新加载新的thread所需数据。当一个线程被挂起时，加入到阻塞队列，在一定的时间或条件下，在通过notify()，notifyAll()唤醒回来。 在某个资源不可用的时候，就将cpu让出，把当前等待线程切换为阻塞状态。等到资源(比如一个共享数据）可用了，那么就将线程唤醒，让他进入runnable状态等待cpu调度。这就是典型的悲观锁的实现。 独占锁是一种悲观锁，synchronized就是一种独占锁，它假设最坏的情况，认为一个线程修改共享数据的时候其他线程也会修改该数据，因此只在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。 但是，由于在进程挂起和恢复执行过程中存在着很大的开销。当一个线程正在等待锁时，它不能做任何事，所以悲观锁有很大的缺点。举个例子，如果一个线程需要某个资源，但是这个资源的占用时间很短，当线程第一次抢占这个资源时，可能这个资源被占用，如果此时挂起这个线程，可能立刻就发现资源可用，然后又需要花费很长的时间重新抢占锁，时间代价就会非常的高。 所以就有了乐观锁的概念，他的核心思路就是，每次不加锁而是假设修改数据之前其他线程一定不会修改，如果因为修改过产生冲突就失败就重试，直到成功为止。 在上面的例子中，某个线程可以不让出cpu，而是一直while循环，如果失败就重试，直到成功为止。所以，当数据争用不严重时，乐观锁效果更好。比如CAS就是一种乐观锁思想的应用。 CAS CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。 举个CAS操作的应用场景的一个例子，当一个线程需要修改共享变量的值。完成这个操作，先取出共享变量的值赋给A，然后基于A的基础进行计算，得到新值B，完了需要更新共享变量的值了，这个时候就可以调用CAS方法更新变量值了。 在java中可以通过锁和循环CAS的方式来实现原子操作。Java中java.util.concurrent.atomic包相关类就是 CAS的实现，atomic包里包括以下类： 类名 说明 AtomicBoolean 可以用原子方式更新的 boolean 值。 AtomicInteger 可以用原子方式更新的 int 值。 AtomicIntegerArray 可以用原子方式更新其元素的 int 数组。 AtomicIntegerFieldUpdater 基于反射的实用工具，可以对指定类的指定 volatile int 字段进行原子更新。 AtomicLong 可以用原子方式更新的 long 值。 AtomicLongArray 可以用原子方式更新其元素的 long 数组。 AtomicLongFieldUpdater 基于反射的实用工具，可以对指定类的指定 volatile long 字段进行原子更新。 AtomicMarkableReference AtomicMarkableReference 维护带有标记位的对象引用，可以原子方式对其进行更新。 AtomicReference 可以用原子方式更新的对象引用。 AtomicReferenceArray 可以用原子方式更新其元素的对象引用数组。 AtomicReferenceFieldUpdater 基于反射的实用工具，可以对指定类的指定 volatile 字段进行原子更新。 AtomicStampedReference AtomicStampedReference 维护带有整数“标志”的对象引用，可以用原子方式对其进行更新。 下面我们来已AtomicIneger的源码为例来看看CAS操作： public final int getAndAdd(int delta) { for (; ; ) { int current = get(); int next = current + delta; if (compareAndSet(current, next)) return current; } } 这里很显然使用CAS操作（for(;;)里面），他每次都从内存中读取数据，+1操作，然后两个值进行CAS操作。如果成功则返回，否则失败重试，直到修改成功为止。上面源码最关键的地方有两个，一个for循环，它代表着一种宁死不屈的精神，不成功誓不罢休。还有就是compareAndSet： public final boolean compareAndSet(int expect, int update) { return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } compareAndSet方法内部是调用Java本地方法compareAndSwapInt来实现的，而compareAndSwapInt方法内部又是借助C来调用CPU的底层指令来保证在硬件层面上实现原子操作的。在intel处理器中，CAS是通过调用cmpxchg指令完成的。这就是我们常说的CAS操作（compare and swap）。 CAS的问题 CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。 ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/concurrence/AbstractQueuedSynchronizer.html":{"url":"java/concurrence/AbstractQueuedSynchronizer.html","title":"AbstractQueuedSynchronizer详解","keywords":"","body":"一、AQS简介 1.1 AQS介绍 AbstractQueuedSynchronizer提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。该同步器（以下简称同步器）利用了一个int来表示状态，期望它能够成为实现大部分同步需求的基础。使用的方法是继承，子类通过继承同步器并需要实现它的方法来管理其状态，管理的方式就是通过类似acquire和release的方式来操纵状态。然而多线程环境中对状态的操纵必须确保原子性，因此子类对于状态的把握，需要使用这个同步器提供的以下三个方法对状态进行操作： java.util.concurrent.locks.AbstractQueuedSynchronizer.getState() java.util.concurrent.locks.AbstractQueuedSynchronizer.setState(int) java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState(int, int) 子类推荐被定义为自定义同步装置的内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干acquire之类的方法来供使用。该同步器即可以作为排他模式也可以作为共享模式，当它被定义为一个排他模式时，其他线程对其的获取就被阻止，而共享模式对于多个线程获取都可以成功。 1.2 AQS用处 1.3 同步器与锁 同步器是实现锁的关键，利用同步器将锁的语义实现，然后在锁的实现中聚合同步器。 可以这样理解：锁的API是面向使用者的，它定义了与锁交互的公共行为，而每个锁需要完成特定的操作也是透过这些行为来完成的（比如：可以允许两个线程进行加锁，排除两个以上的线程），但是实现是依托给同步器来完成；同步器面向的是线程访问和资源控制，它定义了线程对资源是否能够获取以及线程的排队等操作。锁和同步器很好的隔离了二者所需要关注的领域，严格意义上讲，同步器可以适用于除了锁以外的其他同步设施上（包括锁）。 同步器的开始提到了其实现依赖于一个FIFO队列，那么队列中的元素Node就是保存着线程引用和线程状态的容器，每个线程对同步器的访问，都可以看做是队列中的一个节点。Node的主要包含以下成员变量： Node { int waitStatus; Node prev; Node next; Node nextWaiter; Thread thread; } 以上五个成员变量主要负责保存该节点的线程引用，同步等待队列（以下简称sync队列）的前驱和后继节点，同时也包括了同步状态。 属性名称 描述 int waitStatus 表示节点的状态。其中包含的状态有： CANCELLED，值为1，表示当前的线程被取消；SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行；值为0，表示当前节点在sync队列中，等待着获取锁。 Node prev 前驱节点，比如当前节点被取消，那就需要前驱节点和后继节点来完成连接。 Node next 后继节点。 Node nextWaiter 存储condition队列中的后继节点。 Thread thread 入队列时的当前线程。 节点成为sync队列和condition队列构建的基础，在同步器中就包含了sync队列。同步器拥有三个成员变量：sync队列的头结点head、sync队列的尾节点tail和状态state。对于锁的获取，请求形成节点，将其挂载在尾部，而锁资源的转移（释放再获取）是从头部开始向后进行。对于同步器维护的状态state，多个线程对其的获取将会产生一个链式的结构。 1.4 API说明 实现自定义同步器时，需要使用同步器提供的getState()、setState()和compareAndSetState()方法来操纵状态的变迁。 方法名称 描述 protected boolean tryAcquire(int arg) 排它的获取这个状态。这个方法的实现需要查询当前状态是否允许获取，然后再进行获取（使用compareAndSetState来做）状态。 protected boolean tryRelease(int arg) 释放状态。 protected int tryAcquireShared(int arg) 共享的模式下获取状态。 protected boolean tryReleaseShared(int arg) 共享的模式下释放状态。 protected boolean isHeldExclusively() 在排它模式下，状态是否被占用。 实现这些方法必须是非阻塞而且是线程安全的，推荐使用该同步器的父类java.util.concurrent.locks.AbstractOwnableSynchronizer来设置当前的线程。 开始提到同步器内部基于一个FIFO队列，对于一个独占锁的获取和释放有以下伪码可以表示。 获取一个排他锁。 while(获取锁) { if (获取到) { 退出while循环 } else { if(当前线程没有入队列) { 那么入队列 } 阻塞当前线程 } } 释放一个排他锁。 if (释放成功) { 删除头结点 激活原头结点的后继节点 } 1.5 Mutex 示例 下面通过一个排它锁的例子来深入理解一下同步器的工作原理，而只有掌握同步器的工作原理才能够更加深入了解其他的并发组件。 排他锁的实现，一次只能一个线程获取到锁。 class Mutex implements Lock, java.io.Serializable { // 内部类，自定义同步器 private static class Sync extends AbstractQueuedSynchronizer { // 是否处于占用状态 protected boolean isHeldExclusively() { return getState() == 1; } // 当状态为0的时候获取锁 public boolean tryAcquire(int acquires) { assert acquires == 1; // Otherwise unused if (compareAndSetState(0, 1)) { setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } // 释放锁，将状态设置为0 protected boolean tryRelease(int releases) { assert releases == 1; // Otherwise unused if (getState() == 0) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; } // 返回一个Condition，每个condition都包含了一个condition队列 Condition newCondition() { return new ConditionObject(); } } // 仅需要将操作代理到Sync上即可 private final Sync sync = new Sync(); public void lock() { sync.acquire(1); } public boolean tryLock() { return sync.tryAcquire(1); } public void unlock() { sync.release(1); } public Condition newCondition() { return sync.newCondition(); } public boolean isLocked() { return sync.isHeldExclusively(); } public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); } public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); } public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1, unit.toNanos(timeout)); } } 可以看到Mutex将Lock接口均代理给了同步器的实现。 使用方将Mutex构造出来之后，调用lock获取锁，调用unlock进行解锁。下面以Mutex为例子，详细分析以下同步器的实现逻辑。 二、独占模式 2.1 acquire 实现分析 public final void acquire(int arg) 该方法以排他的方式获取锁，对中断不敏感，完成synchronized语义。 public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 上述逻辑主要包括： 尝试获取（调用tryAcquire更改状态，需要保证原子性）； 在tryAcquire方法中使用了同步器提供的对state操作的方法，利用compareAndSet保证只有一个线程能够对状态进行成功修改，而没有成功修改的线程将进入sync队列排队。 如果获取不到，将当前线程构造成节点Node并加入sync队列； 进入队列的每个线程都是一个节点Node，从而形成了一个双向队列，类似CLH队列，这样做的目的是线程间的通信会被限制在较小规模（也就是两个节点左右）。 再次尝试获取，如果没有获取到那么将当前线程从线程调度器上摘下，进入等待状态。 使用LockSupport将当前线程unpark，关于LockSupport后续会详细介绍。 private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // 快速尝试在尾部添加 Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } 上述逻辑主要包括： 使用当前线程构造Node； 对于一个节点需要做的是将当节点前驱节点指向尾节点（current.prev = tail），尾节点指向它（tail = current），原有的尾节点的后继节点指向它（t.next = current）而这些操作要求是原子的。上面的操作是利用尾节点的设置来保证的，也就是compareAndSetTail来完成的。 先行尝试在队尾添加； ​ 如果尾节点已经有了，然后做如下操作： 分配引用T指向尾节点； 将节点的前驱节点更新为尾节点（current.prev = tail）； 如果尾节点是T，那么将当尾节点设置为该节点（tail = current，原子更新）； T的后继节点指向当前节点（T.next = current）。 注意第3点是要求原子的。 这样可以以最短路径O(1)的效果来完成线程入队，是最大化减少开销的一种方式。 如果队尾添加失败或者是第一个入队的节点。 ​ 如果是第1个节点，也就是sync队列没有初始化，那么会进入到enq这个方法，进入的线程可能有多个，或者说在addWaiter中没有成功入队的线程都将进入enq这个方法。 ​ 可以看到enq的逻辑是确保进入的Node都会有机会顺序的添加到sync队列中，而加入的步骤如下： 如果尾节点为空，那么原子化的分配一个头节点，并将尾节点指向头节点，这一步是初始化； 然后是重复在addWaiter中做的工作，但是在一个for(;;)的循环中，直到当前节点入队为止。 进入sync队列之后，接下来就是要进行锁的获取，或者说是访问控制了，只有一个线程能够在同一时刻继续的运行，而其他的进入等待状态。而每个线程都是一个独立的个体，它们自省的观察，当条件满足的时候（自己的前驱是头结点并且原子性的获取了状态），那么这个线程能够继续运行。 final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head &&tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 上述逻辑主要包括： 获取当前节点的前驱节点； 需要获取当前节点的前驱节点，而头结点所对应的含义是当前占有锁且正在运行。 当前驱节点是头结点并且能够获取状态，代表该当前节点占有锁； 如果满足上述条件，那么代表能够占有锁，根据节点对锁占有的含义，设置头结点为当前节点。 否则进入等待状态。 如果没有轮到当前节点运行，那么将当前线程从线程调度器上摘下，也就是进入等待状态。 这里针对acquire做一下总结： 状态的维护； 需要在锁定时，需要维护一个状态(int类型)，而对状态的操作是原子和非阻塞的，通过同步器提供的对状态访问的方法对状态进行操纵，并且利用compareAndSet来确保原子性的修改。 状态的获取； 一旦成功的修改了状态，当前线程或者说节点，就被设置为头节点。 sync队列的维护。 在获取资源未果的过程中条件不符合的情况下(不该自己，前驱节点不是头节点或者没有获取到资源)进入睡眠状态，停止线程调度器对当前节点线程的调度。 这时引入的一个释放的问题，也就是说使睡眠中的Node或者说线程获得通知的关键，就是前驱节点的通知，而这一个过程就是释放，释放会通知它的后继节点从睡眠中返回准备运行。 下面的流程图基本描述了一次acquire所需要经历的过程： 如上图所示，其中的判定退出队列的条件，判定条件是否满足和休眠当前线程就是完成了自旋spin的过程。 2.2 release public final boolean release(int arg) 在unlock方法的实现中，使用了同步器的release方法。相对于在之前的acquire方法中可以得出调用acquire，保证能够获取到锁（成功获取状态），而release则表示将状态设置回去，也就是将资源释放，或者说将锁释放。 public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } 上述逻辑主要包括： 尝试释放状态； tryRelease能够保证原子化的将状态设置回去，当然需要使用compareAndSet来保证。如果释放状态成功过之后，将会进入后继节点的唤醒过程。 唤醒当前节点的后继节点所包含的线程。 通过LockSupport的unpark方法将休眠中的线程唤醒，让其继续acquire状态。 private void unparkSuccessor(Node node) { // 将状态设置为同步状态 int ws = node.waitStatus; if (ws 0) { s = null; for (Node t = tail; t != null && t != node; t = t.prev) if (t.waitStatus 上述逻辑主要包括，该方法取出了当前节点的next引用，然后对其线程(Node)进行了唤醒，这时就只有一个或合理个数的线程被唤醒，被唤醒的线程继续进行对资源的获取与争夺。 回顾整个资源的获取和释放过程： 在获取时，维护了一个sync队列，每个节点都是一个线程在进行自旋，而依据就是自己是否是首节点的后继并且能够获取资源； 在释放时，仅仅需要将资源还回去，然后通知一下后继节点并将其唤醒。 这里需要注意，队列的维护（首节点的更换）是依靠消费者（获取时）来完成的，也就是说在满足了自旋退出的条件时的一刻，这个节点就会被设置成为首节点。 2.3 tryAcquire protected boolean tryAcquire(int arg) tryAcquire是自定义同步器需要实现的方法，也就是自定义同步器非阻塞原子化的获取状态，如果锁该方法一般用于Lock的tryLock实现中，这个特性是synchronized无法提供的。 public final void acquireInterruptibly(int arg) 该方法提供获取状态能力，当然在无法获取状态的情况下会进入sync队列进行排队，这类似acquire，但是和acquire不同的地方在于它能够在外界对当前线程进行中断的时候提前结束获取状态的操作，换句话说，就是在类似synchronized获取锁时，外界能够对当前线程进行中断，并且获取锁的这个操作能够响应中断并提前返回。一个线程处于synchronized块中或者进行同步I/O操作时，对该线程进行中断操作，这时该线程的中断标识位被设置为true，但是线程依旧继续运行。 如果在获取一个通过网络交互实现的锁时，这个锁资源突然进行了销毁，那么使用acquireInterruptibly的获取方式就能够让该时刻尝试获取锁的线程提前返回。而同步器的这个特性被实现Lock接口中的lockInterruptibly方法。根据Lock的语义，在被中断时，lockInterruptibly将会抛出InterruptedException来告知使用者。 public final void acquireInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg); } private void doAcquireInterruptibly(int arg) throws InterruptedException { final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try { for (;;) { final Node p = node.predecessor(); if (p == head && tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return; } // 检测中断标志位 if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } } 上述逻辑主要包括： 检测当前线程是否被中断； 判断当前线程的中断标志位，如果已经被中断了，那么直接抛出异常并将中断标志位设置为false。 尝试获取状态； 调用tryAcquire获取状态，如果顺利会获取成功并返回。 构造节点并加入sync队列； 获取状态失败后，将当前线程引用构造为节点并加入到sync队列中。退出队列的方式在没有中断的场景下和acquireQueued类似，当头结点是自己的前驱节点并且能够获取到状态时，即可以运行，当然要将本节点设置为头结点，表示正在运行。 中断检测。 在每次被唤醒时，进行中断检测，如果发现当前线程被中断，那么抛出InterruptedException并退出循环。 2.4 doAcquireNanos private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException 该方法提供了具备有超时功能的获取状态的调用，如果在指定的nanosTimeout内没有获取到状态，那么返回false，反之返回true。可以将该方法看做acquireInterruptibly的升级版，也就是在判断是否被中断的基础上增加了超时控制。 针对超时控制这部分的实现，主要需要计算出睡眠的delta，也就是间隔值。间隔可以表示为nanosTimeout = 原有nanosTimeout – now（当前时间）+ lastTime（睡眠之前记录的时间）。如果nanosTimeout大于0，那么还需要使当前线程睡眠，反之则返回false。 private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException { long lastTime = System.nanoTime(); final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try { for (;;) { final Node p = node.predecessor(); if (p == head &&tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return true; } if (nanosTimeout spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); long now = System.nanoTime(); //计算时间，当前时间减去睡眠之前的时间得到睡眠的时间，然后被 //原有超时时间减去，得到了还应该睡眠的时间 nanosTimeout -= now - lastTime; lastTime = now; if (Thread.interrupted()) throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } } 上述逻辑主要包括： 加入sync队列； 将当前线程构造成为节点Node加入到sync队列中。 条件满足直接返回； 退出条件判断，如果前驱节点是头结点并且成功获取到状态，那么设置自己为头结点并退出，返回true，也就是在指定的nanosTimeout之前获取了锁。 获取状态失败休眠一段时间； 通过LockSupport.unpark来指定当前线程休眠一段时间。 计算再次休眠的时间； 唤醒后的线程，计算仍需要休眠的时间，该时间表示为nanosTimeout = 原有nanosTimeout – now（当前时间）+ lastTime（睡眠之前记录的时间）。其中now – lastTime表示这次睡眠所持续的时间。 休眠时间的判定。 唤醒后的线程，计算仍需要休眠的时间，并无阻塞的尝试再获取状态，如果失败后查看其nanosTimeout是否大于0，如果小于0，那么返回完全超时，没有获取到锁。 如果nanosTimeout小于等于1000L纳秒，则进入快速的自旋过程。那么快速自旋会造成处理器资源紧张吗？结果是不会，经过测算，开销看起来很小，几乎微乎其微。Doug Lea应该测算了在线程调度器上的切换造成的额外开销，因此在短时1000纳秒内就让当前线程进入快速自旋状态，如果这时再休眠相反会让nanosTimeout的获取时间变得更加不精确。 上述过程可以如下图所示： 上述这个图中可以理解为在类似获取状态需要排队的基础上增加了一个超时控制的逻辑。每次超时的时间就是当前超时剩余的时间减去睡眠的时间，而在这个超时时间的基础上进行了判断，如果大于0那么继续睡眠（等待），可以看出这个超时版本的获取状态只是一个近似超时的获取状态，因此任何含有超时的调用基本结果就是近似于给定超时。 三、共享模式 3.1 acquireShared public final void acquireShared(int arg) 调用该方法能够以共享模式获取状态，共享模式和之前的独占模式有所区别。以文件的查看为例，如果一个程序在对其进行读取操作，那么这一时刻，对这个文件的写操作就被阻塞，相反，这一时刻另一个程序对其进行同样的读操作是可以进行的。如果一个程序在对其进行写操作，那么所有的读与写操作在这一时刻就被阻塞，直到这个程序完成写操作。 以读写场景为例，描述共享和独占的访问模式，如下图所示： 上图中，红色代表被阻塞，绿色代表可以通过。 public final void acquireShared(int arg) { if (tryAcquireShared(arg) = 0) { setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 上述逻辑主要包括： 尝试获取共享状态； 调用tryAcquireShared来获取共享状态，该方法是非阻塞的，如果获取成功则立刻返回，也就表示获取共享锁成功。 获取失败进入sync队列； 在获取共享状态失败后，当前时刻有可能是独占锁被其他线程所把持，那么将当前线程构造成为节点（共享模式）加入到sync队列中。 循环内判断退出队列条件； 如果当前节点的前驱节点是头结点并且获取共享状态成功，这里和独占锁acquire的退出队列条件类似。 获取共享状态成功； 在退出队列的条件上，和独占锁之间的主要区别在于获取共享状态成功之后的行为，而如果共享状态获取成功之后会判断后继节点是否是共享模式，如果是共享模式，那么就直接对其进行唤醒操作，也就是同时激发多个线程并发的运行。 获取共享状态失败。 通过使用LockSupport将当前线程从线程调度器上摘下，进入休眠状态。 对于上述逻辑中，节点之间的通知过程如下图所示： 上图中，绿色表示共享节点，它们之间的通知和唤醒操作是在前驱节点获取状态时就进行的，红色表示独占节点，它的被唤醒必须取决于前驱节点的释放，也就是release操作，可以看出来图中的独占节点如果要运行，必须等待前面的共享节点均释放了状态才可以。而独占节点如果获取了状态，那么后续的独占式获取和共享式获取均被阻塞。 3.2 releaseShared public final boolean releaseShared(int arg) 调用该方法释放共享状态，每次获取共享状态acquireShared都会操作状态，同样在共享锁释放的时候，也需要将状态释放。比如说，一个限定一定数量访问的同步工具，每次获取都是共享的，但是如果超过了一定的数量，将会阻塞后续的获取操作，只有当之前获取的消费者将状态释放才可以使阻塞的获取操作得以运行。 public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } 上述逻辑主要就是调用同步器的tryReleaseShared方法来释放状态，并同时在doReleaseShared方法中唤醒其后继节点。 3.3 一个例子 TwinsLock 在上述对同步器AbstractQueuedSynchronizer进行了实现层面的分析之后，我们通过一个例子来加深对同步器的理解： 设计一个同步工具，该工具在同一时刻，只能有两个线程能够并行访问，超过限制的其他线程进入阻塞状态。 对于这个需求，可以利用同步器完成一个这样的设定，定义一个初始状态，为2，一个线程进行获取那么减1，一个线程释放那么加1，状态正确的范围在[0，1，2]三个之间，当在0时，代表再有新的线程对资源进行获取时只能进入阻塞状态（注意在任何时候进行状态变更的时候均需要以CAS作为原子性保障）。由于资源的数量多于1个，同时可以有两个线程占有资源，因此需要实现tryAcquireShared和tryReleaseShared方法，这里谢谢luoyuyou和同事小明指正，已经修改了实现。 public class TwinsLock implements Lock { private final Sync sync = new Sync(2); private static final class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -7889272986162341211L; Sync(int count) { if (count = 0; } public boolean tryLock(long time, TimeUnit unit) throws InterruptedException { return sync.tryAcquireSharedNanos(1, unit.toNanos(time)); } public void unlock() { sync.releaseShared(1); } @Override public Condition newCondition() { return null; } } 上述测试用例的逻辑主要包括： 打印线程 Worker在两次睡眠之间打印自身线程，如果一个时刻只能有两个线程同时访问，那么打印出来的内容将是成对出现。 分隔线程 不停的打印换行，能让Worker的输出看起来更加直观。 该测试的结果是在一个时刻，仅有两个线程能够获得到锁，并完成打印，而表象就是打印的内容成对出现。 四、总结 AQS简核心是通过一个共享变量来同步状态，变量的状态由子类去维护，而AQS框架做的是： 线程阻塞队列的维护 线程阻塞和唤醒 共享变量的修改都是通过Unsafe类提供的CAS操作完成的。 AbstractQueuedSynchronizer类的主要方法是acquire和release，典型的模板方法， 下面这4个方法由子类去实现： protected boolean tryAcquire(int arg) protected boolean tryRelease(int arg) protected int tryAcquireShared(int arg) protected boolean tryReleaseShared(int arg) acquire方法用来获取锁，返回true说明线程获取成功继续执行，一旦返回false则线程加入到等待队列中，等待被唤醒，release方法用来释放锁。 一般来说实现的时候这两个方法被封装为lock和unlock方法。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/concurrence/ReentrantLock.html":{"url":"java/concurrence/ReentrantLock.html","title":"深入理解ReentrantLock","keywords":"","body":"前言 java5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁的功能，它提供了与synchronized关键字类似的同步功能。既然有了synchronized这种内置的锁功能，为何要新增Lock接口？先来想象一个场景：手把手的进行锁获取和释放，先获得锁A，然后再获取锁B，当获取锁B后释放锁A同时获取锁C，当锁C获取后，再释放锁B同时获取锁D，以此类推，这种场景下，synchronized关键字就不那么容易实现了，而使用Lock却显得容易许多。 定义 public class ReentrantLock implements Lock, java.io.Serializable { private final Sync sync; abstract static class Sync extends AbstractQueuedSynchronizer { /** * Performs {@link Lock#lock}. The main reason for subclassing * is to allow fast path for nonfair version. */ abstract void lock(); /** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */ final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc 从源代码可以Doug lea巧妙的采用组合模式把lock和unlock方法委托给同步器完成。 使用方式 Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); lock.lock(); try { while(条件判断表达式) { condition.wait(); } // 处理逻辑 } finally { lock.unlock(); } 需要显示的获取锁，并在finally块中显示的释放锁，目的是保证在获取到锁之后，最终能够被释放。 非公平锁实现 在非公平锁中，每当线程执行lock方法时，都尝试利用CAS把state从0设置为1。 那么Doug lea是如何实现锁的非公平性呢？ 我们假设这样一个场景： 持有锁的线程A正在running，队列中有线程BCDEF被挂起并等待被唤醒； 在某一个时间点，线程A执行unlock，唤醒线程B； 同时线程G执行lock，这个时候会发生什么？线程B和G拥有相同的优先级，这里讲的优先级是指获取锁的优先级，同时执行CAS指令竞争锁。如果恰好线程G成功了，线程B就得重新挂起等待被唤醒。 通过上述场景描述，我们可以看书，即使线程B等了很长时间也得和新来的线程G同时竞争锁，如此的不公平。 static final class NonfairSync extends Sync { /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); } } 下面我们用线程A和线程B来描述非公平锁的竞争过程。 线程A和B同时执行CAS指令，假设线程A成功，线程B失败，则表明线程A成功获取锁，并把同步器中的exclusiveOwnerThread设置为线程A。 竞争失败的线程B，在nonfairTryAcquire方法中，会再次尝试获取锁， Doug lea会在多处尝试重新获取锁，应该是在这段时间如果线程A释放锁，线程B就可以直接获取锁而不用挂起 。完整的执行流程如下： 公平锁实现 在公平锁中，每当线程执行lock方法时，如果同步器的队列中有线程在等待，则直接加入到队列中。 场景分析： 持有锁的线程A正在running，对列中有线程BCDEF被挂起并等待被唤醒； 线程G执行lock，队列中有线程BCDEF在等待，线程G直接加入到队列的对尾。 所以每个线程获取锁的过程是公平的，等待时间最长的会最先被唤醒获取锁。 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; final void lock() { acquire(1); } /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc 重入锁实现 重入锁，即线程可以重复获取已经持有的锁。在非公平和公平锁中，都对重入锁进行了实现。 if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc 条件变量Condition 条件变量很大一个程度上是为了解决Object.wait/notify/notifyAll难以使用的问题。 public class ConditionObject implements Condition, java.io.Serializable { /** First node of condition queue. */ private transient Node firstWaiter; /** Last node of condition queue. */ private transient Node lastWaiter; public final void signal() {} public final void signalAll() {} public final void awaitUninterruptibly() {} public final void await() throws InterruptedException {} } Synchronized中，所有的线程都在同一个object的条件队列上等待。而ReentrantLock中，每个condition都维护了一个条件队列。 每一个Lock可以有任意数据的Condition对象，Condition是与Lock绑定的，所以就有Lock的公平性特性：如果是公平锁，线程为按照FIFO的顺序从Condition.await中释放，如果是非公平锁，那么后续的锁竞争就不保证FIFO顺序了。 Condition接口定义的方法，await对应于Object.wait，signal对应于Object.notify，signalAll对应于Object.notifyAll。特别说明的是Condition的接口改变名称就是为了避免与Object中的wait/notify/notifyAll的语义和使用上混淆。 先看一个condition在生产者消费者的应用场景： import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * Created by j_zhan on 2016/7/13. */ public class Queue { private final T[] items; private final Lock lock = new ReentrantLock(); private Condition notFull = lock.newCondition(); private Condition notEmpty = lock.newCondition(); private int head, tail, count; public Queue(int maxSize) { items = (T[]) new Object[maxSize]; } public Queue() { this(10); } public void put(T t) throws InterruptedException { lock.lock(); try { while (count == items.length) { //数组满时，线程进入等待队列挂起。线程被唤醒时，从这里返回。 notFull.await(); } items[tail] = t; if (++tail == items.length) { tail = 0; } ++count; notEmpty.signal(); } finally { lock.unlock(); } } public T take() throws InterruptedException { lock.lock(); try { while (count == 0) { notEmpty.await(); } T o = items[head]; items[head] = null;//GC if (++head == items.length) { head = 0; } --count; notFull.signal(); return o; } finally { lock.unlock(); } } } 假设线程AB在并发的往items中插入数据，当items中元素存满时。如果线程A获取到锁，继续添加数据，满足count == items.length条件，导致线程A执行await方法。 ReentrantLock是独占锁，同一时刻只有一个线程能获取到锁，所以在lock.lock()和lock.unlock()之间可能有一次释放锁的操作（同样也必然还有一次获取锁的操作）。在Queue类中，不管take还是put，在线程持有锁之后只有await()方法有可能释放锁，然后挂起线程，一旦条件满足就被唤醒，再次获取锁。具体实现如下： public final void await() throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) { LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } if (acquireQueued(node, savedState) && interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); } private Node addConditionWaiter() { Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null && t.waitStatus != Node.CONDITION) { unlinkCancelledWaiters(); t = lastWaiter; } Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node; } await实现逻辑： 将线程A加入到条件等待队列中，如果最后一个节点是取消状态，则从对列中删除。 线程A释放锁，实质上是线程A修改AQS的状态state为0，并唤醒AQS等待队列中的线程B，线程B被唤醒后，尝试获取锁，接下去的过程就不重复说明了。 线程A释放锁并唤醒线程B之后，如果线程A不在AQS的同步队列中，线程A将通过LockSupport.park进行挂起操作。 随后，线程A等待被唤醒，当线程A被唤醒时，会通过acquireQueued方法竞争锁，如果失败，继续挂起。如果成功，线程A从await位置恢复。 假设线程B获取锁之后，执行了take操作和条件变量的signal，signal通过某种实现唤醒了线程A，具体实现如下： public final void signal() { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first); } private void doSignal(Node first) { do { if ((firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; } while (!transferForSignal(first) && (first = firstWaiter) != null); } final boolean transferForSignal(Node node) { if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; Node p = enq(node); //线程A插入到AQS的等待队列中 int ws = p.waitStatus; if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true; } signal实现逻辑： 接着上述场景，线程B执行了signal方法，取出条件队列中的第一个非CANCELLED节点线程，即线程A。另外，signalAll就是唤醒条件队列中所有非CANCELLED节点线程。遇到CANCELLED线程就需要将其从队列中删除。 通过CAS修改线程A的waitStatus，表示该节点已经不是等待条件状态，并将线程A插入到AQS的等待队列中。 唤醒线程A，线程A和别的线程进行锁的竞争。 总结 ReentrantLock提供了内置锁类似的功能和内存语义。 此外，ReetrantLock还提供了其它功能，包括定时的锁等待、可中断的锁等待、公平性、以及实现非块结构的加锁、Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性，不过ReetrantLock需要显示的获取锁，并在finally中释放锁，否则后果很严重。 ReentrantLock在性能上似乎优于Synchronized，其中在jdk1.6中略有胜出，在1.5中是远远胜出。那么为什么不放弃内置锁，并在新代码中都使用ReetrantLock？ 在java1.5中， 内置锁与ReentrantLock相比有例外一个优点：在线程转储中能给出在哪些调用帧中获得了哪些锁，并能够检测和识别发生死锁的线程。Reentrant的非块状特性任然意味着，获取锁的操作不能与特定的栈帧关联起来，而内置锁却可以。 因为内置锁时JVM的内置属性，所以未来更可能提升synchronized而不是ReentrantLock的性能。例如对线程封闭的锁对象消除优化，通过增加锁粒度来消除内置锁的同步。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/concurrence/ArrayBlockingQueue.html":{"url":"java/concurrence/ArrayBlockingQueue.html","title":"Java并发集合——ArrayBlockingQueue","keywords":"","body":"前言 本文的主要详细分析ArrayBlockingQueue的实现原理，由于该并发集合其底层是使用了java.util.ReentrantLock和java.util.Condition来完成并发控制的，我们可以通过JDK的源代码更好的学习这些并发控制类的使用，同时该类也是所有并发集合中最简单的一个，分析该类的源码也是为之后分析其他并发集合做好基础。 一、Queue接口和BlockingQueue接口回顾 1.1 Queue接口回顾 在Queue接口中，除了继承Collection接口中定义的方法外，它还分别额外地定义插入、删除、查询这3个操作，其中每一个操作都以两种不同的形式存在，每一种形式都对应着一个方法。 方法说明： Throws exception Returns special value Insert add(e) offer(e) Remove remove() poll() Examine element() peek() add方法在将一个元素插入到队列的尾部时，如果出现队列已经满了，那么就会抛出IllegalStateException,而使用offer方法时，如果队列满了，则添加失败,返回false,但并不会引发异常。 remove方法是获取队列的头部元素并且删除，如果当队列为空时，那么就会抛出NoSuchElementException。而poll在队列为空时，则返回一个null。 element方法是从队列中获取到队列的第一个元素，但不会删除，但是如果队列为空时，那么它就会抛出NoSuchElementException。peek方法与之类似，只是不会抛出异常，而是返回false。 后面我们在分析ArrayBlockingQueue的方法时，主要也是围绕着这几个方法来进行分析。 1.2 BlockingQueue接口回顾 BlockingQueue是JDK1.5出现的接口，它在原来的Queue接口基础上提供了更多的额外功能：当获取队列中的头部元素时，如果队列为空，那么它将会使执行线程处于等待状态；当添加一个元素到队列的尾部时，如果队列已经满了，那么它同样会使执行的线程处于等待状态。 前面我们在说Queue接口时提到过，它针对于相同的操作提供了2种不同的形式，而BlockingQueue更夸张，针对于相同的操作提供了4种不同的形式。 该四种形式分别为： 抛出异常 返回一个特殊值(可能是null或者是false，取决于具体的操作) 阻塞当前执行直到其可以继续 当线程被挂起后，等待最大的时间，如果一旦超时，即使该操作依旧无法继续执行，线程也不会再继续等待下去。 对应的方法说明: Throws exception Returns special value Blocks Times out Insert add(e) offer(e) put(e) offer(e, time, unit) Remove remove() poll() take() poll(time, unit) Examine element() peek() 无 无 BlockingQueue虽然比起Queue在操作上提供了更多的支持，但是它在使用有如下的几点: BlockingQueue中是不允许添加null的，该接受在声明的时候就要求所有的实现类在接收到一个null的时候，都应该抛出NullPointerException。 BlockingQueue是线程安全的，因此它的所有和队列相关的方法都具有原子性。但是对于那么从Collection接口中继承而来的批量操作方法，比如addAll(Collection e)等方法，BlockingQueue的实现通常没有保证其具有原子性，因此我们在使用的BlockingQueue，应该尽可能地不去使用这些方法。 BlockingQueue主要应用于生产者与消费者的模型中，其元素的添加和获取都是极具规律性的。但是对于remove(Object o)这样的方法，虽然BlockingQueue可以保证元素正确的删除，但是这样的操作会非常响应性能，因此我们在没有特殊的情况下，也应该避免使用这类方法。 二、ArrayBlockingQueue深入分析 有了上面的铺垫，下面我们就可以真正开始分析ArrayBlockingQueue了。在分析之前，首先让我们看看API对其的描述。 注意:这里使用的JDK版本为1.7，不同的JDK版本在实现上存在不同 首先让我们看下ArrayBlockingQueue的核心组成： /** 底层维护队列元素的数组 */ final Object[] items; /** 当读取元素时数组的下标(这里称为读下标) */ int takeIndex; /** 添加元素时数组的下标 (这里称为写小标)*/ int putIndex; /** 队列中的元素个数 */ int count; /**用于并发控制的工具类**/ final ReentrantLock lock; /** 控制take操作时是否让线程等待 */ private final Condition notEmpty; /** 控制put操作时是否让线程等待 */ private final Condition notFull; take方法分析(369-379行): public E take() throws InterruptedException { final ReentrantLock lock = this.lock; /* 尝试获取锁，如果此时锁被其他线程锁占用，那么当前线程就处于Waiting的状态。 注意:当方法是支持线程中断响应的如果其他线程此时中断当前线程， 那么当前线程就会抛出InterruptedException */ lock.lockInterruptibly(); try { /* 如果此时队列中的元素个数为0,那么就让当前线程wait,并且释放锁。 注意:这里使用了while进行重复检查，是为了防止当前线程可能由于其他未知的原因被唤醒。 (通常这种情况被称为\"spurious wakeup\") */ while (count == 0) notEmpty.await(); //如果队列不为空，则从队列的头部取元素 return extract(); } finally { //完成锁的释放 lock.unlock(); } } extract方法分析(163-171): /* 根据takeIndex来获取当前的元素,然后通知其他等待的线程。 Call only when holding lock.(只有当前线程已经持有了锁之后，它才能调用该方法) */ private E extract() { final Object[] items = this.items; //根据takeIndex获取元素,因为元素是一个Object类型的数组,因此它通过cast方法将其转换成泛型。 E x = this.cast(items[takeIndex]); //将当前位置的元素设置为null items[takeIndex] = null; //并且将takeIndex++,注意：这里因为已经使用了锁，因此inc方法中没有使用到原子操作 takeIndex = inc(takeIndex); //将队列中的总的元素减1 --count; //唤醒其他等待的线程 notFull.signal(); return x; } put方法分析(318-239) public void put(E e) throws InterruptedException { //首先检查元素是否为空，否则抛出NullPointerException checkNotNull(e); final ReentrantLock lock = this.lock; //进行锁的抢占 lock.lockInterruptibly(); try { /*当队列的长度等于数组的长度,此时说明队列已经满了,这里同样 使用了while来方式当前线程被\"伪唤醒\"。*/ while (count == items.length) //则让当前线程处于等待状态 notFull.await(); //一旦获取到锁并且队列还未满时，则执行insert操作。 insert(e); } finally { //完成锁的释放 lock.unlock(); } } //检查元素是否为空 private static void checkNotNull(Object v) { if (v == null) throw new NullPointerException(); } //该方法的逻辑非常简单 private void insert(E x) { //将当前元素设置到putIndex位置 items[putIndex] = x; //让putIndex++ putIndex = inc(putIndex); //将队列的大小加1 ++count; //唤醒其他正在处于等待状态的线程 notEmpty.signal(); } 注:ArrayBlockingQueue其实是一个循环队列 我们使用一个图来简单说明一下: 黄色表示数组中有元素 当再一次执行put的时候,其结果为： 此时放入的元素会从头开始置，我们通过其incr方法更加清晰的看出其底层的操作： /** * Circularly increment i. */ final int inc(int i) { //当takeIndex的值等于数组的长度时,就会重新置为0，这个一个循环递增的过程 return (++i == items.length) ? 0 : i; } 至此，ArrayBlockingQueue的核心部分就分析完了，其余的队列操作基本上都是换汤不换药的，此处不再一一列举。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/concurrence/LinkedBlockingQueue.html":{"url":"java/concurrence/LinkedBlockingQueue.html","title":"Java并发集合——LinkedBlockingQueue","keywords":"","body":"前言 在前面的文章ArrayBlockingQueue中，已经对JDK中的BlockingQueue中的做了一个回顾，同时对ArrayBlockingQueue中的核心方法作了说明，而LinkedBlockingQueue作为JDK中BlockingQueue家族系列中一员，由于其作为固定大小线程池(Executors.newFixedThreadPool())底层所使用的阻塞队列，分析它的目的主要在于2点： 与ArrayBlockingQueue进行类比学习，加深各种数据结构的理解 了解底层实现，能够更好地理解每一种阻塞队列对线程池性能的影响，做到真正的知其然，且知其所以然 源码分析LinkedBlockingQueue的实现 与ArrayBlockingQueue进行比较 说明为什么选择LinkedBlockingQueue作为固定大小的线程池的阻塞队列 LinkedBlockingQueue深入分析 LinkedBlockingQueue，见名之意，它是由一个基于链表的阻塞队列，首先看一下的核心组成： // 所有的元素都通过Node这个静态内部类来进行存储，这与LinkedList的处理方式完全一样 static class Node { //使用item来保存元素本身 E item; //保存当前节点的后继节点 Node next; Node(E x) { item = x; } } /** 阻塞队列所能存储的最大容量 用户可以在创建时手动指定最大容量,如果用户没有指定最大容量 那么最默认的最大容量为Integer.MAX_VALUE. */ private final int capacity; /** 当前阻塞队列中的元素数量 PS:如果你看过ArrayBlockingQueue的源码,你会发现 ArrayBlockingQueue底层保存元素数量使用的是一个 普通的int类型变量。其原因是在ArrayBlockingQueue底层 对于元素的入队列和出队列使用的是同一个lock对象。而数 量的修改都是在处于线程获取锁的情况下进行操作，因此不 会有线程安全问题。 而LinkedBlockingQueue却不是，它的入队列和出队列使用的是两个 不同的lock对象,因此无论是在入队列还是出队列，都会涉及对元素数 量的并发修改，(之后通过源码可以更加清楚地看到)因此这里使用了一个原子操作类 来解决对同一个变量进行并发修改的线程安全问题。 */ private final AtomicInteger count = new AtomicInteger(0); /** * 链表的头部 * LinkedBlockingQueue的头部具有一个不变性: * 头部的元素总是为null，head.item==null */ private transient Node head; /** * 链表的尾部 * LinkedBlockingQueue的尾部也具有一个不变性: * 即last.next==null */ private transient Node last; /** 元素出队列时线程所获取的锁 当执行take、poll等操作时线程需要获取的锁 */ private final ReentrantLock takeLock = new ReentrantLock(); /** 当队列为空时，通过该Condition让从队列中获取元素的线程处于等待状态 */ private final Condition notEmpty = takeLock.newCondition(); /** 元素入队列时线程所获取的锁 当执行add、put、offer等操作时线程需要获取锁 */ private final ReentrantLock putLock = new ReentrantLock(); /** 当队列的元素已经达到capactiy，通过该Condition让元素入队列的线程处于等待状态 */ private final Condition notFull = putLock.newCondition(); 通过上面的分析，我们可以发现LinkedBlockingQueue在入队列和出队列时使用的不是同一个Lock，这也意味着它们之间的操作不会存在互斥操作。在多个CPU的情况下，它们可以做到真正的在同一时刻既消费、又生产，能够做到并行处理。 下面让我们看下LinkedBlockingQueue的构造方法： /** * 如果用户没有显示指定capacity的值，默认使用int的最大值 */ public LinkedBlockingQueue() { this(Integer.MAX_VALUE); } /** 可以看到,当队列中没有任何元素的时候,此时队列的头部就等于队列的尾部, 指向的是同一个节点,并且元素的内容为null */ public LinkedBlockingQueue(int capacity) { if (capacity (null); } /* 在初始化LinkedBlockingQueue的时候，还可以直接将一个集合 中的元素全部入队列，此时队列最大容量依然是int的最大值。 */ public LinkedBlockingQueue(Collection c) { this(Integer.MAX_VALUE); final ReentrantLock putLock = this.putLock; //获取锁 putLock.lock(); // Never contended, but necessary for visibility try { //迭代集合中的每一个元素,让其入队列,并且更新一下当前队列中的元素数量 int n = 0; for (E e : c) { if (e == null) throw new NullPointerException(); if (n == capacity) throw new IllegalStateException(\"Queue full\"); //参考下面的enqueue分析 enqueue(new Node(e)); ++n; } count.set(n); } finally { //释放锁 putLock.unlock(); } } /** * 我去，这代码其实可读性不怎么样啊。 * 其实下面的代码等价于如下内容: * last.next=node; * last = node; * 其实也没有什么花样: 就是让新入队列的元素成为原来的last的next，让进入的元素称为last * */ private void enqueue(Node node) { // assert putLock.isHeldByCurrentThread(); // assert last.next == null; last = last.next = node; } 在分析完LinkedBlockingQueue的核心组成之后,下面让我们再看下核心的几个操作方法,首先分析一下元素入队列的过程: public void put(E e) throws InterruptedException { if (e == null) throw new NullPointerException(); // Note: convention in all put/take/etc is to preset local var /*注意上面这句话,约定所有的put/take操作都会预先设置本地变量, 可以看到下面有一个将putLock赋值给了一个局部变量的操作 */ int c = -1; Node node = new Node(e); /* 在这里首先获取到putLock,以及当前队列的元素数量 即上面所描述的预设置本地变量操作 */ final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; /* 执行可中断的锁获取操作,即意味着如果线程由于获取 锁而处于Blocked状态时，线程是可以被中断而不再继 续等待，这也是一种避免死锁的一种方式，不会因为 发现到死锁之后而由于无法中断线程最终只能重启应用。 */ putLock.lockInterruptibly(); try { /* 当队列的容量到底最大容量时,此时线程将处于等待状 态，直到队列有空闲的位置才继续执行。使用while判 断依旧是为了放置线程被\"伪唤醒”而出现的情况,即当 线程被唤醒时而队列的大小依旧等于capacity时，线 程应该继续等待。 */ while (count.get() == capacity) { notFull.await(); } //让元素进行队列的末尾,enqueue代码在上面分析过了 enqueue(node); //首先获取原先队列中的元素个数,然后再对队列中的元素个数+1. c = count.getAndIncrement(); /*注:c+1得到的结果是新元素入队列之后队列元素的总和。 当前队列中的总元素个数小于最大容量时,此时唤醒其他执行入队列的线程 让它们可以放入元素,如果新加入元素之后,队列的大小等于capacity， 那么就意味着此时队列已经满了,也就没有必须要唤醒其他正在等待入队列的线程,因为唤醒它们之后，它们也还是继续等待。 */ if (c + 1 看完put方法，下面再看看下offer是如何处理的方法： /** 在BlockingQueue接口中除了定义put方法外(当队列元素满了之后就会阻塞， 直到队列有新的空间可以方法线程才会继续执行)，还定义一个offer方法， 该方法会返回一个boolean值，当入队列成功返回true,入队列失败返回false。 该方法与put方法基本操作基本一致，只是有细微的差异。 */ public boolean offer(E e) { if (e == null) throw new NullPointerException(); final AtomicInteger count = this.count; /* 当队列已经满了，它不会继续等待,而是直接返回。 因此该方法是非阻塞的。 */ if (count.get() == capacity) return false; int c = -1; Node node = new Node(e); final ReentrantLock putLock = this.putLock; putLock.lock(); try { /* 当获取到锁时，需要进行二次的检查,因为可能当队列的大小为capacity-1时， 两个线程同时去抢占锁，而只有一个线程抢占成功，那么此时 当线程将元素入队列后，释放锁，后面的线程抢占锁之后，此时队列 大小已经达到capacity，所以将它无法让元素入队列。 下面的其余操作和put都一样，此处不再详述 */ if (count.get() = 0; } BlockingQueue还定义了一个限时等待插入操作，即在等待一定的时间内，如果队列有空间可以插入，那么就将元素入队列，然后返回true,如果在过完指定的时间后依旧没有空间可以插入，那么就返回false，下面是限时等待操作的分析: /** 通过timeout和TimeUnit来指定等待的时长 timeout为时间的长度,TimeUnit为时间的单位 */ public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException { if (e == null) throw new NullPointerException(); //将指定的时间长度转换为毫秒来进行处理 long nanos = unit.toNanos(timeout); int c = -1; final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try { while (count.get() == capacity) { //如果等待的剩余时间小于等于0，那么直接返回 if (nanos (e)); c = count.getAndIncrement(); if (c + 1 通过上面的分析，我们应该比较清楚地知道了LinkedBlockingQueue的入队列的操作，其主要是通过获取到putLock锁来完成，当队列的数量达到最大值，此时会导致线程处于阻塞状态或者返回false(根据具体的方法来看)；如果队列还有剩余的空间，那么此时会新创建出一个Node对象，将其设置到队列的尾部，作为LinkedBlockingQueue的last元素。 在分析完入队列的过程之后，我们接下来看看LinkedBlockingQueue出队列的过程；由于BlockingQueue的方法都具有对称性，此处就只分析take方法的实现，其余方法的实现都如出一辙： public E take() throws InterruptedException { E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; //通过takeLock获取锁，并且支持线程中断 takeLock.lockInterruptibly(); try { //当队列为空时，则让当前线程处于等待 while (count.get() == 0) { notEmpty.await(); } //完成元素的出队列 x = dequeue(); /* 队列元素个数完成原子化操作-1,可以看到count元素会 在插入元素的线程和获取元素的线程进行并发修改操作。 */ c = count.getAndDecrement(); /* 当一个元素出队列之后，队列的大小依旧大于1时 当前线程会唤醒其他执行元素出队列的线程,让它们也 可以执行元素的获取 */ if (c > 1) notEmpty.signal(); } finally { //完成锁的释放 takeLock.unlock(); } /* 当c==capaitcy时，即在获取当前元素之前， 队列已经满了，而此时获取元素之后，队列就会 空出一个位置，故当前线程会唤醒执行插入操作的线 程通知其他中的一个可以进行插入操作。 */ if (c == capacity) signalNotFull(); return x; } /** * 让头部元素出队列的过程 * 其最终的目的是让原来的head被GC回收，让其的next成为head * 并且新的head的item为null. * 因为LinkedBlockingQueue的头部具有一致性:即元素为null。 */ private E dequeue() { Node h = head; Node first = h.next; h.next = h; // help GC head = first; E x = first.item; first.item = null; return x; } 对于LinkedBlockingQueue的源码分析就到这里，下面让我们将LinkedBlockingQueue与ArrayBlockingQueue进行一个比较。 LinkedBlockingQueue与ArrayBlockingQueue的比较 ArrayBlockingQueue由于其底层基于数组，并且在创建时指定存储的大小，在完成后就会立即在内存分配固定大小容量的数组元素，因此其存储通常有限，故其是一个“有界“的阻塞队列； 而LinkedBlockingQueue可以由用户指定最大存储容量，也可以无需指定，如果不指定则最大存储容量将是Integer.MAX_VALUE，即可以看作是一个“无界”的阻塞队列，由于其节点的创建都是动态创建，并且在节点出队列后可以被GC所回收，因此其具有灵活的伸缩性。但是由于ArrayBlockingQueue的有界性，因此其能够更好的对于性能进行预测，而LinkedBlockingQueue由于没有限制大小，当任务非常多的时候，不停地向队列中存储，就有可能导致内存溢出的情况发生。 其次，ArrayBlockingQueue中在入队列和出队列操作过程中，使用的是同一个lock，所以即使在多核CPU的情况下，其读取和操作的都无法做到并行，而LinkedBlockingQueue的读取和插入操作所使用的锁是两个不同的lock，它们之间的操作互相不受干扰，因此两种操作可以并行完成，故LinkedBlockingQueue的吞吐量要高于ArrayBlockingQueue。 选择LinkedBlockingQueue的理由 /** 下面的代码是Executors创建固定大小线程池的代码，其使用了 LinkedBlockingQueue来作为任务队列。 */ public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); } JDK中选用LinkedBlockingQueue作为阻塞队列的原因就在于其无界性。因为线程大小固定的线程池，其线程的数量是不具备伸缩性的，当任务非常繁忙的时候，就势必会导致所有的线程都处于工作状态，如果使用一个有界的阻塞队列来进行处理，那么就非常有可能很快导致队列满的情况发生，从而导致任务无法提交而抛出RejectedExecutionException，而使用无界队列由于其良好的存储容量的伸缩性，可以很好的去缓冲任务繁忙情况下场景，即使任务非常多，也可以进行动态扩容，当任务被处理完成之后，队列中的节点也会被随之被GC回收，非常灵活。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/concurrence/ConcurrentHashMap.html":{"url":"java/concurrence/ConcurrentHashMap.html","title":"Java并发集合——ConcurrentHashMap","keywords":"","body":"前言 HashMap是我们平时开发过程中用的比较多的集合，但它是非线程安全的，在涉及到多线程并发的情况，进行put操作有可能会引起死循环，导致CPU利用率接近100%。 final HashMap map = new HashMap(2); for (int i = 0; i 解决方案有Hashtable和Collections.synchronizedMap(hashMap)，不过这两个方案基本上是对读写进行加锁操作，一个线程在读写元素，其余线程必须等待，性能可想而知。 所以，Doug Lea给我们带来了并发安全的ConcurrentHashMap，它的实现是依赖于 Java 内存模型，所以我们在了解 ConcurrentHashMap 的之前必须了解一些底层的知识： java内存模型 java中的CAS AbstractQueuedSynchronizer ReentrantLock 本文源码是JDK8的版本，与之前的版本有较大差异。 JDK1.6分析 ConcurrentHashMap采用 分段锁的机制，实现并发的更新操作，底层采用数组+链表+红黑树的存储结构。 其包含两个核心静态内部类 Segment和HashEntry。 Segment继承ReentrantLock用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶。 HashEntry 用来封装映射表的键 / 值对； 每个桶是由若干个 HashEntry 对象链接起来的链表。 一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组，下面我们通过一个图来演示一下 ConcurrentHashMap 的结构： JDK1.8分析 1.8的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层依然采用数组+链表+红黑树的存储结构。 重要概念 在开始之前，有些重要的概念需要介绍一下： table：默认为null，初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方。 nextTable：默认为null，扩容时新生成的数组，其大小为原数组的两倍。 sizeCtl ：默认为0，用来控制table的初始化和扩容操作，具体应用在后续会体现出来。 -1 代表table正在初始化 -N 表示有N-1个线程正在进行扩容操作 其余情况： 1、如果table未初始化，表示table需要初始化的大小。 2、如果table初始化完成，表示table的容量，默认是table大小的0.75倍，居然用这个公式算0.75（n - (n >>> 2)）。 Node ：保存key，value及key的hash值的数据结构。 class Node implements Map.Entry { final int hash; final K key; volatile V val; volatile Node next; ... 省略部分代码 } 其中value和next都用volatile修饰，保证并发的可见性。 ForwardingNode ：一个特殊的Node节点，hash值为-1，其中存储nextTable的引用。 final class ForwardingNode extends Node { final Node[] nextTable; ForwardingNode(Node[] tab) { super(MOVED, null, null, null); this.nextTable = tab; } } 只有table发生扩容的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或则已经被移动。 实例初始化 实例化ConcurrentHashMap时带参数时，会根据参数调整table的大小，假设参数为100，最终会调整成256，确保table的大小总是2的幂次方，算法如下： ConcurrentHashMap hashMap = new ConcurrentHashMap<>(100); private static final int tableSizeFor(int c) { int n = c - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n = MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 注意，ConcurrentHashMap在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。 table初始化 前面已经提到过，table初始化操作会延缓到第一次put行为。但是put是可以并发执行的，Doug Lea是如何实现table只初始化一次的？让我们来看看源码的实现。 private final Node[] initTable() { Node[] tab; int sc; while ((tab = table) == null || tab.length == 0) { //如果一个线程发现sizeCtl 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\"unchecked\") Node[] nt = (Node[])new Node[n]; table = tab = nt; sc = n - (n >>> 2); } } finally { sizeCtl = sc; } break; } } return tab; } sizeCtl默认为0，如果ConcurrentHashMap实例化时有传参数，sizeCtl会是一个2的幂次方的值。所以执行第一次put操作的线程会执行Unsafe.compareAndSwapInt方法修改sizeCtl为-1，有且只有一个线程能够修改成功，其它线程通过Thread.yield()让出CPU时间片等待table初始化完成。 put操作 假设table已经初始化完成，put操作采用CAS+synchronized实现并发插入或更新操作，具体实现如下。 final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; for (Node[] tab = table;;) { Node f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { if (casTabAt(tab, i, null, new Node(hash, key, value, null))) break; // no lock when adding to empty bin } else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); ...省略部分代码 } addCount(1L, binCount); return null; } hash算法 static final int spread(int h) {return (h ^ (h >>> 16)) & HASH_BITS;} table中定位索引位置，n是table的大小 int index = (n - 1) & hash 获取table中对应索引的元素f。 Doug Lea采用Unsafe.getObjectVolatile来获取，也许有人质疑，直接table[index]不可以么，为什么要这么复杂？ 在java内存模型中，我们已经知道每个线程都有一个工作内存，里面存储着table的副本，虽然table是volatile修饰的，但不能保证线程每次都拿到table中的最新元素，Unsafe.getObjectVolatile可以直接获取指定内存的数据，保证了每次拿到数据都是最新的。 如果f为null，说明table中这个位置第一次插入元素，利用Unsafe.compareAndSwapObject方法插入Node节点。 如果CAS成功，说明Node节点已经插入，随后addCount(1L, binCount)方法会检查当前容量是否需要进行扩容。 如果CAS失败，说明有其它线程提前插入了节点，自旋重新尝试在这个位置插入节点。 如果f的hash值为-1，说明当前f是ForwardingNode节点，意味有其它线程正在扩容，则一起进行扩容操作。 其余情况把新的Node节点按链表或红黑树的方式插入到合适的位置，这个过程采用同步内置锁实现并发，代码如下: synchronized (f) { if (tabAt(tab, i) == f) { if (fh >= 0) { binCount = 1; for (Node e = f;; ++binCount) { K ek; if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node pred = e; if ((e = e.next) == null) { pred.next = new Node(hash, key, value, null); break; } } } else if (f instanceof TreeBin) { Node p; binCount = 2; if ((p = ((TreeBin)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } 在节点f上进行同步，节点插入之前，再次利用tabAt(tab, i) == f判断，防止被其它线程修改。 如果f.hash >= 0，说明f是链表结构的头结点，遍历链表，如果找到对应的node节点，则修改value，否则在链表尾部加入节点。 如果f是TreeBin类型节点，说明f是红黑树根节点，则在树结构上遍历元素，更新或增加节点。 如果链表中节点数binCount >= TREEIFY_THRESHOLD(默认是8)，则把链表转化为红黑树结构。 table扩容 当table容量不足的时候，即table的元素数量达到容量阈值sizeCtl，需要对table进行扩容。 整个扩容分为两部分： 构建一个nextTable，大小为table的两倍。 把table的数据复制到nextTable中。 这两个过程在单线程下实现很简单，但是ConcurrentHashMap是支持并发插入的，扩容操作自然也会有并发的出现，这种情况下，第二步可以支持节点的并发复制，这样性能自然提升不少，但实现的复杂度也上升了一个台阶。 先看第一步，构建nextTable，毫无疑问，这个过程只能只有单个线程进行nextTable的初始化，具体实现如下： private final void addCount(long x, int check) { ... 省略部分代码 if (check >= 0) { Node[] tab, nt; int n, sc; while (s >= (long)(sc = sizeCtl) && (tab = table) != null && (n = tab.length) >> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex 通过Unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable，扩容后的数组长度为原来的两倍，但是容量是原来的1.5。 节点从table移动到nextTable，大体思想是遍历、复制的过程。 首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素f，初始化一个forwardNode实例fwd。 如果f == null，则在table中的i位置放入fwd，这个过程是采用Unsafe.compareAndSwapObjectf方法实现的，很巧妙的实现了节点的并发移动。 如果f是链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上，移动完成，采用Unsafe.putObjectVolatile方法给table原位置赋值fwd。 如果f是TreeBin节点，也做一个反序处理，并判断是否需要untreeify，把处理的结果分别放在nextTable的i和i+n的位置上，移动完成，同样采用Unsafe.putObjectVolatile方法给table原位置赋值fwd。 遍历过所有的节点以后就完成了复制工作，把table指向nextTable，并更新sizeCtl为新数组大小的0.75倍 ，扩容完成。 红黑树构造 注意：如果链表结构中元素超过TREEIFY_THRESHOLD阈值，默认为8个，则把链表转化为红黑树，提高遍历查询效率。 if (binCount != 0) { if (binCount >= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } 接下来我们看看如何构造树结构，代码如下： private final void treeifyBin(Node[] tab, int index) { Node b; int n, sc; if (tab != null) { if ((n = tab.length) = 0) { synchronized (b) { if (tabAt(tab, index) == b) { TreeNode hd = null, tl = null; for (Node e = b; e != null; e = e.next) { TreeNode p = new TreeNode(e.hash, e.key, e.val, null, null); if ((p.prev = tl) == null) hd = p; else tl.next = p; tl = p; } setTabAt(tab, index, new TreeBin(hd)); } } } } } 可以看出，生成树节点的代码块是同步的，进入同步代码块之后，再次验证table中index位置元素是否被修改过。 1、根据table中index位置Node链表，重新生成一个hd为头结点的TreeNode链表。 2、根据hd头结点，生成TreeBin树结构，并把树结构的root节点写到table的index位置的内存中，具体实现如下： TreeBin(TreeNode b) { super(TREEBIN, null, null, null); this.first = b; TreeNode r = null; for (TreeNode x = b, next; x != null; x = next) { next = (TreeNode)x.next; x.left = x.right = null; if (r == null) { x.parent = null; x.red = false; r = x; } else { K k = x.key; int h = x.hash; Class kc = null; for (TreeNode p = r;;) { int dir, ph; K pk = p.key; if ((ph = p.hash) > h) dir = -1; else if (ph xp = p; if ((p = (dir 主要根据Node节点的hash值大小构建二叉树。这个红黑树的构造过程实在有点复杂，感兴趣的同学可以看看源码。 get操作 get操作和put操作相比，显得简单了许多。 public V get(Object key) { Node[] tab; Node e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null && (n = tab.length) > 0 && (e = tabAt(tab, (n - 1) & h)) != null) { if ((eh = e.hash) == h) { if ((ek = e.key) == key || (ek != null && key.equals(ek))) return e.val; } else if (eh 判断table是否为空，如果为空，直接返回null。 计算key的hash值，并获取指定table中指定位置的Node节点，通过遍历链表或则树结构找到对应的节点，返回value值。 总结 ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 HashTable 和同步包装器包装的 HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"java/virtual-machine.html":{"url":"java/virtual-machine.html","title":"Java虚拟机","keywords":"","body":"一、前言 本部分内容是关于Java虚拟机的一些面试高频知识点的总结。说到对Java虚拟机的学习，就不得不提下这本书《深入理解Java虚拟机》。 本部分的内容也是基于这本书进行整理的，这本书基本是面试必备。 关于Java虚拟机，重点考察以下三个方面的内容： 内存区域/内存模型 类加载机制 垃圾收集算法/收集器 二、目录 对象的创建、内存布局和访问定位 Java内存区域与内存模型 Java类加载机制及类加载器详解 JVM中垃圾收集算法及垃圾收集器详解 JVM怎么判断对象是否已死？ Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:02 "},"java/virtual-machine/object.html":{"url":"java/virtual-machine/object.html","title":"对象的创建、内存布局和访问定位","keywords":"","body":"一、对象的创建 1.虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用； 2.检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，那必须先执行响应的类加载过程； 3.在类加载检查功通过后，为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定。 二、对象的内存布局 分为3个区域：对象头，实例数据，对齐填充。 对象头： 包括两部分信息，第一部分：对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32 bit和64 bit，官方称它为“Mark Word”。 第二部分：类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个java数组，那在对象头中还必须有一块用于记录数组长度的数据。 实例数据： 是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。 对齐填充： 对齐填充不是必然存在的。HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的整数倍。因此，当对象实例数据部分没有对齐时，就需要通过对其补充来补全了。 三、对象的访问定位 Java程序需要通过栈上了reference数据来操作堆上的具体对象。 目前主流的访问方式有使用句柄和直接指针两种。 句柄访问： Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对实例数据与类型数据的各自具体的地址信息。 直接指针访问： reference中存储的直接就是对象地址。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:02 "},"java/virtual-machine/memory.html":{"url":"java/virtual-machine/memory.html","title":"Java内存区域与内存模型","keywords":"","body":"一、Java内存区域 方法区（公有）： 用户存储已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据。异常状态 OutOfMemoryError 其中包含常量池：用户存放编译器生成的各种字面量和符号引用。 堆（公有）： 是JVM所管理的内存中最大的一块。唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。异常状态 OutOfMemoryError 虚拟机栈（线程私有）： 描述的是java方法执行的内存模型：每个方法在执行时都会创建一个栈帧，用户存储局部变量表，操作数栈，动态连接，方法出口等信息。每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 对这个区域定义了两种异常状态 OutOfMemoryError StackOverflowError 本地方法栈（线程私有）: 与虚拟机栈所发挥的作用相似。它们之间的区别不过是虚拟机栈为虚拟机执行java方法，而本地方法栈为虚拟机使用到的Native方法服务。 程序计数器（线程私有）： 一块较小的内存，当前线程所执行的字节码的行号指示器。字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 二、Java内存模型 Java内存模型的目的： 屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。 主要目标： 定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java变成中所说的变量是有所区别，它包括了实例字段，静态字段和构成数组对象的元素，但不包括局部变量和方法参数。 Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了8种操作来完成，并且每种操作都是原子的、不可再分的。 八种操作： 类型 说明 lock 作用于主内存的变量，把一个变量标识为一条线程独占的状态 unlock 作用于主内存的变量，把一个处于锁定状态的变量释放出来。 read 把一个变量的值从主内存传输到工作内存中，以便随后的load使用。 load 把read操作从主内存中得到的变量值放入到工作内存的变量副本中。 use 把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 assign 把一个从执行引擎中接收到的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store 把工作内存中的一个变量的值传递到主内存，以便随后的write使用。 write 把store操作从工作内存中得到的变量值放入到主内存的变量中。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:02 "},"java/virtual-machine/classloader.html":{"url":"java/virtual-machine/classloader.html","title":"Java类加载机制及类加载器详解","keywords":"","body":"一、类加载机制 1.定义： 把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。 在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点来实现的。 2.类的生命周期： 加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接。 这7个阶段发生顺序如下图： 加载，验证，准备，初始化，卸载这5个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化完成后在开始，这是为了支持Java语言的运行时绑定。 其中加载，验证，准备，解析及初始化是属于类加载机制中的步骤。注意此处的加载不等同于类加载。 3.触发类加载的条件： ①.遇到new,getstatic,putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段的时候（被final修饰，已在编译期把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候。 ②.使用java.lang.reflect包的方法对类进行反射调用的时候。 ③.当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先出发父类的初始化。 ④.当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 ⑤.当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出发初始化。 4.类加载的具体过程： 加载: ①.通过一个类的全限定名来获取定义此类的二进制字节流 ②.将这个字节流所代表的静态存储结构转换为方法区内的运行时数据结构 ③.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 验证： 是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 包含四个阶段的校验动作 a.文件格式验证 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。 b.元数据验证 对类的元数据信息进行语义校验，是否不存在不符合Java语言规范的元数据信息 c.字节码验证 最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 d.符号引用验证 最后一个阶段的校验发生在虚拟机将符号引用转换为直接引用的时候，这个转换动作将在连接的第三个阶段——解析阶段中发生。 符号验证的目的是确保解析动作能正常进行。 准备： 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。这些变量所使用的内存都将在方法区中分配。只包括类变量。初始值“通常情况”下是数据类型的零值。 “特殊情况”下，如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段变量的值就会被初始化为ConstantValue属性所指定的值。 解析： 虚拟机将常量池内的符号引用替换为直接引用的过程。 “动态解析”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。 初始化： 类加载过程中的最后一步。 初始化阶段是执行类构造器()方法的过程。 ()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。 ()与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的()方法执行之前，父类的()方法已经执行完毕。 简单地说，初始化就是对类变量进行赋值及执行静态代码块。 二、类加载器 通过上述的了解，我们已经知道了类加载机制的大概流程及各个部分的功能。其中加载部分的功能是将类的class文件读入内存，并为之创建一个java.lang.Class对象。这部分功能就是由类加载器来实现的。 1.类加载器分类： 不同的类加载器负责加载不同的类。主要分为两类。 启动类加载器（Bootstrap ClassLoader）： 由C++语言实现（针对HotSpot）,负责将存放在\\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中，即负责加载Java的核心类。 其他类加载器： 由Java语言实现，继承自抽象类ClassLoader。如： 扩展类加载器（Extension ClassLoader）： 负责加载\\lib\\ext目录或java.ext.dirs系统变量指定的路径中的所有类库，即负责加载Java扩展的核心类之外的类。 应用程序类加载器（Application ClassLoader）： 负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器，通过ClassLoader.getSystemClassLoader()方法直接获取。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。 以上2大类，3小类类加载器基本上负责了所有Java类的加载。下面我们来具体了解上述几个类加载器实现类加载过程时相互配合协作的流程。 2.双亲委派模型 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 这样的好处是不同层次的类加载器具有不同优先级，比如所有Java对象的超级父类java.lang.Object，位于rt.jar，无论哪个类加载器加载该类，最终都是由启动类加载器进行加载，保证安全。即使用户自己编写一个java.lang.Object类并放入程序中，虽能正常编译，但不会被加载运行，保证不会出现混乱。 3.双亲委派模型的代码实现 ClassLoader中loadClass方法实现了双亲委派模型 protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { //检查该类是否已经加载过 Class c = findLoadedClass(name); if (c == null) { //如果该类没有加载，则进入该分支 long t0 = System.nanoTime(); try { if (parent != null) { //当父类的加载器不为空，则通过父类的loadClass来加载该类 c = parent.loadClass(name, false); } else { //当父类的加载器为空，则调用启动类加载器来加载该类 c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { //非空父类的类加载器无法找到相应的类，则抛出异常 } if (c == null) { //当父类加载器无法加载时，则调用findClass方法来加载该类 long t1 = System.nanoTime(); c = findClass(name); //用户可通过覆写该方法，来自定义类加载器 //用于统计类加载器相关的信息 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { //对类进行link操作 resolveClass(c); } return c; } } 整个流程大致如下： a.首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。 b.如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。 c.如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。 关于自定义类加载器，本篇文章就不介绍了，主要是重写findClass方法，有兴趣的可以参考这篇文章。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:02 "},"java/virtual-machine/Garbage-Collector.html":{"url":"java/virtual-machine/Garbage-Collector.html","title":"JVM中垃圾收集算法及垃圾收集器详解","keywords":"","body":"一、垃圾收集算法 1.标记-清除算法 最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段。 ①首先标记出所有需要回收的对象 ②在标记完成后统一回收所有被标记的对象。 不足： 效率问题：标记和清除两个过程的效率都不高 空间问题：标记清除之后产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 2.复制算法 目的： 为了解决效率问题。 将可用内存按容量大小划分为大小相等的两块，每次只使用其中的一块。当一块内存使用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。 缺点： 将内存缩小为了原来的一半。 现代的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中对象98%对象是“朝生夕死”的，所以不需要按照1：1的比例来划分内存空间，而是将内存分为较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。HotSpot虚拟机中默认Eden和Survivor的大小比例是8：1。 3.标记-整理算法 复制收集算法在对象存活率较高时，就要进行较多的复制操作，效率就会变低。 根据老年代的特点，提出了“标记-整理”算法。 标记过程仍然与”标记-清除“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。 4.分代收集算法 一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须采用“标记-清除”或“标记-整理”算法来进行回收。 二、垃圾回收机制的一些知识 1.JVM中的年代 JVM中分为年轻代（Young generation）和老年代(Tenured generation)。 HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1，为啥默认会是这个比例，接下来我们会聊到。 一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理)，这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。 因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 2.Minor GC和Full GC的区别 Minor GC:指发生在新生代的垃圾收集动作，该动作非常频繁。 Full GC/Major GC:指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。 3. 空间分配担保 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果这个条件成立，那么Minor GC可以 确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则将尝试进行一次Minor GC，尽管这个Minor GC是有风险的。如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 以上便是在垃圾回收过程中，需要了解的一些必要的知识。下面我们就来介绍具体的垃圾收集器。 三、垃圾收集器 上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，说明它们可以搭配使用。 1.Serial收集器 是最基本、发展历史最悠久的收集器。这是一个单线程收集器。但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。 是虚拟机运行在Client模式下的默认新生代收集器。 优势： 简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程效率。 2.ParNew收集器 ParNew收集器其实就是Serial收集器的多线程版本。 是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。 ParNew收集器默认开启的收集线程数与CPU的数量相同。 下图是ParNew/Serial Old收集器运行示意图 3.Parallel Scavenge收集器 Parallel Scavenge收集器是一个新生代收集器，使用复制算法，又是并行的多线程收集器。 最大的特点是： Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 4.Serial Old收集器 Serial Old是Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下虚拟机使用。 如果在Server模式下，它主要还有两大用途： 1.与Parallel Scavenge收集器搭配使用 2.作为CMS收集器的后备预案，在并发收集发生Conurrent Mode Failure使用。 5.Parallel Old收集器 Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。 在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old收集器 6.CMS（Concurrent Mark Sweep）收集器 是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。 关注点： 尽可能地缩短垃圾收集时用户线程的停顿时间。 CMS收集器是基于“标记-清除”算法实现的，整个过程分为4个步骤： ①初始标记 ②并发标记 ③重新标记 ④并发清除 其中，初始标记，重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只标记一下GC Roots能直接关联到的对象，速度很快。并发标记阶段就是 进行GC Roots Tracing的过程。 重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记几率，这个阶段的停顿时间一般会比初始标记阶段稍长，但远比并发标记时间短。 整个过程耗时最长的阶段是并发标记，并发清除过程，但这两个过程可以和用户线程一起工作。 缺点： ①CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。 ②CMS收集器无法处理浮动垃圾，可能出现“Conurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会产生新的垃圾，这一部分垃圾出现在标记过程之后，CMS无法在档次收集中处理掉它们，只好留待下一次GC时再清理掉。这部分垃圾就称为“浮动垃圾”。因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时程序运作使用。在JDK1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活。如果预留空间无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案Serial Old。 ③CMS是一款基于“标记-清除”算法实现的收集器，所以会有大量空间碎片问题。 7.G1收集器 是当今收集器技术发展的最前沿成果之一。是一款面向服务端应用的垃圾收集器。 特点： ①并行与并发 能充分利用多CPU，多核环境下的硬件优势，缩短Stop-The-World停顿的时间，同时可以通过并发的方式让Java程序继续执行 ②分代收集 可以不需要其他收集器的配合管理整个堆，但是仍采用不同的方式去处理分代的对象。 ③空间整合 G1从整体上来看，采用基于“标记-整理”算法实现收集器 G1从局部上来看，采用基于“复制”算法实现。 ④可预测停顿 使用G1收集器时，Java堆内存布局与其他收集器有很大差别，它将整个Java堆划分成为多个大小相等的独立区域。 G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:02 "},"java/virtual-machine/life-cycle.html":{"url":"java/virtual-machine/life-cycle.html","title":"JVM怎么判断对象是否已死？","keywords":"","body":"一、引用计数法 给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能被再使用的。 主流的JVM里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象间的互循环引用的问题。 二、可达性分析算法 通过一些列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时（就是从GC Roots 到这个对象是不可达），则证明此对象是不可用的。所以它们会被判定为可回收对象（例如图B中的对象既是不可达的）。 在Java语言中，可以作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量引用的对象； 本地方法栈中JNI（即一般说的Native方法）引用的对象； 总结就是，方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象；Native方法中引用的对象 在可达性分析算法中，要真正宣告一个对象死亡，至少要经历两次标记过程： 1.如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有 覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。 2.如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。finalize()方法是对象逃脱死亡命运的最后一次机会，稍候GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalie()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将会被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。 三、判断对象是否存活与“引用”有关 在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。 强引用： 就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用： 用来描述一些还有用但并非必须的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。 弱引用： 用户描述非必须对象的。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 虚引用： 一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时刻得到一个系统通知。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:02 "},"design-mode/Builder-Pattern.html":{"url":"design-mode/Builder-Pattern.html","title":"创建型模式","keywords":"","body":"一、前言 创建型模式 创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。 创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。 包含模式 简单工厂模式（Simple Factory） 工厂方法模式（Factory Method） 抽象工厂模式（Abstract Factory） 建造者模式（Builder） 原型模式（Prototype） 单例模式（Singleton） 二、目录 本部分没有包含以上所有模式，仅介绍了几种常用的。 简单工厂模式 工厂方法模式 抽象工厂模式 单例模式 建造者模式 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Builder-Pattern/Simple-Factory.html":{"url":"design-mode/Builder-Pattern/Simple-Factory.html","title":"简单工厂模式","keywords":"","body":"一、简单工厂模式简介 1.定义 简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 2.使用动机 考虑一个简单的软件应用场景：一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观。 如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。 二、简单工厂模式结构 1.模式结构 简单工厂模式包含如下角色： ●Factory：工厂角色工厂角色负责实现创建所有实例的内部逻辑 ●Product：抽象产品角色抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 ●ConcreteProduct：具体产品角色具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 2.时序图 ①先调用工厂类中的静态方法createProduct() ②根据传入产品类型参数，获得具体的产品对象 ③返回产品对象并使用 三、简单工厂的使用实例 以登录功能来说，假如应用系统需要支持多种登录方式如：口令认证、域认证（口令认证通常是去数据库中验证用户，而域认证则是需要到微软的域中验证用户）。那么自然的做法就是建立一个各种登录方式都适用的接口，如下图所示： 抽象产品Login public interface Login { //登录验证 public boolean verify(String name , String password); } 具体产品DomainLogin public class DomainLogin implements Login { @Override public boolean verify(String name, String password) { // TODO Auto-generated method stub /** * 业务逻辑 */ return true; } } 具体产品PasswordLogin public class PasswordLogin implements Login { @Override public boolean verify(String name, String password) { // TODO Auto-generated method stub /** * 业务逻辑 */ return true; } } 工厂类LoginManager根据调用者不同的要求，创建出不同的登录对象并返回。而如果碰到不合法的要求，会返回一个Runtime异常。 public class LoginManager { public static Login factory(String type){ if(type.equals(\"password\")){ return new PasswordLogin(); }else if(type.equals(\"passcode\")){ return new DomainLogin(); }else{ /** * 这里抛出一个自定义异常会更恰当 */ throw new RuntimeException(\"没有找到登录类型\"); } } } 测试调用 public class Test { public static void main(String[] args) { String loginType = \"password\"; String name = \"name\"; String password = \"password\"; Login login = LoginManager.factory(loginType); boolean bool = login.verify(name, password); if (bool) { /** * 业务逻辑 */ } else { /** * 业务逻辑 */ } } } 假如不使用简单工厂模式则验证登录Servlet代码如下： public class Test { public static void main(String[] args) { // TODO Auto-generated method stub String loginType = \"password\"; String name = \"name\"; String password = \"password\"; //处理口令认证 if(loginType.equals(\"password\")){ PasswordLogin passwordLogin = new PasswordLogin(); boolean bool = passwordLogin.verify(name, password); if (bool) { /** * 业务逻辑 */ } else { /** * 业务逻辑 */ } } //处理域认证 else if(loginType.equals(\"passcode\")){ DomainLogin domainLogin = new DomainLogin(); boolean bool = domainLogin.verify(name, password); if (bool) { /** * 业务逻辑 */ } else { /** * 业务逻辑 */ } }else{ /** * 业务逻辑 */ } } } 可以看到非常麻烦，代码重复很多，而且不利于扩展维护。 四、简单工厂模式优缺点 优点： 通过使用工厂类，外界不再需要关心如何创造各种具体的产品，只要提供一个产品的名称作为参数传给工厂，就可以直接得到一个想要的产品对象，并且可以按照接口规范来调用产品对象的所有功能（方法）。 构造容易，逻辑简单。 缺点： 1.简单工厂模式中的if else判断非常多，完全是Hard Code，如果有一个新产品要加进来，就要同时添加一个新产品类，并且必须修改工厂类，再加入一个 else if 分支才可以， 这样就违背了 “开放-关闭原则”中的对修改关闭的准则了。当系统中的具体产品类不断增多时候，就要不断的修改工厂类，对系统的维护和扩展不利。 2.一个工厂类中集合了所有的类的实例创建逻辑，违反了高内聚的责任分配原则，将全部的创建逻辑都集中到了一个工厂类当中，所有的业务逻辑都在这个工厂类中实现。什么时候它不能工作了，整个系统都会受到影响。因此一般只在很简单的情况下应用，比如当工厂类负责创建的对象比较少时。 3.简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 适用环境 在以下情况下可以使用简单工厂模式： 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 五、简单工厂模式在Java中的应用 ①JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。 public final static DateFormat getDateInstance(); public final static DateFormat getDateInstance(int style); public final static DateFormat getDateInstance(int style,Locale locale); ②Java加密技术获取不同加密算法的密钥生成器: KeyGenerator keyGen=KeyGenerator.getInstance(\"DESede\"); 创建密码器: Cipher cp=Cipher.getInstance(\"DESede\"); Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Builder-Pattern/Factory-Method.html":{"url":"design-mode/Builder-Pattern/Factory-Method.html","title":"工厂方法模式","keywords":"","body":"一、工厂方法模式简介 1.定义 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。 在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 2.使用动机 现在对该系统（上篇文章提到）进行修改，不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成。 我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。 二、工厂方法模式结构 1.模式结构 工厂方法模式包含如下角色： ●Product：抽象产品，工厂方法模式所创建的对象的超类，也就是所有产品类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。 ●ConcreteProduct：具体产品，这个角色实现了抽象产品（Product）所声明的接口，工厂方法模式所创建的每一个对象都是某个具体产品的实例。 ●Factory：抽象工厂，担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。 ●ConcreteFactory：具体工厂，担任这个角色的是实现了抽象工厂接口的具体Java类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建具体产品对象。 2.时序图 ①先调用具体工厂对象中的方法createProduct() ②根据传入产品类型参数（也可以无参），获得具体的产品对象 ③返回产品对象并使用 三、工厂方法模式的使用实例 上面的类图中，在灯这个品类下，有灯泡和灯管两种产品，并且都实现了灯的通用方法：关灯和开灯。在工厂类下，有各种生产具体产品的子工厂负责生产相应的两种灯具。 如果还不是太明白，那我们来假设一个情景。小明（客户端）想要买一个灯泡，他不认识工厂，只能去供销店（工厂类）买，于是和老板说“我要一个灯泡”，老板说 “没问题！您稍等”。转身到了后院，对生产灯泡的小弟（灯泡工厂子类）吆喝一声，给我造个灯泡！不一会灯泡造好了，老板拿给小明，“嘿嘿，灯泡给您作了一个，您试试？”，小明把灯泡拧在灯口上，开关了两下（灯的通用方法）“嘿！挺好，没问题！”，付了钱高高兴兴走了。 抽象的产品接口ILight public interface ILight { void TurnOn(); void TurnOff(); } 具体的产品类：BulbLight public class BulbLight implements ILight { public void TurnOn() { Console.WriteLine(\"BulbLight turns on.\"); } public void TurnOff() { Console.WriteLine(\"BulbLight turns off.\"); } } 具体的产品类：TubeLight public class TubeLight implements ILight { public void TurnOn() { Console.WriteLine(\"TubeLight turns on.\"); } public void TurnOff() { Console.WriteLine(\"TubeLight turns off.\"); } } 抽象的工厂类 public interface ICreator { ILight CreateLight(); } 具体的工厂类:BulbCreator public class BulbCreator implements ICreator { public ILight CreateLight() { return new BulbLight(); } } 具体的工厂类:TubeCreator public class TubeCreator implements ICreator { public ILight CreateLight() { return new TubeLight(); } } 客户端调用 static void Main(string[] args) { //先给我来个灯泡 ICreator creator = new BulbCreator(); ILight light = creator.CreateLight(); light.TurnOn(); light.TurnOff(); //再来个灯管看看 creator = new TubeCreator(); light = creator.CreateLight(); light.TurnOn(); light.TurnOff(); } 通过一个引用变量ICreator来创建产品对象，创建何种产品对象由指向的具体工厂类决定。通过工厂方法模式，将具体的应用逻辑和产品的创建分离开，促进松耦合。 本例中每个具体工厂类只负责生产一种类型的产品，当然每个具体工厂类也内部可以维护少数几种产品实例对象，类似于简单工厂模式。 四、工厂方法模式的优缺点 优点 ①在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 ②基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 ③使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”，这点比简单工厂模式更优秀。 缺点 ①在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 ②由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 适用场景 在以下情况下可以使用工厂方法模式： ①一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。 ②一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 ③将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 五、工厂方法模式在Java中应用 JDBC中的工厂方法: Connection conn=DriverManager.getConnection(\"jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=DB;user=sa;password=\"); Statement statement=conn.createStatement(); ResultSet rs=statement.executeQuery(\"select * from UserInfo\"); Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Builder-Pattern/Abstract-Factory.html":{"url":"design-mode/Builder-Pattern/Abstract-Factory.html","title":"抽象工厂模式","keywords":"","body":"一、抽象工厂模式简介 1.定义 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 定义很难懂？没错，看起来是很抽象，不过这正反应了这种模式的强大。下面具体阐述下定义。 2.定义阐述 在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种或几种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个不同种类产品对象，而不是单一种类的产品对象。 为了更清晰地理解工厂方法模式，需要先引入两个概念： 产品等级结构： 产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族： 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。 二、抽象工厂模式结构 1.模式结构 抽象工厂模式包含如下角色： AbstractFactory：抽象工厂ConcreteFactory：具体工厂AbstractProduct：抽象产品Product：具体产品 2.时序图 ①先调用具体工厂对象中的方法createProductX()。根据具体工厂不同可以选择不同的方法，针对同一种工厂也可以选择不同的方法创建不同类型的产品对象。 ②根据传入产品类型参数（也可以无参），获得具体的产品对象 ③返回产品对象并使用 三、抽象工厂的使用实例 假设有一个移动终端工厂，可以制造苹果系列的移动产品和三星系列的移动产品。这个工厂下有两个子厂，一个负责制造苹果系列的Pad和三星系列的Pad，另一个负责制造苹果系列的手机和三星系列的手机。这便是一个典型的抽象工厂的实例。抽象产品： 苹果系列 public interface Apple { void AppleStyle(); } 抽象产品： 三星系列 public interface Sumsung { void BangziStyle(); } 具体产品：iphone public class iphone implements Apple { public void AppleStyle() { Console.WriteLine(\"Apple's style: iPhone!\"); } } 具体产品：ipad public class ipad implements Apple { public void AppleStyle() { Console.WriteLine(\"Apple's style: iPad!\"); } } 具体产品：note2 public class note2 implements Sumsung { public void BangziStyle() { Console.WriteLine(\"Bangzi's style : Note2!\"); } } 具体产品：tabs public class Tabs implements Sumsung { public void BangziStyle() { Console.WriteLine(\"Bangzi's style : Tab!\"); } } 抽象工厂 public interface Factory { Apple createAppleProduct(); Sumsung createSumsungProduct(); } 手机工厂 public class Factory_Phone implements Factory { public Apple createAppleProduct() { return new iphone(); } public Sumsung createSumsungProduct() { return new note2(); } } pad工厂 public class Factory_Pad implements Factory { public Apple createAppleProduct() { return new ipad(); } public Sumsung createSumsungProduct() { return new Tabs(); } } 客户端调用 public static void Main(string[] args) { //采购商要一台iPad和一台Tab Factory factory = new Factory_Pad(); Apple apple = factory.createAppleProduct(); apple.AppleStyle(); Sumsung sumsung = factory.createSumsungProduct(); sumsung.BangziStyle(); //采购商又要一台iPhone和一台Note2 factory = new Factory_Phone(); apple = factory.createAppleProduct(); apple.AppleStyle(); sumsung = factory.createSumsungProduct(); sumsung.BangziStyle(); Console.ReadKey(); } 抽象工厂可以通过多态，来动态设置不同的工厂，生产不同的产品，同时每个工厂中的产品又不属于同一个产品等级结构。 四、抽象工厂模式优缺点 优点 ①抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。 ②增加新的具体工厂和产品族很方便，因为一个具体的工厂实现代表的是一个产品族，无须修改已有系统，符合“开闭原则”。 缺点 在添加新的产品对象（不同于现有的产品等级结构）时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。 适用环境 在以下情况下可以使用抽象工厂模式： ①一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。 ②系统中有多于一个的产品族，而每次只使用其中某一产品族。与工厂方法模式的区别 ③属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。 ④系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Builder-Pattern/Singleton-Pattern.html":{"url":"design-mode/Builder-Pattern/Singleton-Pattern.html","title":"单例模式","keywords":"","body":"一、单例模式 1.定义 作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。 2.特点 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 二、创建单例模式的方式 ①懒汉式，线程不安全 懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。 public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。 ②懒汉式，线程安全 为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } 虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。 ③双重检验锁 双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。 public static Singleton getSingleton() { if (instance == null) { //Single Checked synchronized (Singleton.class) { if (instance == null) { //Double Checked instance = new Singleton(); } } } return instance ; } 这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情: 1.给 instance 分配内存 2.调用 Singleton 的构造函数来初始化成员变量 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。 我们只需要将 instance 变量声明成 volatile 就可以了。 public class Singleton { private volatile static Singleton instance; //声明成 volatile private Singleton (){} public static Singleton getSingleton() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。 从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。 但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。 相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。 ④饿汉式 static final field 饿汉式其实是一种比较形象的称谓。既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。 这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。 public class Singleton{ //类加载时就初始化 private static final Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; } } 缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。 饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。 ⑤静态内部类 static nested class 这种方法也是《Effective Java》上所推荐的。 public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 这种写法仍然使用JVM本身机制保证了线程安全问题。由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类SingletonHolder，在该内部类中定义了一个static类型的变量INSTANCE ，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。 由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。 ⑥枚举 Enum 用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。 public enum EasySingleton{ INSTANCE; } 我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。 三、总结 一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，上文中第一种方式线程不安全，排除。 一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）倾向于使用静态内部类。如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Builder-Pattern/Builder-Pattern.html":{"url":"design-mode/Builder-Pattern/Builder-Pattern.html","title":"建造者模式","keywords":"","body":"一、模式定义 造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。 二、模式结构 建造者模式包含如下角色： Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：指挥者 Product：产品角色 三、时序图 四、简单实现 电脑的组装过程较为复杂，步骤繁多，但是顺序却是不固定的。下面我们以组装电脑为例来演示一下简单且经典的builder模式 package com.dp.example.builder; /** * Computer产品抽象类, 为了例子简单, 只列出这几个属性 * * @author mrsimple * */ public abstract class Computer { protected int mCpuCore = 1; protected int mRamSize = 0; protected String mOs = \"Dos\"; protected Computer() { } // 设置CPU核心数 public abstract void setCPU(int core); // 设置内存 public abstract void setRAM(int gb); // 设置操作系统 public abstract void setOs(String os); @Override public String toString() { return \"Computer [mCpuCore=\" + mCpuCore + \", mRamSize=\" + mRamSize + \", mOs=\" + mOs + \"]\"; } } package com.dp.example.builder; /** * Apple电脑 */ public class AppleComputer extends Computer { protected AppleComputer() { } @Override public void setCPU(int core) { mCpuCore = core; } @Override public void setRAM(int gb) { mRamSize = gb; } @Override public void setOs(String os) { mOs = os; } } package com.dp.example.builder; package com.dp.example.builder; /** * builder抽象类 * */ public abstract class Builder { // 设置CPU核心数 public abstract void buildCPU(int core); // 设置内存 public abstract void buildRAM(int gb); // 设置操作系统 public abstract void buildOs(String os); // 创建Computer public abstract Computer create(); } package com.dp.example.builder; public class ApplePCBuilder extends Builder { private Computer mApplePc = new AppleComputer(); @Override public void buildCPU(int core) { mApplePc.setCPU(core); } @Override public void buildRAM(int gb) { mApplePc.setRAM(gb); } @Override public void buildOs(String os) { mApplePc.setOs(os); } @Override public Computer create() { return mApplePc; } } package com.dp.example.builder; public class Director { Builder mBuilder = null; /** * * @param builder */ public Director(Builder builder) { mBuilder = builder; } /** * 构建对象 * * @param cpu * @param ram * @param os */ public void construct(int cpu, int ram, String os) { mBuilder.buildCPU(cpu); mBuilder.buildRAM(ram); mBuilder.buildOs(os); } } /** * 经典实现较为繁琐 * * @author mrsimple * */ public class Test { public static void main(String[] args) { // 构建器 Builder builder = new ApplePCBuilder(); // Director Director pcDirector = new Director(builder); // 封装构建过程, 4核, 内存2GB, Mac系统 pcDirector.construct(4, 2, \"Mac OS X 10.9.1\"); // 构建电脑, 输出相关信息 System.out.println(\"Computer Info : \" + builder.create().toString()); } } 五、Android源码中模式实现 在Android源码中，我们最常用到的Builder模式就是AlertDialog.Builder， 使用该Builder来构建复杂的AlertDialog对象。简单示例如下 : //显示基本的AlertDialog private void showDialog(Context context) { AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setIcon(R.drawable.icon); builder.setTitle(\"Title\"); builder.setMessage(\"Message\"); builder.setPositiveButton(\"Button1\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int whichButton) { setTitle(\"点击了对话框上的Button1\"); } }); builder.setNeutralButton(\"Button2\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int whichButton) { setTitle(\"点击了对话框上的Button2\"); } }); builder.setNegativeButton(\"Button3\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int whichButton) { setTitle(\"点击了对话框上的Button3\"); } }); builder.create().show(); // 构建AlertDialog， 并且显示 } 结果 : 下面我们看看AlertDialog的相关源码 : // AlertDialog public class AlertDialog extends Dialog implements DialogInterface { // Controller, 接受Builder成员变量P中的各个参数 private AlertController mAlert; // 构造函数 protected AlertDialog(Context context, int theme) { this(context, theme, true); } // 4 : 构造AlertDialog AlertDialog(Context context, int theme, boolean createContextWrapper) { super(context, resolveDialogTheme(context, theme), createContextWrapper); mWindow.alwaysReadCloseOnTouchAttr(); mAlert = new AlertController(getContext(), this, getWindow()); } // 实际上调用的是mAlert的setTitle方法 @Override public void setTitle(CharSequence title) { super.setTitle(title); mAlert.setTitle(title); } // 实际上调用的是mAlert的setCustomTitle方法 public void setCustomTitle(View customTitleView) { mAlert.setCustomTitle(customTitleView); } public void setMessage(CharSequence message) { mAlert.setMessage(message); } // AlertDialog其他的代码省略 // ************ Builder为AlertDialog的内部类 ******************* public static class Builder { // 1 : 存储AlertDialog的各个参数, 例如title, message, icon等. private final AlertController.AlertParams P; // 属性省略 /** * Constructor using a context for this builder and the {@link AlertDialog} it creates. */ public Builder(Context context) { this(context, resolveDialogTheme(context, 0)); } public Builder(Context context, int theme) { P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, theme))); mTheme = theme; } // Builder的其他代码省略 ...... // 2 : 设置各种参数 public Builder setTitle(CharSequence title) { P.mTitle = title; return this; } public Builder setMessage(CharSequence message) { P.mMessage = message; return this; } public Builder setIcon(int iconId) { P.mIconId = iconId; return this; } public Builder setPositiveButton(CharSequence text, final OnClickListener listener) { P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this; } public Builder setView(View view) { P.mView = view; P.mViewSpacingSpecified = false; return this; } // 3 : 构建AlertDialog, 传递参数 public AlertDialog create() { // 调用new AlertDialog构造对象， 并且将参数传递个体AlertDialog final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false); // 5 : 将P中的参数应用的dialog中的mAlert对象中 P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) { dialog.setCanceledOnTouchOutside(true); } dialog.setOnCancelListener(P.mOnCancelListener); if (P.mOnKeyListener != null) { dialog.setOnKeyListener(P.mOnKeyListener); } return dialog; } } } 可以看到，通过Builder来设置AlertDialog中的title, message, button等参数， 这些参数都存储在类型为AlertController.AlertParams的成员变量P中，AlertController.AlertParams中包含了与之对应的成员变量。在调用Builder类的create函数时才创建AlertDialog, 并且将Builder成员变量P中保存的参数应用到AlertDialog的mAlert对象中，即P.apply(dialog.mAlert)代码段。我们看看apply函数的实现 : public void apply(AlertController dialog) { if (mCustomTitleView != null) { dialog.setCustomTitle(mCustomTitleView); } else { if (mTitle != null) { dialog.setTitle(mTitle); } if (mIcon != null) { dialog.setIcon(mIcon); } if (mIconId >= 0) { dialog.setIcon(mIconId); } if (mIconAttrId > 0) { dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId)); } } if (mMessage != null) { dialog.setMessage(mMessage); } if (mPositiveButtonText != null) { dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText, mPositiveButtonListener, null); } if (mNegativeButtonText != null) { dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText, mNegativeButtonListener, null); } if (mNeutralButtonText != null) { dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText, mNeutralButtonListener, null); } if (mForceInverseBackground) { dialog.setInverseBackgroundForced(true); } // For a list, the client can either supply an array of items or an // adapter or a cursor if ((mItems != null) || (mCursor != null) || (mAdapter != null)) { createListView(dialog); } if (mView != null) { if (mViewSpacingSpecified) { dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight, mViewSpacingBottom); } else { dialog.setView(mView); } } } 实际上就是把P中的参数挨个的设置到AlertController中， 也就是AlertDialog中的mAlert对象。从AlertDialog的各个setter方法中我们也可以看到，实际上也都是调用了mAlert对应的setter方法。在这里，Builder同时扮演了上文中提到的builder、ConcreteBuilder、Director的角色，简化了Builder模式的设计。 六、优缺点 优点 良好的封装性， 使用建造者模式可以使客户端不必知道产品内部组成的细节； 建造者独立，容易扩展； 在对象创建过程中会使用到系统中的一些其它对象，这些对象在产品对象的创建过程中不易得到。 缺点 会产生多余的Builder对象以及Director对象，消耗内存； 对象的构建过程暴露。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Structural-Patterns.html":{"url":"design-mode/Structural-Patterns.html","title":"结构型模式","keywords":"","body":"一、前言 结构型模式 结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。 结构型模式可以分为类结构型模式和对象结构型模式： 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。 对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。 包含模式 适配器模式(Adapter) 桥接模式(Bridge) 组合模式(Composite) 装饰模式(Decorator) 外观模式(Facade) 享元模式(Flyweight) 代理模式(Proxy) 二、目录 本部分没有包含以上所有模式，仅介绍了几种常用的。 适配器模式 外观模式 装饰者模式 代理模式 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Structural-Patterns/Adapter-Pattern.html":{"url":"design-mode/Structural-Patterns/Adapter-Pattern.html","title":"适配器模式","keywords":"","body":"一、适配器模式简介 1.定义 适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 2.定义阐述 适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。 例如：　用电器做例子，笔记本电脑的插头一般都是三相的，即除了阳极、阴极外，还有一个地极。而有些地方的电源插座却只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。 二、适配器模式结构 适配器模式有类的适配器模式和对象的适配器模式两种不同的形式。 类适配器模式 类的适配器模式把适配的类的API转换成为目标类的API。 在上图中可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，提供一个中间环节，即类Adapter，把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的： 模式所涉及的角色有： ●　　目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。 ●　　源(Adapee)角色：现在需要适配的接口。 ●　　适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。 public interface Target { /** * 这是源类Adaptee也有的方法 */ public void sampleOperation1(); /** * 这是源类Adapteee没有的方法 */ public void sampleOperation2(); } 上面给出的是目标角色的源代码，这个角色是以一个JAVA接口的形式实现的。可以看出，这个接口声明了两个方法：sampleOperation1()和sampleOperation2()。而源角色Adaptee是一个具体类，它有一个sampleOperation1()方法，但是没有sampleOperation2()方法。 public class Adaptee { public void sampleOperation1(){} } 适配器角色Adapter扩展了Adaptee,同时又实现了目标(Target)接口。由于Adaptee没有提供sampleOperation2()方法，而目标接口又要求这个方法，因此适配器角色Adapter实现了这个方法。 public class Adapter extends Adaptee implements Target { /** * 由于源类Adaptee没有方法sampleOperation2() * 因此适配器补充上这个方法 */ @Override public void sampleOperation2() { //写相关的代码 } } 对象适配器模式 与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。 从上图可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，需要提供一个包装(Wrapper)类Adapter。这个包装类包装了一个Adaptee的实例，从而此包装类能够把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是委派关系，这决定了适配器模式是对象的。 public interface Target { /** * 这是源类Adaptee也有的方法 */ public void sampleOperation1(); /** * 这是源类Adapteee没有的方法 */ public void sampleOperation2(); } public class Adaptee { public void sampleOperation1(){} } public class Adapter { private Adaptee adaptee; public Adapter(Adaptee adaptee){ this.adaptee = adaptee; } /** * 源类Adaptee有方法sampleOperation1 * 因此适配器类直接委派即可 */ public void sampleOperation1(){ this.adaptee.sampleOperation1(); } /** * 源类Adaptee没有方法sampleOperation2 * 因此由适配器类需要补充此方法 */ public void sampleOperation2(){ //写相关的代码 } } 时序图 三、类适配器和对象适配器的权衡 ●　　类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。 ●　　对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了。 ●　　对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。 ●　 对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。 ●　 对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。 ●　　对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。 ●　　对于对象适配器，需要额外的引用来间接得到Adaptee。 建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。 四、缺省适配器 缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。 五、Java中适配器模式的使用 JDK1.1 之前提供的容器有 Arrays,Vector,Stack,Hashtable,Properties,BitSet，其中定义了一种访问群集内各元素的标准方式，称为 Enumeration（列举器）接口。 Vector v=new Vector(); for (Enumeration enum =v.elements(); enum.hasMoreElements();) { Object o = enum.nextElement(); processObject(o); } JDK1.2 版本中引入了 Iterator 接口，新版本的集合对（HashSet,HashMap,WeakHeahMap,ArrayList,TreeSet,TreeMap, LinkedList）是通过 Iterator 接口访问集合元素。 List list=new ArrayList(); for(Iterator it=list.iterator();it.hasNext();){ System.out.println(it.next()); } 这样，如果将老版本的程序运行在新的 Java 编译器上就会出错。因为 List 接口中已经没有 elements()，而只有 iterator() 了。那么如何将老版本的程序运行在新的 Java 编译器上呢? 如果不加修改，是肯定不行的，但是修改要遵循“开－闭”原则。我们可以用 Java 设计模式中的适配器模式解决这个问题。 public class NewEnumeration implements Enumeration { Iterator it; public NewEnumeration(Iterator it) { this.it = it; } public boolean hasMoreElements() { return it.hasNext(); } public Object nextElement() { return it.next(); } public static void main(String[] args) { List list = new ArrayList(); list.add(\"a\"); list.add(\"b\"); list.add(\"C\"); for (Enumeration e = new NewEnumeration(list.iterator()); e.hasMoreElements(); ) { System.out.println(e.nextElement()); } } } NewEnumeration 是一个适配器类，通过它实现了从 Iterator 接口到 Enumeration 接口的适配，这样我们就可以使用老版本的代码来使用新的集合对象了。 六、Android中适配器模式的使用 在开发过程中,ListView的Adapter是我们最为常见的类型之一。一般的用法大致如下: // 代码省略 ListView myListView = (ListView) findViewById(listview_id); // 设置适配器 myListView.setAdapter(new MyAdapter(context,myDatas)); // 适配器 public class MyAdapter extends BaseAdapter { private LayoutInflater mInflater; List mDatas; public MyAdapter(Context context, List datas) { this.mInflater = LayoutInflater.from(context); mDatas = datas; } @Override public int getCount() { return mDatas.size(); } @Override public String getItem(int pos) { return mDatas.get(pos); } @Override public long getItemId(int pos) { return pos; } // 解析、设置、缓存convertView以及相关内容 @Override public View getView(int position, View convertView, ViewGroup parent) { ViewHolder holder = null; // Item View的复用 if (convertView == null) { holder = new ViewHolder(); convertView = mInflater.inflate(R.layout.my_listview_item, null); // 获取title holder.title = (TextView) convertView.findViewById(R.id.title); convertView.setTag(holder); } else { holder = (ViewHolder) convertView.getTag(); } holder.title.setText(mDatas.get(position)); return convertView; } } 我们知道，作为最重要的View，ListView需要能够显示各式各样的视图，每个人需要的显示效果各不相同，显示的数据类型、数量等也千变万化。那么如何隔离这种变化尤为重要。 Android的做法是增加一个Adapter层来应对变化，将ListView需要的接口抽象到Adapter对象中，这样只要用户实现了Adapter的接口，ListView就可以按照用户设定的显示效果、数量、数据来显示特定的Item View。 通过代理数据集来告知ListView数据的个数( getCount函数 )以及每个数据的类型( getItem函数 )，最重要的是要解决Item View的输出。Item View千变万化，但终究它都是View类型，Adapter统一将Item View输出为View ( getView函数 )，这样就很好的应对了Item View的可变性。 那么ListView是如何通过Adapter模式 ( 不止Adapter模式 )来运作的呢 ？我们一起来看一看。ListView继承自AbsListView，Adapter定义在AbsListView中，我们看一看这个类。 public abstract class AbsListView extends AdapterView implements TextWatcher, ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener, ViewTreeObserver.OnTouchModeChangeListener, RemoteViewsAdapter.RemoteAdapterConnectionCallback { ListAdapter mAdapter; // 关联到Window时调用的函数 @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); // 代码省略 // 给适配器注册一个观察者。 if (mAdapter != null&& mDataSetObserver == null){ mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver); // Data may have changed while we were detached. Refresh. mDataChanged = true; mOldItemCount = mItemCount // 获取Item的数量,调用的是mAdapter的getCount方法 mItemCount = mAdapter.getCount(); } mIsAttached = true; } /** * 子类需要覆写layoutChildren()函数来布局child view,也就是Item View */ @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { super.onLayout(changed, l, t, r, b); mInLayout = true; if (changed) { int childCount = getChildCount(); for (int i = 0; i 通过增加Adapter一层来将Item View的操作抽象起来，ListView等集合视图通过Adapter对象获得Item的个数、数据元素、Item View等，从而达到适配各种数据、各种Item视图的效果。 因为Item View和数据类型千变万化，Android的架构师们将这些变化的部分交给用户来处理，通过getCount、getItem、getView等几个方法抽象出来，也就是将Item View的构造过程交给用户来处理，灵活地运用了适配器模式，达到了无限适配、拥抱变化的目的。 七、适配器模式的优缺点 适配器模式的优点 更好的复用性 系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。 更好的扩展性 在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。 适配器模式的缺点 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Structural-Patterns/Facade-Pattern.html":{"url":"design-mode/Structural-Patterns/Facade-Pattern.html","title":"外观模式","keywords":"","body":"一、外观模式概述 1.定义 外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 2.定义阐述 医院的例子 现代的软件系统都是比较复杂的，设计师处理复杂系统的一个常见方法便是将其“分而治之”，把一个系统划分为几个较小的子系统。如果把医院作为一个子系统，按照部门职能，这个系统可以划分为挂号、门诊、划价、化验、收费、取药等。看病的病人要与这些部门打交道，就如同一个子系统的客户端与一个子系统的各个类打交道一样，不是一件容易的事情。 首先病人必须先挂号，然后门诊。如果医生要求化验，病人必须首先划价，然后缴费，才可以到化验部门做化验。化验后再回到门诊室。 上图描述的是病人在医院里的体验，图中的方框代表医院。 解决这种不便的方法便是引进外观模式，医院可以设置一个接待员的位置，由接待员负责代为挂号、划价、缴费、取药等。这个接待员就是外观模式的体现，病人只接触接待员，由接待员与各个部门打交道。 二、外观模式结构 外观模式没有一个一般化的类图描述，最好的描述方法实际上就是以一个例子说明。 由于门面模式的结构图过于抽象，因此把它稍稍具体点。假设子系统内有三个模块，分别是ModuleA、ModuleB和ModuleC，它们分别有一个示例方法，那么此时示例的整体结构图如下： 在这个对象图中，出现了两个角色：●　　外观(Facade)角色 ：客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。 ●　　子系统(SubSystem)角色 ：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合（如上面的子系统就是由ModuleA、ModuleB、ModuleC三个类组合而成）。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。 时序图 子系统角色中的类： public class ModuleA { //示意方法 public void testA(){ System.out.println(\"调用ModuleA中的testA方法\"); } } public class ModuleB { //示意方法 public void testB(){ System.out.println(\"调用ModuleB中的testB方法\"); } } public class ModuleC { //示意方法 public void testC(){ System.out.println(\"调用ModuleC中的testC方法\"); } } 外观角色类: public class Facade { //示意方法，满足客户端需要的功能 public void test(){ ModuleA a = new ModuleA(); a.testA(); ModuleB b = new ModuleB(); b.testB(); ModuleC c = new ModuleC(); c.testC(); } } 客户端角色类： public class Client { public static void main(String[] args) { Facade facade = new Facade(); facade.test(); } } Facade类其实相当于A、B、C模块的外观界面，有了这个Facade类，那么客户端就不需要亲自调用子系统中的A、B、C模块了，也不需要知道系统内部的实现细节，甚至都不需要知道A、B、C模块的存在，客户端只需要跟Facade类交互就好了，从而更好地实现了客户端和子系统中A、B、C模块的解耦，让客户端更容易地使用系统。 三、外观模式的扩展 使用外观模式还有一个附带的好处，就是能够有选择性地暴露方法。一个模块中定义的方法可以分成两部分，一部分是给子系统外部使用的，一部分是子系统内部模块之间相互调用时使用的。有了Facade类，那么用于子系统内部模块之间相互调用的方法就不用暴露给子系统外部了。 比如，定义如下A、B、C模块。 public class Module { /** * 提供给子系统外部使用的方法 */ public void a1(){}; /** * 子系统内部模块之间相互调用时使用的方法 */ public void a2(){}; public void a3(){}; } public class ModuleB { /** * 提供给子系统外部使用的方法 */ public void b1(){}; /** * 子系统内部模块之间相互调用时使用的方法 */ public void b2(){}; public void b3(){}; } public class ModuleC { /** * 提供给子系统外部使用的方法 */ public void c1(){}; /** * 子系统内部模块之间相互调用时使用的方法 */ public void c2(){}; public void c3(){}; } public class ModuleFacade { ModuleA a = new ModuleA(); ModuleB b = new ModuleB(); ModuleC c = new ModuleC(); /** * 下面这些是A、B、C模块对子系统外部提供的方法 */ public void a1(){ a.a1(); } public void b1(){ b.b1(); } public void c1(){ c.c1(); } } 这样定义一个ModuleFacade类可以有效地屏蔽内部的细节，免得客户端去调用Module类时，发现一些不需要它知道的方法。比如a2()和a3()方法就不需要让客户端知道，否则既暴露了内部的细节，又让客户端迷惑。 一个系统可以有几个外观类 在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只有一个外观类，而仅仅是说对每一个子系统只有一个外观类。或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个外观类，整个系统可以有数个外观类。 为子系统增加新行为 初学者往往以为通过继承一个外观类便可在子系统中加入新的行为，这是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。比如医院中的接待员并不是医护人员，接待员并不能为病人提供医疗服务。 四、外观模式的实例 1.实例说明 某软件公司欲开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括三个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这三个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这三个操作的业务代码封装在三个不同的类中。 2.实例类图 EncryptFacade充当外观类，FileReader、CipherMachine和FileWriter充当子系统类。 3.实例代码 FileReader：文件读取类，充当子系统类。 class FileReader { public string Read(string fileNameSrc) { Console.Write(\"读取文件，获取明文：\"); FileStream fs = null; StringBuilder sb = new StringBuilder(); try { fs = new FileStream(fileNameSrc, FileMode.Open); int data; while((data = fs.ReadByte())!= -1) { sb = sb.Append((char)data); } fs.Close(); Console.WriteLine(sb.ToString()); } catch(FileNotFoundException e) { Console.WriteLine(\"文件不存在！\"); } catch(IOException e) { Console.WriteLine(\"文件操作错误！\"); } return sb.ToString(); } } CipherMachine：数据加密类，充当子系统类。 class CipherMachine { public string Encrypt(string plainText) { Console.Write(\"数据加密，将明文转换为密文：\"); string es = \"\"; char[] chars = plainText.ToCharArray(); foreach(char ch in chars) { string c = (ch % 7).ToString(); es += c; } Console.WriteLine(es); return es; } } FileWriter：文件保存类，充当子系统类。 class FileWriter { public void Write(string encryptStr,string fileNameDes) { Console.WriteLine(\"保存密文，写入文件。\"); FileStream fs = null; try { fs = new FileStream(fileNameDes, FileMode.Create); byte[] str = Encoding.Default.GetBytes(encryptStr); fs.Write(str,0,str.Length); fs.Flush(); fs.Close(); } catch(FileNotFoundException e) { Console.WriteLine(\"文件不存在！\"); } catch(IOException e) { Console.WriteLine(e.Message); Console.WriteLine(\"文件操作错误！\"); } } } EncryptFacade：加密外观类，充当外观类。 class EncryptFacade { //维持对其他对象的引用 private FileReader reader; private CipherMachine cipher; private FileWriter writer; public EncryptFacade() { reader = new FileReader(); cipher = new CipherMachine(); writer = new FileWriter(); } //调用其他对象的业务方法 public void FileEncrypt(string fileNameSrc, string fileNameDes) { string plainStr = reader.Read(fileNameSrc); string encryptStr = cipher.Encrypt(plainStr); writer.Write(encryptStr, fileNameDes); } } Program：客户端测试类 class Program { static void Main(string[] args) { EncryptFacade ef = new EncryptFacade(); ef.FileEncrypt(\"src.txt\", \"des.txt\"); Console.Read(); } } 五、外观模式的优点 ●　　松散耦合 外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。 ●　　简单易用 外观模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观类交互就可以了。 ●　　更好的划分访问层次 通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到外观中，这样既方便客户端使用，也很好地隐藏了内部的细节。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Structural-Patterns/Decorator-Pattern.html":{"url":"design-mode/Structural-Patterns/Decorator-Pattern.html","title":"装饰者模式","keywords":"","body":"一、装饰者模式的概念 装饰者模式又名包装(Wrapper)模式。装饰者模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。 装饰者模式动态地将责任附加到对象身上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 二、装饰者模式的结构 装饰者模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰者模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。 　　装饰者模式的类图如下： 　在装饰模式中的角色有： 　　●　　抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。 　　●　　具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。 　　●　　装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 　　●　　具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。抽象构件角色 public interface Component { public void sampleOperation(); } 具体构件角色 public class ConcreteComponent implements Component { @Override public void sampleOperation() { // 写相关的业务代码 } } 装饰角色 public class Decorator implements Component{ private Component component; public Decorator(Component component){ this.component = component; } @Override public void sampleOperation() { // 委派给构件 component.sampleOperation(); } } 具体装饰角色 public class ConcreteDecoratorA extends Decorator { public ConcreteDecoratorA(Component component) { super(component); } @Override public void sampleOperation() { // 写相关的业务代码 　　　super.sampleOperation(); // 写相关的业务代码 } } 三、装饰者模式实例演示 齐天大圣的例子孙悟空有七十二般变化，他的每一种变化都给他带来一种附加的本领。他变成鱼儿时，就可以到水里游泳；他变成鸟儿时，就可以在天上飞行。 本例中，Component的角色便由鼎鼎大名的齐天大圣扮演；ConcreteComponent的角色属于大圣的本尊，就是猢狲本人；Decorator的角色由大圣的七十二变扮演。而ConcreteDecorator的角色便是鱼儿、鸟儿等七十二般变化。 抽象构件角色“齐天大圣”接口定义了一个move()方法，这是所有的具体构件类和装饰类必须实现的。 //大圣的尊号 public interface TheGreatestSage { public void move(); } 具体构件角色“大圣本尊”猢狲类 public class Monkey implements TheGreatestSage { @Override public void move() { //代码 System.out.println(\"Monkey Move\"); } } 抽象装饰角色“七十二变” public class Change implements TheGreatestSage { private TheGreatestSage sage; public Change(TheGreatestSage sage){ this.sage = sage; } @Override public void move() { // 代码 sage.move(); } } 具体装饰角色“鱼儿” public class Fish extends Change { public Fish(TheGreatestSage sage) { super(sage); } @Override public void move() { // 代码 System.out.println(\"Fish Move\"); } } 具体装饰角色“鸟儿” public class Bird extends Change { public Bird(TheGreatestSage sage) { super(sage); } @Override public void move() { // 代码 System.out.println(\"Bird Move\"); } } 客户端调用 public class Client { public static void main(String[] args) { TheGreatestSage sage = new Monkey(); // 第一种写法 单层装饰 TheGreatestSage bird = new Bird(sage); TheGreatestSage fish = new Fish(bird); // 第二种写法 双层装饰 //TheGreatestSage fish = new Fish(new Bird(sage)); fish.move(); } } “大圣本尊”是ConcreteComponent类，而“鸟儿”、“鱼儿”是装饰类。要装饰的是“大圣本尊”，也即“猢狲”实例。 上面的例子中，第二种些方法：系统把大圣从一只猢狲装饰成了一只鸟儿（把鸟儿的功能加到了猢狲身上），然后又把鸟儿装饰成了一条鱼儿（把鱼儿的功能加到了猢狲+鸟儿身上，得到了猢狲+鸟儿+鱼儿）。 如上图所示，大圣的变化首先将鸟儿的功能附加到了猢狲身上，然后又将鱼儿的功能附加到猢狲+鸟儿身上。 四、装饰者模式的一些变化 1.装饰者模式的简化 大多数情况下，装饰者模式的实现都要比上面给出的示意性例子要简单。 如果只有一个ConcreteComponent类，那么可以考虑去掉抽象的Component类（接口），把Decorator作为一个ConcreteComponent子类。如下图所示： 如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。如下图所示： 2.透明性的要求 装饰者模式对客户端的透明性要求程序不要声明一个ConcreteComponent类型的变量，而应当声明一个Component类型的变量。 用孙悟空的例子来说，必须永远把孙悟空的所有变化都当成孙悟空来对待，而如果把老孙变成的鱼儿当成鱼儿，而不是老孙，那就被老孙骗了，而这时不应当发生的。下面的做法是对的： TheGreatestSage sage = new Monkey(); TheGreatestSage bird = new Bird(sage); 而下面的做法是不对的： Monkey sage = new Monkey(); Bird bird = new Bird(sage); 3.半透明的装饰者模式 然而，纯粹的装饰者模式很难找到。装饰者模式的用意是在不改变接口的前提下，增强所考虑的类的性能。在增强性能的时候，往往需要建立新的公开的方法。即便是在孙大圣的系统里，也需要新的方法。比如齐天大圣类并没有飞行的能力，而鸟儿有。这就意味着鸟儿应当有一个新的fly()方法。再比如，齐天大圣类并没有游泳的能力，而鱼儿有，这就意味着在鱼儿类里应当有一个新的swim()方法。 这就导致了大多数的装饰者模式的实现都是“半透明”的，而不是完全透明的。换言之，允许装饰者模式改变接口，增加新的方法。这意味着客户端可以声明ConcreteDecorator类型的变量，从而可以调用ConcreteDecorator类中才有的方法： TheGreatestSage sage = new Monkey(); Bird bird = new Bird(sage); bird.fly(); 半透明的装饰者模式是介于装饰者模式和适配器模式之间的。适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。大多数的装饰者模式实际上是半透明的装饰者模式，这样的装饰者模式也称做半装饰、半适配器模式。 五、装饰者模式的优缺点 装饰模式的优点 　　（1）装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。 　　（2）通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。 装饰模式的缺点 　　由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。 六、装饰者模式在Java IO流中的应用 装饰者模式在Java语言中的最著名的应用莫过于Java I/O标准库的设计了。 由于Java I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。而如果采用装饰者模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰者模式是Java I/O库的基本模式。 Java I/O库的对象结构图如下，由于Java I/O的对象众多，因此只画出InputStream的部分。 根据上图可以看出： 　　●　　抽象构件(Component)角色：由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。 　　●　　具体构件(ConcreteComponent)角色：由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。 　　●　　抽象装饰(Decorator)角色：由FilterInputStream扮演。它实现了InputStream所规定的接口。 　　●　　具体装饰(ConcreteDecorator)角色：由几个类扮演，分别是BufferedInputStream、DataInputStream以及两个不常用到的类LineNumberInputStream、PushbackInputStream。 半透明的装饰者模式 装饰者模式和适配器模式都是“包装模式(Wrapper Pattern)”，它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。 理想的装饰者模式在对被装饰对象进行功能增强的同时，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。而适配器模式则不然，一般而言，适配器模式并不要求对源对象的功能进行增强，但是会改变源对象的接口，以便和目标接口相符合。 装饰者模式有透明和半透明两种，这两种的区别就在于装饰角色的接口与抽象构件角色的接口是否完全一致。透明的装饰者模式也就是理想的装饰者模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。相反，如果装饰角色的接口与抽象构件角色接口不一致，也就是说装饰角色的接口比抽象构件角色的接口宽的话，装饰角色实际上已经成了一个适配器角色，这种装饰者模式也是可以接受的，称为“半透明”的装饰模式，如下图所示。 在适配器模式里面，适配器类的接口通常会与目标类的接口重叠，但往往并不完全相同。换言之，适配器类的接口会比被装饰的目标类接口宽。 显然，半透明的装饰者模式实际上就是处于适配器模式与装饰者模式之间的灰色地带。如果将装饰者模式与适配器模式合并成为一个“包装模式”的话，那么半透明的装饰者模式倒可以成为这种合并后的“包装模式”的代表。 InputStream类型中的装饰者模式 InputStream类型中的装饰者模式是半透明的。为了说明这一点，不妨看一看作装饰者模式的抽象构件角色的InputStream的源代码。这个抽象类声明了九个方法，并给出了其中八个的实现，另外一个是抽象方法，需要由子类实现。 public abstract class InputStream implements Closeable { public abstract int read() throws IOException; public int read(byte b[]) throws IOException {} public int read(byte b[], int off, int len) throws IOException {} public long skip(long n) throws IOException {} public int available() throws IOException {} public void close() throws IOException {} public synchronized void mark(int readlimit) {} public synchronized void reset() throws IOException {} public boolean markSupported() {} } 下面是作为装饰模式的抽象装饰角色FilterInputStream类的源代码。可以看出，FilterInputStream的接口与InputStream的接口是完全一致的。也就是说，直到这一步，还是与装饰模式相符合的。 public class FilterInputStream extends InputStream { protected FilterInputStream(InputStream in) {} public int read() throws IOException {} public int read(byte b[]) throws IOException {} public int read(byte b[], int off, int len) throws IOException {} public long skip(long n) throws IOException {} public int available() throws IOException {} public void close() throws IOException {} public synchronized void mark(int readlimit) {} public synchronized void reset() throws IOException {} public boolean markSupported() {} } 下面是具体装饰角色PushbackInputStream的源代码。 public class PushbackInputStream extends FilterInputStream { private void ensureOpen() throws IOException {} public PushbackInputStream(InputStream in, int size) {} public PushbackInputStream(InputStream in) {} public int read() throws IOException {} public int read(byte[] b, int off, int len) throws IOException {} public void unread(int b) throws IOException {} public void unread(byte[] b, int off, int len) throws IOException {} public void unread(byte[] b) throws IOException {} public int available() throws IOException {} public long skip(long n) throws IOException {} public boolean markSupported() {} public synchronized void mark(int readlimit) {} public synchronized void reset() throws IOException {} public synchronized void close() throws IOException {} } 查看源码，你会发现，这个装饰类提供了额外的方法unread()，这就意味着PushbackInputStream是一个半透明的装饰类。换言 之，它破坏了理想的装饰者模式的要求。如果客户端持有一个类型为InputStream对象的引用in的话，那么如果in的真实类型是 PushbackInputStream的话，只要客户端不需要使用unread()方法，那么客户端一般没有问题。但是如果客户端必须使用这个方法，就 必须进行向下类型转换。将in的类型转换成为PushbackInputStream之后才可能调用这个方法。但是，这个类型转换意味着客户端必须知道它 拿到的引用是指向一个类型为PushbackInputStream的对象。这就破坏了使用装饰者模式的原始用意。 现实世界与理论总归是有一段差距的。纯粹的装饰者模式在真实的系统中很难找到。一般所遇到的，都是这种半透明的装饰者模式。 下面是使用I/O流读取文件内容的简单操作示例。 public class IOTest { public static void main(String[] args) throws IOException { // 流式读取文件 DataInputStream dis = null; try{ dis = new DataInputStream( new BufferedInputStream( new FileInputStream(\"test.txt\") ) ); //读取文件内容 byte[] bs = new byte[dis.available()]; dis.read(bs); String content = new String(bs); System.out.println(content); }finally{ dis.close(); } } } 观察上面的代码，会发现最里层是一个FileInputStream对象，然后把它传递给一个BufferedInputStream对象，经过BufferedInputStream处理，再把处理后的对象传递给了DataInputStream对象进行处理，这个过程其实就是装饰器的组装过程，FileInputStream对象相当于原始的被装饰的对象，而BufferedInputStream对象和DataInputStream对象则相当于装饰器。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Structural-Patterns/Proxy-Pattern.html":{"url":"design-mode/Structural-Patterns/Proxy-Pattern.html","title":"代理模式","keywords":"","body":"一、模式定义 代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。 二、模式结构 代理模式包含如下角色： Subject: 抽象主题角色 Proxy: 代理主题角色 RealSubject: 真实主题角色 三、时序图 四、模式的简单实现 抽象对象角色 public abstract class AbstractObject { //操作 public abstract void operation(); } 目标对象角色 public class RealObject extends AbstractObject { @Override public void operation() { //一些操作 System.out.println(\"一些操作\"); } } 代理对象角色 public class ProxyObject extends AbstractObject{ RealObject realObject = new RealObject(); @Override public void operation() { //调用目标对象之前可以做相关操作 System.out.println(\"before\"); realObject.operation(); //调用目标对象之后可以做相关操作 System.out.println(\"after\"); } } 客户端 public class Client { public static void main(String[] args) { AbstractObject obj = new ProxyObject(); obj.operation(); } } 五、代理模式在Binder中的使用 直观来说，Binder是Android中的一个类，它继承了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，etc）和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当你bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。 Binder一个很重要的作用是：将客户端的请求参数通过Parcel包装后传到远程服务端，远程服务端解析数据并执行对应的操作，同时客户端线程挂起，当服务端方法执行完毕后，再将返回结果写入到另外一个Parcel中并将其通过Binder传回到客户端，客户端接收到返回数据的Parcel后，Binder会解析数据包中的内容并将原始结果返回给客户端，至此，整个Binder的工作过程就完成了。由此可见，Binder更像一个数据通道，Parcel对象就在这个通道中跨进程传输，至于双方如何通信，这并不负责，只需要双方按照约定好的规范去打包和解包数据即可。 为了更好地说明Binder，这里我们先手动实现了一个Binder。为了使得逻辑更清晰，这里简化一下，我们来模拟一个银行系统，这个银行提供的功能只有一个：即查询余额，只有传递一个int的id过来，银行就会将你的余额设置为id*10，满足下大家的发财梦。 先定义一个Binder接口 package com.ryg.design.manualbinder; import android.os.IBinder; import android.os.IInterface; import android.os.RemoteException; public interface IBank extends IInterface { static final String DESCRIPTOR = \"com.ryg.design.manualbinder.IBank\"; static final int TRANSACTION_queryMoney = (IBinder.FIRST_CALL_TRANSACTION + 0); public long queryMoney(int uid) throws RemoteException; } 2.创建一个Binder并实现这个上述接口 package com.ryg.design.manualbinder; import android.os.Binder; import android.os.IBinder; import android.os.Parcel; import android.os.RemoteException; public class BankImpl extends Binder implements IBank { public BankImpl() { this.attachInterface(this, DESCRIPTOR); } public static IBank asInterface(IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) && (iin instanceof IBank))) { return ((IBank) iin); } return new BankImpl.Proxy(obj); } @Override public IBinder asBinder() { return this; } @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException { switch (code) { case INTERFACE_TRANSACTION: { reply.writeString(DESCRIPTOR); return true; } case TRANSACTION_queryMoney: { data.enforceInterface(DESCRIPTOR); int uid = data.readInt(); long result = this.queryMoney(uid); reply.writeNoException(); reply.writeLong(result); return true; } } return super.onTransact(code, data, reply, flags); } @Override public long queryMoney(int uid) throws RemoteException { return uid * 10l; } private static class Proxy implements IBank { private IBinder mRemote; Proxy(IBinder remote) { mRemote = remote; } @Override public IBinder asBinder() { return mRemote; } public java.lang.String getInterfaceDescriptor() { return DESCRIPTOR; } @Override public long queryMoney(int uid) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); long result; try { data.writeInterfaceToken(DESCRIPTOR); data.writeInt(uid); mRemote.transact(TRANSACTION_queryMoney, data, reply, 0); reply.readException(); result = reply.readLong(); } finally { reply.recycle(); data.recycle(); } return result; } } } ok，到此为止，我们的Binder就完成了，这里只要创建服务端和客户端，二者就能通过我们的Binder来通信了。这里就不做这个示例了，我们的目的是分析代理模式在Binder中的使用。 我们看上述Binder的实现中，有一个叫做“Proxy”的类，它的构造方法如下： Proxy(IBinder remote) { mRemote = remote; } Proxy类接收一个IBinder参数，这个参数实际上就是服务端Service中的onBind方法返回的Binder对象在客户端重新打包后的结果，因为客户端无法直接通过这个打包的Binder和服务端通信，因此客户端必须借助Proxy类来和服务端通信，这里Proxy的作用就是代理的作用，客户端所有的请求全部通过Proxy来代理，具体工作流程为：Proxy接收到客户端的请求后，会将客户端的请求参数打包到Parcel对象中，然后将Parcel对象通过它内部持有的Ibinder对象传送到服务端，服务端接收数据、执行方法后返回结果给客户端的Proxy，Proxy解析数据后返回给客户端的真正调用者。很显然，上述所分析的就是典型的代理模式。至于Binder如何传输数据，这涉及到很底层的知识，这个很难搞懂，但是数据传输的核心思想是共享内存。 六、优缺点 优点 给对象增加了本地化的扩展性，增加了存取操作控制 缺点 会产生多余的代理类 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Behavioral-Pattern.html":{"url":"design-mode/Behavioral-Pattern.html","title":"行为型模式","keywords":"","body":"一、前言 行为型模式 行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。 行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。 行为型模式分为类行为型模式和对象行为型模式两种： 类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。 对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。 包含模式 职责链模式(Chain of Responsibility) 命令模式(Command) 解释器模式(Interpreter) 迭代器模式(Iterator) 中介者模式(Mediator) 备忘录模式(Memento) 观察者模式(Observer) 状态模式(State) 策略模式(Strategy) 模板方法模式(Template Method) 访问者模式(Visitor) 二、目录 本部分没有包含以上所有模式，仅介绍了几种常用的。 命令模式 迭代器模式 观察者模式 策略模式 模板方法模式 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Behavioral-Pattern/Command-Pattern.html":{"url":"design-mode/Behavioral-Pattern/Command-Pattern.html","title":"命令模式","keywords":"","body":"一、命令模式的概念 命令模式属于对象的行为模式。命令模式又称为行动(Action)模式或交易(Transaction)模式。 命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，具有请求排队或者记录请求日志，提供命令的撤销和恢复的功能。 命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。 二、命令模式的结构 命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。 每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。 下面以一个示意性的系统，说明命令模式的结构。 命令模式涉及到五个角色，它们分别是： ●　　客户端(Client)角色：创建请求者，接收者以及命令对象，执行具体逻辑。 ●　　命令(Command)角色：声明了一个给所有具体命令类的抽象接口。 ●　　具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。 ●　　请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。 ●　　接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。 时序图 接收者角色类 public class Receiver { /** * 真正执行命令相应的操作 */ public void action(){ System.out.println(\"执行操作\"); } } 抽象命令角色类 public interface Command { /** * 执行方法 */ void execute(); } 具体命令角色类 public class ConcreteCommand implements Command { //持有相应的接收者对象 private Receiver receiver = null; /** * 构造方法 */ public ConcreteCommand(Receiver receiver){ this.receiver = receiver; } @Override public void execute() { //通常会转调接收者对象的相应方法，让接收者来真正执行功能 receiver.action(); } } 请求者角色类 public class Invoker { /** * 持有命令对象 */ private Command command = null; /** * 构造方法 */ public Invoker(Command command){ this.command = command; } /** * 行动方法 */ public void action(){ command.execute(); } } 客户端角色类 public class Client { public static void main(String[] args) { //创建接收者 Receiver receiver = new Receiver(); //创建命令对象，设定它的接收者 Command command = new ConcreteCommand(receiver); //创建请求者，把命令对象设置进去 Invoker invoker = new Invoker(command); //执行方法 invoker.action(); } } 三、命令模式的具体实例 AudioPlayer系统 小女孩茱丽(Julia)有一个盒式录音机，此录音机有播音(Play)、倒带(Rewind)和停止(Stop)功能，录音机的键盘便是请求者(Invoker)角色；茱丽(Julia)是客户端角色，而录音机便是接收者角色。Command类扮演抽象命令角色，而PlayCommand、StopCommand和RewindCommand便是具体命令类。茱丽(Julia)不需要知道播音(play)、倒带(rewind)和停止(stop)功能是怎么具体执行的，这些命令执行的细节全都由键盘(Keypad)具体实施。茱丽(Julia)只需要在键盘上按下相应的键便可以了。 录音机是典型的命令模式。录音机按键把客户端与录音机的操作细节分割开来。 接收者角色，由录音机类扮演 public class AudioPlayer { public void play(){ System.out.println(\"播放...\"); } public void rewind(){ System.out.println(\"倒带...\"); } public void stop(){ System.out.println(\"停止...\"); } } 抽象命令角色类 public interface Command { /** * 执行方法 */ public void execute(); } 具体命令角色类 public class PlayCommand implements Command { private AudioPlayer myAudio; public PlayCommand(AudioPlayer audioPlayer){ myAudio = audioPlayer; } /** * 执行方法 */ @Override public void execute() { myAudio.play(); } } public class RewindCommand implements Command { private AudioPlayer myAudio; public RewindCommand(AudioPlayer audioPlayer){ myAudio = audioPlayer; } @Override public void execute() { myAudio.rewind(); } } public class StopCommand implements Command { private AudioPlayer myAudio; public StopCommand(AudioPlayer audioPlayer){ myAudio = audioPlayer; } @Override public void execute() { myAudio.stop(); } } 请求者角色，由键盘类扮演 public class Keypad { private Command playCommand; private Command rewindCommand; private Command stopCommand; public void setPlayCommand(Command playCommand) { this.playCommand = playCommand; } public void setRewindCommand(Command rewindCommand) { this.rewindCommand = rewindCommand; } public void setStopCommand(Command stopCommand) { this.stopCommand = stopCommand; } /** * 执行播放方法 */ public void play(){ playCommand.execute(); } /** * 执行倒带方法 */ public void rewind(){ rewindCommand.execute(); } /** * 执行播放方法 */ public void stop(){ stopCommand.execute(); } } 客户端角色，由茱丽小女孩扮演 public class Julia { public static void main(String[]args){ //创建接收者对象 AudioPlayer audioPlayer = new AudioPlayer(); //创建命令对象 Command playCommand = new PlayCommand(audioPlayer); Command rewindCommand = new RewindCommand(audioPlayer); Command stopCommand = new StopCommand(audioPlayer); //创建请求者对象 Keypad keypad = new Keypad(); keypad.setPlayCommand(playCommand); keypad.setRewindCommand(rewindCommand); keypad.setStopCommand(stopCommand); //测试 keypad.play(); keypad.rewind(); keypad.stop(); keypad.play(); keypad.stop(); } } 运行结果： 四、宏命令 宏命令所谓宏命令简单点说就是包含多个命令的命令，是一个命令的组合。 设想茱丽的录音机有一个记录功能，可以把一个一个的命令记录下来，再在任何需要的时候重新把这些记录下来的命令一次性执行，这就是所谓的宏命令集功能。因此，茱丽的录音机系统现在有四个键，分别为播音、倒带、停止和宏命令功能。此时系统的设计与前面的设计相比有所增强，主要体现在Julia类现在有了一个新方法，用以操作宏命令键。 系统需要一个代表宏命令的接口，以定义出具体宏命令所需要的接口。 public interface MacroCommand extends Command { /** * 宏命令聚集的管理方法 * 可以添加一个成员命令 */ public void add(Command cmd); /** * 宏命令聚集的管理方法 * 可以删除一个成员命令 */ public void remove(Command cmd); } 具体的宏命令MacroAudioCommand类负责把个别的命令合成宏命令。 public class MacroAudioCommand implements MacroCommand { private List commandList = new ArrayList (); /** * 宏命令聚集管理方法 */ @Override public void add(Command cmd) { commandList.add(cmd); } /** * 宏命令聚集管理方法 */ @Override public void remove(Command cmd) { commandList.remove(cmd); } /** * 执行方法 */ @Override public void execute() { for(Command cmd : commandList){ cmd.execute(); } } } 客户端类Julia public class Julia { public static void main(String[]args){ //创建接收者对象 AudioPlayer audioPlayer = new AudioPlayer(); //创建命令对象 Command playCommand = new PlayCommand(audioPlayer); Command rewindCommand = new RewindCommand(audioPlayer); Command stopCommand = new StopCommand(audioPlayer); MacroCommand marco = new MacroAudioCommand(); marco.add(playCommand); marco.add(rewindCommand); marco.add(stopCommand); marco.execute(); } } 这样执行MacroCommand 的execute()方法就会一次性执行多条命令。 五、命令模式的优缺点 优点 　　●　　更松散的耦合 　　命令模式使得发起命令的对象，和具体实现命令的对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。 　　●　　更动态的控制 　　命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。 　　●　　很自然的复合命令 　　命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。 　　●　　更好的扩展性 　　由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。 缺点 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Behavioral-Pattern/Iterator-Pattern.html":{"url":"design-mode/Behavioral-Pattern/Iterator-Pattern.html","title":"迭代器模式","keywords":"","body":"一、迭代器模式定义 迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。 二、迭代器模式结构 迭代器模式涉及到以下几个角色： 　　●　　抽象迭代器(Iterator)角色：此抽象角色定义出遍历元素所需的接口。 　　●　　具体迭代器(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。 　　●　　聚集(Aggregate)角色：此抽象角色给出创建迭代器(Iterator)对象的接口。 　　●　　具体聚集(ConcreteAggregate)角色：实现了创建迭代器(Iterator)对象的接口，返回一个合适的具体迭代器实例。 　　●　　客户端(Client)角色：持有对聚集及其迭代器对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。 抽象聚集角色类，这个角色规定出所有的具体聚集必须实现的接口。迭代器模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代器对象的实例。 public abstract class Aggregate { /** * 工厂方法，创建相应迭代子对象的接口 */ public abstract Iterator createIterator(); } 具体聚集角色类，实现了抽象聚集角色类所要求的接口，也就是createIterator()方法。此外，还有方法getElement()向外界提供聚集元素，而方法size()向外界提供聚集的大小等。 public class ConcreteAggregate extends Aggregate { private Object[] objArray = null; /** * 构造方法，传入聚合对象的具体内容 */ public ConcreteAggregate(Object[] objArray){ this.objArray = objArray; } @Override public Iterator createIterator() { return new ConcreteIterator(this); } /** * 取值方法：向外界提供聚集元素 */ public Object getElement(int index){ if(index 抽象迭代器角色类 public interface Iterator { /** * 迭代方法：移动到第一个元素 */ public void first(); /** * 迭代方法：移动到下一个元素 */ public void next(); /** * 迭代方法：是否为最后一个元素 */ public boolean isDone(); /** * 迭代方法：返还当前元素 */ public Object currentItem(); } 具体迭代器角色类 public class ConcreteIterator implements Iterator { //持有被迭代的具体的聚合对象 private ConcreteAggregate agg; //内部索引，记录当前迭代到的索引位置 private int index = 0; //记录当前聚集对象的大小 private int size = 0; public ConcreteIterator(ConcreteAggregate agg){ this.agg = agg; this.size = agg.size(); index = 0; } /** * 迭代方法：返还当前元素 */ @Override public Object currentItem() { return agg.getElement(index); } /** * 迭代方法：移动到第一个元素 */ @Override public void first() { index = 0; } /** * 迭代方法：是否为最后一个元素 */ @Override public boolean isDone() { return (index > = size); } /** * 迭代方法：移动到下一个元素 */ @Override public void next() { if(index 客户端类 public class Client { public void operation(){ Object[] objArray = {\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\"}; //创建聚合对象 Aggregate agg = new ConcreteAggregate(objArray); //循环输出聚合对象中的值 Iterator it = agg.createIterator(); while(!it.isDone()){ System.out.println(it.currentItem()); it.next(); } } public static void main(String[] args) { Client client = new Client(); client.operation(); } } 三、迭代器模式的应用 如果要问Java中使用最多的一种模式，答案不是单例模式，也不是工厂模式，更不是策略模式，而是迭代器模式，先来看一段代码吧： public static void print(Collection coll){ Iterator it = coll.iterator(); while(it.hasNext()){ String str = (String)it.next(); System.out.println(str); } } 这个方法的作用是循环打印一个字符串集合，里面就用到了迭代器模式，java语言已经完整地实现了迭代器模式，例如List，Set，Map，而迭代器的作用就是把容器中的对象一个一个地遍历出来。 四、迭代器模式的优缺点 优点 ①简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于hash表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。 ②可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。 ③封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。 缺点 对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像ArrayList，我们宁可愿意使用for循环和get方法来遍历集合。 五、迭代器的应用场景 迭代器模式是与集合共生共死的，一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器，就像java中的Collection，List、Set、Map等，这些集合都有自己的迭代器。假如我们要实现一个这样的新的容器，当然也需要引入迭代器模式，给我们的容器实现一个迭代器。 但是，由于容器与迭代器的关系太密切了，所以大多数语言在实现容器的时候都给提供了迭代器，并且这些语言提供的容器和迭代器在绝大多数情况下就可以满足我们的需要，所以现在需要我们自己去实践迭代器模式的场景还是比较少见的，我们只需要使用语言中已有的容器和迭代器就可以了。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Behavioral-Pattern/Observer-Pattern.html":{"url":"design-mode/Behavioral-Pattern/Observer-Pattern.html","title":"观察者模式","keywords":"","body":"一、观察者模式的概念 观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 二、观察者模式的结构 一个软件系统里面包含了各种对象，就像一片欣欣向荣的森林充满了各种生物一样。在一片森林中，各种生物彼此依赖和约束，形成一个个生物链。一种生物的状态变化会造成其他一些生物的相应行动，每一个生物都处于别的生物的互动之中。 同样，一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易于复用，应该选择低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，保证高度的协作。观察者模式是满足这一要求的各种设计方案中最重要的一种。 下面以一个简单的示意性实现为例，讨论观察者模式的结构。 观察者模式所涉及的角色有： 　　●　　抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。 　　●　　具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。 　　●　　抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。 　　●　　具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。 三、观察者模式的代码实现 抽象主题角色类(此处是抽象类，改成接口将会提高复用) public abstract class Subject { /** * 用来保存注册的观察者对象 */ private List list = new ArrayList (); /** * 注册观察者对象 * @param observer 观察者对象 */ public void attach(Observer observer){ list.add(observer); System.out.println(\"Attached an observer\"); } /** * 删除观察者对象 * @param observer 观察者对象 */ public void detach(Observer observer){ list.remove(observer); } /** * 通知所有注册的观察者对象 */ public void nodifyObservers(String newState){ for(Observer observer : list){ observer.update(newState); } } } 具体主题角色类 public class ConcreteSubject extends Subject{ private String state; public String getState() { return state; } public void change(String newState){ state = newState; System.out.println(\"主题状态为：\" + state); //状态发生改变，通知各个观察者 this.nodifyObservers(state); } } 抽象观察者角色类 public interface Observer { /** * 更新接口 * @param state 更新的状态 */ public void update(String state); } 具体观察者角色类 public class ConcreteObserver implements Observer { //观察者的状态 private String observerState; @Override public void update(String state) { /** * 更新观察者的状态，使其与目标的状态保持一致 */ observerState = state; System.out.println(\"状态为：\"+observerState); } } 具体使用： public class Client { public static void main(String[] args) { //创建主题对象 ConcreteSubject subject = new ConcreteSubject(); //创建观察者对象 Observer observer = new ConcreteObserver(); //将观察者对象登记到主题对象上 subject.attach(observer); //改变主题对象的状态 subject.change(\"new state\"); } } 当主题对象的状态改变时，将通知所有观察者，观察者接收到主题对象的通知后，将可以进行其他操作，进行响应。 四、推模型和拉模型 　在观察者模式中，又分为推模型和拉模型两种方式。 　　●　　推模型 　　　　 主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。 　　●　　拉模型 　　　　 主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。 　　根据上面的描述，发现前面的例子就是典型的推模型，下面给出一个拉模型的实例。 拉模型的抽象观察者类 拉模型通常都是把主题对象当做参数传递。 public interface Observer { /** * 更新接口 * @param subject 传入主题对象，方面获取相应的主题对象的状态 */ public void update(Subject subject); } 拉模型的具体观察者类 public class ConcreteObserver implements Observer { //观察者的状态 private String observerState; @Override public void update(Subject subject) { /** * 更新观察者的状态，使其与目标的状态保持一致 */ observerState = ((ConcreteSubject)subject).getState(); System.out.println(\"观察者状态为：\"+observerState); } } 拉模型的抽象主题类拉模型的抽象主题类主要的改变是nodifyObservers()方法。在循环通知观察者的时候，也就是循环调用观察者的update()方法的时候，传入的参数不同了。 public abstract class Subject { /** * 用来保存注册的观察者对象 */ private List list = new ArrayList (); /** * 注册观察者对象 * @param observer 观察者对象 */ public void attach(Observer observer){ list.add(observer); System.out.println(\"Attached an observer\"); } /** * 删除观察者对象 * @param observer 观察者对象 */ public void detach(Observer observer){ list.remove(observer); } /** * 通知所有注册的观察者对象 */ public void nodifyObservers(){ for(Observer observer : list){ observer.update(this); } } } 拉模型的具体主题类跟推模型相比，有一点变化，就是调用通知观察者的方法的时候，不需要传入参数了。 public class ConcreteSubject extends Subject{ private String state; public String getState() { return state; } public void change(String newState){ state = newState; System.out.println(\"主题状态为：\" + state); //状态发生改变，通知各个观察者 this.nodifyObservers(); } } 两种模式的比较 　　■　　推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。 　　■　　推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。 五、JAVA提供的对观察者模式的支持 在JAVA语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成JAVA语言对观察者模式的支持。 Observer接口这个接口只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。 public interface Observer { void update(Observable o, Object arg); } Observable类被观察者类都是java.util.Observable类的子类。java.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。 public class Observable { private boolean changed = false; private Vector obs; /** Construct an Observable with zero Observers. */ public Observable() { obs = new Vector(); } /** * 将一个观察者添加到观察者聚集上面 */ public synchronized void addObserver(Observer o) { if (o == null) throw new NullPointerException(); if (!obs.contains(o)) { obs.addElement(o); } } /** * 将一个观察者从观察者聚集上删除 */ public synchronized void deleteObserver(Observer o) { obs.removeElement(o); } public void notifyObservers() { notifyObservers(null); } /** * 如果本对象有变化（那时hasChanged 方法会返回true） * 调用本方法通知所有登记的观察者，即调用它们的update()方法 * 传入this和arg作为参数 */ public void notifyObservers(Object arg) { Object[] arrLocal; synchronized (this) { if (!changed) return; arrLocal = obs.toArray(); clearChanged(); } for (int i = arrLocal.length-1; i > =0; i--) ((Observer)arrLocal[i]).update(this, arg); } /** * 将观察者聚集清空 */ public synchronized void deleteObservers() { obs.removeAllElements(); } /** * 将“已变化”设置为true */ protected synchronized void setChanged() { changed = true; } /** * 将“已变化”重置为false */ protected synchronized void clearChanged() { changed = false; } /** * 检测本对象是否已变化 */ public synchronized boolean hasChanged() { return changed; } /** * Returns the number of observers of this Observable object. * * @return the number of observers of this object. */ public synchronized int countObservers() { return obs.size(); } } 这个类代表一个被观察者对象，有时称之为主题对象。一个被观察者对象可以有数个观察者对象，每个观察者对象都是实现Observer接口的对象。在被观察者发生变化时，会调用Observable的notifyObservers()方法，此方法调用所有的具体观察者的update()方法，从而使所有的观察者都被通知更新自己。 使用JAVA对观察者模式的支持 这里给出一个非常简单的例子，说明怎样使用JAVA所提供的对观察者模式的支持。在这个例子中，被观察对象叫做Watched；而观察者对象叫做Watcher。Watched对象继承自java.util.Observable类；而Watcher对象实现了java.util.Observer接口。另外有一个Test类扮演客户端角色。被观察者Watched类 public class Watched extends Observable{ private String data = \"\"; public String getData() { return data; } public void setData(String data) { if(!this.data.equals(data)){ this.data = data; setChanged(); notifyObservers(); } } } 观察者Watcher 类 public class Watcher implements Observer{ public Watcher(Observable o){ o.addObserver(this); } @Override public void update(Observable o, Object arg) { System.out.println(\"状态发生改变：\" + ((Watched)o).getData()); } } 具体使用： public static void main(String[] args) { //创建被观察者对象 Watched watched = new Watched(); //创建观察者对象，并将被观察者对象登记 Observer watcher = new Watcher(watched); //给被观察者状态赋值 watched.setData(\"start\"); watched.setData(\"run\"); watched.setData(\"stop\"); } 总结： 观察者模式一般是一对多的情形，本文中篇幅有限，都是一对一的例子。当一对多时，通过Java内置的观察者模式时，通知多个观察者的顺序不是固定的。所以如果依赖此顺序的话，要自己实现观察者模式。同时Java内置的观察者模式中，Observerable是个类，所以在子类继承了该类后就不能继承其他类，导致复用受到限制，自己实现观察者模式时可以设置为接口，提高复用。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Behavioral-Pattern/Strategy-Pattern.html":{"url":"design-mode/Behavioral-Pattern/Strategy-Pattern.html","title":"策略模式","keywords":"","body":"一、策略模式的简介 1.定义 策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。 2.使用场景 针对一个对象，其行为有些是固定的不变的，有些是容易变化的，针对不同情况有不同的表现形式。那么对于这些容易变化的行为，我们不希望将其实现绑定在对象中，而是希望以动态的形式，针对不同情况产生不同的应对策略。那么这个时候就要用到策略模式了。简言之，策略模式就是为了应对对象中复杂多变的行为而产生的。 二、策略模式的结构 策略模式是对算法的包装，是把调用算法的责任（行为）和算法本身（行为实现）分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。下面就以一个示意性的实现讲解策略模式实例的结构。 　　这个模式涉及到三个角色： 　　●　　环境(Context)角色：持有一个Strategy的引用，即具有复杂多变行为的对象。 　　●　　抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 　　●　　具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。 三、具体场景实现 假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。 　　根据描述，折扣是根据以下的几个算法中的一个进行的： 　　算法一：对初级会员没有折扣。 　　算法二：对中级会员提供10%的促销折扣。 　　算法三：对高级会员提供20%的促销折扣。 　　使用策略模式来实现的结构图如下： 抽象折扣类 public interface MemberStrategy { /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double calcPrice(double booksPrice); } 初级会员折扣类 public class PrimaryMemberStrategy implements MemberStrategy { @Override public double calcPrice(double booksPrice) { System.out.println(\"对于初级会员的没有折扣\"); return booksPrice; } } 中级会员折扣类 public class IntermediateMemberStrategy implements MemberStrategy { @Override public double calcPrice(double booksPrice) { System.out.println(\"对于中级会员的折扣为10%\"); return booksPrice * 0.9; } } 高级会员折扣类 public class AdvancedMemberStrategy implements MemberStrategy { @Override public double calcPrice(double booksPrice) { System.out.println(\"对于高级会员的折扣为20%\"); return booksPrice * 0.8; } } 价格类 public class Price { //持有一个具体的策略对象 private MemberStrategy strategy; /** * 构造函数，传入一个具体的策略对象 * @param strategy 具体的策略对象 */ public Price(MemberStrategy strategy){ this.strategy = strategy; } /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double quote(double booksPrice){ return this.strategy.calcPrice(booksPrice); } } 具体调用： public static void main(String[] args) { //选择并创建需要使用的策略对象 MemberStrategy strategy = new AdvancedMemberStrategy(); //创建环境 Price price = new Price(strategy); //计算价格 double quote = price.quote(300); System.out.println(\"图书的最终价格为：\" + quote); } 四、对策略模式的深入认识 策略模式对多态的使用 　　通过让环境类持有一个抽象策略类（超类）的引用，在生成环境类实例对象时，让该引用指向具体的策略子类。再对应的方法调用中，就会通过Java的多态，调用对应策略子类的方法。从而可以相互替换，不需要修改环境类内部的实现。同时，在有新的需求的情况下，也只需要修改策略类即可，降低与环境类之间的耦合度。 策略模式的重心 　　策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。 算法的平等性 　　策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。 　　所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。 运行时策略的唯一性 　　运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。 公有的行为 　　经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。 　　这其实也是典型的将代码向继承等级结构的上方集中的标准做法。 五、策略模式的优缺点 策略模式的优点　　（1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。 　　（2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。 策略模式的缺点　　（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。 　　（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"design-mode/Behavioral-Pattern/Template-Method.html":{"url":"design-mode/Behavioral-Pattern/Template-Method.html","title":"模板方法模式","keywords":"","body":"一、模版方法模式的定义 模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。 二、模版方法模式的结构 模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。 模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。 模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑。模板方法模式的静态结构图如下所示： 这里涉及到两个角色： 抽象模板(Abstract Template)角色有如下责任： ■　　定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。 ■　　定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 具体模板(Concrete Template)角色又如下责任： ■　　实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。 ■　　每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 抽象模板角色类，abstractMethod()、hookMethod()等基本方法是顶级逻辑的组成步骤，这个顶级逻辑由templateMethod()方法代表。 public abstract class AbstractTemplate { /** * 模板方法 */ public void templateMethod(){ //调用基本方法 abstractMethod(); hookMethod(); concreteMethod(); } /** * 基本方法的声明（由子类实现） */ protected abstract void abstractMethod(); /** * 基本方法(空方法) */ protected void hookMethod(){} /** * 基本方法（已经实现） */ private final void concreteMethod(){ //业务相关的代码 } } 具体模板角色类，实现了父类所声明的基本方法，abstractMethod()方法所代表的就是强制子类实现的剩余逻辑，而hookMethod()方法是可选择实现的逻辑，不是必须实现的。 public class ConcreteTemplate extends AbstractTemplate{ //基本方法的实现 @Override public void abstractMethod() { //业务相关的代码 } //重写父类的方法 @Override public void hookMethod() { //业务相关的代码 } } 模板模式的关键是：子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。 每当定义一个新的子类时，不要按照控制流程的思路去想，而应当按照“责任”的思路去想。换言之，应当考虑哪些操作是必须置换掉的，哪些操作是可以置换掉的，以及哪些操作是不可以置换掉的。使用模板模式可以使这些责任变得清晰。 三、模板方法模式中的方法 模板方法中的方法可以分为两大类：模板方法和基本方法。 模板方法 一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。 一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。 基本方法 基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。 ●　　抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。 ●　　具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。 ●　　钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。 在上面的例子中，AbstractTemplate是一个抽象类，它带有三个方法。其中abstractMethod()是一个抽象方法，它由抽象类声明为抽象方法，并由子类实现；hookMethod()是一个钩子方法，它由抽象类声明并提供默认实现，并且由子类置换掉。concreteMethod()是一个具体方法，它由抽象类声明并实现。 默认钩子方法 一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook”。具体模版类中可以选择是否重写钩子方法，通常重写钩子方法是为了对模版方法中的步骤进行控制，判断钩子方法中的状态，是否进行下一步操作。 四、模版方法的具体实例 考虑一个计算存款利息的例子。假设系统需要支持两种存款账号，即货币市场(Money Market)账号和定期存款(Certificate of Deposite)账号。这两种账号的存款利息是不同的，因此，在计算一个存户的存款利息额时，必须区分两种不同的账号类型。 这个系统的总行为应当是计算出利息，这也就决定了作为一个模板方法模式的顶级逻辑应当是利息计算。由于利息计算涉及到两个步骤：一个基本方法给出账号种类，另一个基本方法给出利息百分比。这两个基本方法构成具体逻辑，因为账号的类型不同，所以具体逻辑会有所不同。 显然，系统需要一个抽象角色给出顶级行为的实现，而将两个作为细节步骤的基本方法留给具体子类实现。由于需要考虑的账号有两种：一是货币市场账号，二是定期存款账号。系统的类结构如下图所示。 抽象模板角色类 public abstract class Account { /** * 模板方法，计算利息数额 * @return 返回利息数额 */ public final double calculateInterest(){ double interestRate = doCalculateInterestRate(); String accountType = doCalculateAccountType(); double amount = calculateAmount(accountType); return amount * interestRate; } /** * 基本方法留给子类实现 */ protected abstract String doCalculateAccountType(); /** * 基本方法留给子类实现 */ protected abstract double doCalculateInterestRate(); /** * 基本方法，已经实现 */ private double calculateAmount(String accountType){ /** * 省略相关的业务逻辑 */ return 7243.00; } } 具体模板角色类 public class MoneyMarketAccount extends Account { @Override protected String doCalculateAccountType() { return \"Money Market\"; } @Override protected double doCalculateInterestRate() { return 0.045; } } public class CDAccount extends Account { @Override protected String doCalculateAccountType() { return \"Certificate of Deposite\"; } @Override protected double doCalculateInterestRate() { return 0.06; } } 客户端类 public class Client { public static void main(String[] args) { Account account = new MoneyMarketAccount(); System.out.println(\"货币市场账号的利息数额为：\" + account.calculateInterest()); account = new CDAccount(); System.out.println(\"定期账号的利息数额为：\" + account.calculateInterest()); } } 五、模板方法模式效果与适用场景 模板方法模式是基于继承的代码复用技术，它体现了面向对象的诸多重要思想，是一种使用较为频繁的模式。模板方法模式广泛应用于框架设计中，以确保通过父类来控制处理流程的逻辑顺序（如框架的初始化，测试流程的设置等）。 在以下情况下可以考虑使用模板方法模式： (1) 对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。 (2) 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。 (3) 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。 六、模版方法模式的优缺点 优点 (1) 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。 (2) 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。 (3) 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。 (4) 在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。 缺点 需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"computer-networks/tcpip.html":{"url":"computer-networks/tcpip.html","title":"TCP/IP","keywords":"","body":" 一、TCP/IP模型 TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。 基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。 TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp，等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。 上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。 上图以HTTP协议为例，具体说明。 二、数据链路层 物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点，这些节点是通过MAC来唯一标识的(MAC，物理地址，一个主机会有一个MAC地址)。 封装成帧：把网络层数据报加头和尾，封装成帧，帧头中包括源MAC地址和目的MAC地址。 透明传输：零比特填充、转义字符。 可靠传输：在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。 差错检测(CRC)：接收者检测错误,如果发现差错，丢弃该帧。 三、网络层 1.IP协议 IP协议是TCP/IP协议的核心，所有的TCP，UDP，ICMP，IGCP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议——TCP或UDP要做的事情。 1.1 IP地址 在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。 32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。 A类IP地址：1.0.0.0~127.0.0.0 B类IP地址：128.0.0.0~191.255.255.255 C类IP地址：192.0.0.0~223.255.255.255 1.2 IP协议头 这里只介绍：八位的TTL（Time To Live）字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。 这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。 2.ARP及RARP协议 ARP 是根据IP地址获取MAC地址的一种协议。 ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。 如果查询的IP-MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址。如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。 而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。 RARP协议的工作与此相反，不做赘述。 3. ICMP协议 IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。 当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。 四、ping ping可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。 例如：当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下: ping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。 ping程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping给出来了传送的时间和TTL的数据。 五、Traceroute Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。 Traceroute的原理非常非常有意思。它收到到目的主机的IP后，首先给目的主机发送一个TTL=1（Time To Live）的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。 六、TCP/UDP TCP/UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。 面向报文 面向报文的传输方式是应用层交给UDP多长的报文，UDP发送多长的报文，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率；若太短，会使IP数据报太小。 面向字节流 面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。 关于拥塞控制，流量控制，是TCP的重点，后面讲解。 TCP和UDP协议的一些应用 什么时候应该使用TCP？ 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 什么时候应该使用UDP？ 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 七、DNS DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。 八、TCP连接的建立与终止 1.三次握手 TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。 回合 说明 第一次握手 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x + 1(Sequence Number + 1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y + 1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 为什么要三次握手？ 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 具体例子——“已失效的连接请求报文段”的产生在这样一种情况下： client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。 例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 2.四次挥手 当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 回合 说明 第一次分手 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为 Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL（MSL：Maximum Segment Lifetime，报文段最大生存时间，详情请见下文介绍）后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要四次分手？ TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 为什么要等待2MSL？ MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。原因有二： 保证TCP协议的全双工连接能够可靠关闭 保证这次连接的重复数据段从网络中消失 第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT状态。当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。 第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中（称为Lost Duplicate），这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接要在TIME_WAIT状态等待2倍MSL，保证本次连接的所有数据都从网络中消失。 九、TCP流量控制 如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。 设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。 从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。 TCP为每一个连接设有一个持续计时器(persistence timer)。当TCP连接中的发送方收到接收方的零窗口通知时，发送方就启动持续计时器。若持续计时器设置的时间到期，发送方就发送一个零窗口控测报文段（携1字节的数据）给接收方。如果接收方可以接收数据，就重新开始发送数据；如果接收方不能接收数据，就重新设置持续计时器。 十、TCP拥塞控制 1.慢开始和拥塞避免 发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 慢开始算法： 当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。 因此，较好的方法是，先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。 通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS（Maximum Segment Size，最大报文长度）的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值（底数为2的指数增长规律）。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。 每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 一个传输轮次所经历的时间其实就是往返时间RTT。 不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。 另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下： 当 cwnd 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。 拥塞避免 让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性增长规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。 这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。 如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。 2.快重传和快恢复 快重传 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。 接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。 显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。 但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。 快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。 由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。 快恢复 与快重传配合使用的还有快恢复算法，其过程有以下两个要点： 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。 与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"computer-networks/http.html":{"url":"computer-networks/http.html","title":"HTTP","keywords":"","body":"一、 HTTP请求和响应步骤 以上完整表示了HTTP请求和响应的7个步骤，下面从TCP/IP协议模型的角度来理解HTTP请求和响应如何传递的。 二、TCP/IP协议 TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。TCP/IP协议簇是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与OSI的七层模型相对应。 HTTP协议就是基于TCP/IP协议模型来传输信息的。 (1). 链路层 也称作数据链路层或网络接口层（在第一个图中为网络接口层和硬件层），通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。 (2). 网络层 也称作互联网层（在第一个图中为网际层），处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。 IP是一种网络层协议，提供的是一种不可靠的服务，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。 ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。 IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。 (3). 传输层 主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。 TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。为了提供可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。 UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。一个数据报是指从发送方传输到接收方的一个信息单元（例如，发送方指定的一定字节数的信息）。UDP协议任何必需的可靠性必须由应用层来提供。 (4). 应用层 应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。包括 HTTP，FTP（File Transfer Protocol，文件传输协议），DNS（Domain Name System，域名系统）服务。 当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程如图所示。 当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。协议是通过目的端口号、源I P地址和源端口号进行解包的。 通过以上步骤我们从TCP/IP模型的角度来理解了一次HTTP请求与响应的过程。 下面这张图更清楚明白： 下面具体来看如何进行一步步操作的。 三、TCP三次握手 TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。 回合 说明 第一次握手 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x + 1(Sequence Number + 1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN + ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手 客户端收到服务器的SYN + ACK报文段。然后将Acknowledgment Number设置为y + 1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 为什么要三次握手 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 具体例子： ——“已失效的连接请求报文段”的产生在这样一种情况下： client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。 例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 四、HTTP协议 Http是什么？ 通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。 四个基于： 请求与响应： 客户端发送请求，服务器端响应数据 无状态的： 协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。 应用层： Http是属于应用层的协议，配合TCP/IP使用。 TCP/IP： Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。 针对无状态的一些解决策略： 有时需要对用户之前的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。于是引入了Cookie技术。 HTTP/1.1想出了持久连接（HTTP keep-alive）方法。其特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。等等还有很多…… 下面开始讲解重头戏：HTTP请求报文，响应报文，对应于上述步骤的2，3，4，5，6。 HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。 五、HTTP请求报文 一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。 1.请求行 请求行分为三个部分：请求方法、请求地址和协议版本 请求方法 HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。 请求地址 URL：统一资源定位符，是一种自愿位置的抽象唯一识别方法。 组成：：//：/ 端口和路径有时可以省略（HTTP默认端口号是80） 如下例： 有时会带参数，GET请求 协议版本 协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1 2.请求头部 请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。 常见请求头如下： 请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。 3.请求数据 可选部分，比如GET请求就没有请求数据。 下面是一个POST方法的请求报文： POST 　/index.php　HTTP/1.1 　　 请求行Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-cn,zh;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveReferer:http://localhost/Content-Length：25Content-Type：application/x-www-form-urlencoded　　空行username=aa&password=1234　　请求数据 六、HTTP响应报文 HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。 1.状态行 由3部分组成，分别为：协议版本，状态码，状态码描述。 其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。 状态码 状态代码为3位数字。 1xx：指示信息——表示请求已接收，继续处理。 2xx：成功——表示请求已被成功接收、理解、接受。 3xx：重定向——要完成请求必须进行更进一步的操作。 4xx：客户端错误——请求有语法错误或请求无法实现。 5xx：服务器端错误——服务器未能实现合法的请求。 下面列举几个常见的： 2.响应头部 与请求头部类似，为响应报文添加了一些附加信息 常见响应头部如下： 3.响应数据 用于存放需要返回给客户端的数据信息。 下面是一个响应报文的实例： HTTP/1.1 200 OK　　状态行Date: Sun, 17 Mar 2013 08:12:54 GMT　　响应头部Server: Apache/2.2.8 (Win32) PHP/5.2.5X-Powered-By: PHP/5.2.5Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheContent-Length: 4393Keep-Alive: timeout=5, max=100Connection: Keep-AliveContent-Type: text/html; charset=utf-8　　空行 　　响应数据HTTP响应示例Hello HTTP! 关于请求头部和响应头部的知识点很多，这里只是简单介绍。 通过以上步骤，数据已经传递完毕，HTTP/1.1会维持持久连接，但持续一段时间总会有关闭连接的时候，这时候据需要断开TCP连接。 七、TCP四次挥手 当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 回合 说明 第一次分手 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要四次分手 TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 通过以上步骤便完成了HTTP的请求和响应，进行了数据传递，这其中涉及到需要知识点，都进行了逐一了解。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "},"computer-networks/https.html":{"url":"computer-networks/https.html","title":"HTTPS","keywords":"","body":"我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。 HTTPS简介 HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，且看下图。 1. 客户端发起HTTPS请求 这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。 2. 服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 3. 传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 4. 客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 5. 传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 6. 服务段加密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 7. 传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原 8. 客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。 Copyright © springcitylee 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-06 18:30:01 "}}